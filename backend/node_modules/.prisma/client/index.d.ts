
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model TopDestination
 * 
 */
export type TopDestination = $Result.DefaultSelection<Prisma.$TopDestinationPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Host
 * 
 */
export type Host = $Result.DefaultSelection<Prisma.$HostPayload>
/**
 * Model HostLanguage
 * 
 */
export type HostLanguage = $Result.DefaultSelection<Prisma.$HostLanguagePayload>
/**
 * Model PhotographerSkill
 * 
 */
export type PhotographerSkill = $Result.DefaultSelection<Prisma.$PhotographerSkillPayload>
/**
 * Model PhotographerGear
 * 
 */
export type PhotographerGear = $Result.DefaultSelection<Prisma.$PhotographerGearPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Itinerary
 * 
 */
export type Itinerary = $Result.DefaultSelection<Prisma.$ItineraryPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model CurrencyConversionLog
 * 
 */
export type CurrencyConversionLog = $Result.DefaultSelection<Prisma.$CurrencyConversionLogPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Wishlist
 * 
 */
export type Wishlist = $Result.DefaultSelection<Prisma.$WishlistPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model HostBadge
 * 
 */
export type HostBadge = $Result.DefaultSelection<Prisma.$HostBadgePayload>
/**
 * Model BlockedDate
 * 
 */
export type BlockedDate = $Result.DefaultSelection<Prisma.$BlockedDatePayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model Story
 * 
 */
export type Story = $Result.DefaultSelection<Prisma.$StoryPayload>
/**
 * Model StoryLike
 * 
 */
export type StoryLike = $Result.DefaultSelection<Prisma.$StoryLikePayload>
/**
 * Model StoryComment
 * 
 */
export type StoryComment = $Result.DefaultSelection<Prisma.$StoryCommentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  TRAVELLER: 'TRAVELLER',
  HOST: 'HOST',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ServiceType: {
  GUIDE: 'GUIDE',
  PHOTOGRAPHER: 'PHOTOGRAPHER',
  COMBO: 'COMBO'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const CurrencyCode: {
  IDR: 'IDR',
  USD: 'USD',
  JPY: 'JPY',
  EUR: 'EUR',
  SGD: 'SGD',
  THB: 'THB'
};

export type CurrencyCode = (typeof CurrencyCode)[keyof typeof CurrencyCode]


export const ContactMethod: {
  WHATSAPP: 'WHATSAPP',
  TELEGRAM: 'TELEGRAM',
  LINE: 'LINE',
  EMAIL: 'EMAIL',
  ZOOM: 'ZOOM'
};

export type ContactMethod = (typeof ContactMethod)[keyof typeof ContactMethod]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const StoryType: {
  TRAVELER: 'TRAVELER',
  HOST: 'HOST'
};

export type StoryType = (typeof StoryType)[keyof typeof StoryType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type CurrencyCode = $Enums.CurrencyCode

export const CurrencyCode: typeof $Enums.CurrencyCode

export type ContactMethod = $Enums.ContactMethod

export const ContactMethod: typeof $Enums.ContactMethod

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type StoryType = $Enums.StoryType

export const StoryType: typeof $Enums.StoryType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TopDestinations
 * const topDestinations = await prisma.topDestination.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TopDestinations
   * const topDestinations = await prisma.topDestination.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.topDestination`: Exposes CRUD operations for the **TopDestination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopDestinations
    * const topDestinations = await prisma.topDestination.findMany()
    * ```
    */
  get topDestination(): Prisma.TopDestinationDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.host`: Exposes CRUD operations for the **Host** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hosts
    * const hosts = await prisma.host.findMany()
    * ```
    */
  get host(): Prisma.HostDelegate<ExtArgs>;

  /**
   * `prisma.hostLanguage`: Exposes CRUD operations for the **HostLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HostLanguages
    * const hostLanguages = await prisma.hostLanguage.findMany()
    * ```
    */
  get hostLanguage(): Prisma.HostLanguageDelegate<ExtArgs>;

  /**
   * `prisma.photographerSkill`: Exposes CRUD operations for the **PhotographerSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotographerSkills
    * const photographerSkills = await prisma.photographerSkill.findMany()
    * ```
    */
  get photographerSkill(): Prisma.PhotographerSkillDelegate<ExtArgs>;

  /**
   * `prisma.photographerGear`: Exposes CRUD operations for the **PhotographerGear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotographerGears
    * const photographerGears = await prisma.photographerGear.findMany()
    * ```
    */
  get photographerGear(): Prisma.PhotographerGearDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.itinerary`: Exposes CRUD operations for the **Itinerary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itineraries
    * const itineraries = await prisma.itinerary.findMany()
    * ```
    */
  get itinerary(): Prisma.ItineraryDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.currencyConversionLog`: Exposes CRUD operations for the **CurrencyConversionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurrencyConversionLogs
    * const currencyConversionLogs = await prisma.currencyConversionLog.findMany()
    * ```
    */
  get currencyConversionLog(): Prisma.CurrencyConversionLogDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **Wishlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wishlists
    * const wishlists = await prisma.wishlist.findMany()
    * ```
    */
  get wishlist(): Prisma.WishlistDelegate<ExtArgs>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs>;

  /**
   * `prisma.hostBadge`: Exposes CRUD operations for the **HostBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HostBadges
    * const hostBadges = await prisma.hostBadge.findMany()
    * ```
    */
  get hostBadge(): Prisma.HostBadgeDelegate<ExtArgs>;

  /**
   * `prisma.blockedDate`: Exposes CRUD operations for the **BlockedDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedDates
    * const blockedDates = await prisma.blockedDate.findMany()
    * ```
    */
  get blockedDate(): Prisma.BlockedDateDelegate<ExtArgs>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs>;

  /**
   * `prisma.story`: Exposes CRUD operations for the **Story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stories
    * const stories = await prisma.story.findMany()
    * ```
    */
  get story(): Prisma.StoryDelegate<ExtArgs>;

  /**
   * `prisma.storyLike`: Exposes CRUD operations for the **StoryLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryLikes
    * const storyLikes = await prisma.storyLike.findMany()
    * ```
    */
  get storyLike(): Prisma.StoryLikeDelegate<ExtArgs>;

  /**
   * `prisma.storyComment`: Exposes CRUD operations for the **StoryComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryComments
    * const storyComments = await prisma.storyComment.findMany()
    * ```
    */
  get storyComment(): Prisma.StoryCommentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TopDestination: 'TopDestination',
    Country: 'Country',
    City: 'City',
    Language: 'Language',
    User: 'User',
    Host: 'Host',
    HostLanguage: 'HostLanguage',
    PhotographerSkill: 'PhotographerSkill',
    PhotographerGear: 'PhotographerGear',
    Service: 'Service',
    Itinerary: 'Itinerary',
    Booking: 'Booking',
    CurrencyConversionLog: 'CurrencyConversionLog',
    Review: 'Review',
    Wishlist: 'Wishlist',
    PromoCode: 'PromoCode',
    HostBadge: 'HostBadge',
    BlockedDate: 'BlockedDate',
    Referral: 'Referral',
    Story: 'Story',
    StoryLike: 'StoryLike',
    StoryComment: 'StoryComment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "topDestination" | "country" | "city" | "language" | "user" | "host" | "hostLanguage" | "photographerSkill" | "photographerGear" | "service" | "itinerary" | "booking" | "currencyConversionLog" | "review" | "wishlist" | "promoCode" | "hostBadge" | "blockedDate" | "referral" | "story" | "storyLike" | "storyComment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      TopDestination: {
        payload: Prisma.$TopDestinationPayload<ExtArgs>
        fields: Prisma.TopDestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopDestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopDestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>
          }
          findFirst: {
            args: Prisma.TopDestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopDestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>
          }
          findMany: {
            args: Prisma.TopDestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>[]
          }
          create: {
            args: Prisma.TopDestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>
          }
          createMany: {
            args: Prisma.TopDestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopDestinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>[]
          }
          delete: {
            args: Prisma.TopDestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>
          }
          update: {
            args: Prisma.TopDestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>
          }
          deleteMany: {
            args: Prisma.TopDestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopDestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopDestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopDestinationPayload>
          }
          aggregate: {
            args: Prisma.TopDestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopDestination>
          }
          groupBy: {
            args: Prisma.TopDestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopDestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopDestinationCountArgs<ExtArgs>
            result: $Utils.Optional<TopDestinationCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Host: {
        payload: Prisma.$HostPayload<ExtArgs>
        fields: Prisma.HostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>
          }
          findFirst: {
            args: Prisma.HostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>
          }
          findMany: {
            args: Prisma.HostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>[]
          }
          create: {
            args: Prisma.HostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>
          }
          createMany: {
            args: Prisma.HostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>[]
          }
          delete: {
            args: Prisma.HostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>
          }
          update: {
            args: Prisma.HostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>
          }
          deleteMany: {
            args: Prisma.HostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostPayload>
          }
          aggregate: {
            args: Prisma.HostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHost>
          }
          groupBy: {
            args: Prisma.HostGroupByArgs<ExtArgs>
            result: $Utils.Optional<HostGroupByOutputType>[]
          }
          count: {
            args: Prisma.HostCountArgs<ExtArgs>
            result: $Utils.Optional<HostCountAggregateOutputType> | number
          }
        }
      }
      HostLanguage: {
        payload: Prisma.$HostLanguagePayload<ExtArgs>
        fields: Prisma.HostLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HostLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HostLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>
          }
          findFirst: {
            args: Prisma.HostLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HostLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>
          }
          findMany: {
            args: Prisma.HostLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>[]
          }
          create: {
            args: Prisma.HostLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>
          }
          createMany: {
            args: Prisma.HostLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HostLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>[]
          }
          delete: {
            args: Prisma.HostLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>
          }
          update: {
            args: Prisma.HostLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>
          }
          deleteMany: {
            args: Prisma.HostLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HostLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HostLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostLanguagePayload>
          }
          aggregate: {
            args: Prisma.HostLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHostLanguage>
          }
          groupBy: {
            args: Prisma.HostLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<HostLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.HostLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<HostLanguageCountAggregateOutputType> | number
          }
        }
      }
      PhotographerSkill: {
        payload: Prisma.$PhotographerSkillPayload<ExtArgs>
        fields: Prisma.PhotographerSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotographerSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotographerSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>
          }
          findFirst: {
            args: Prisma.PhotographerSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotographerSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>
          }
          findMany: {
            args: Prisma.PhotographerSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>[]
          }
          create: {
            args: Prisma.PhotographerSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>
          }
          createMany: {
            args: Prisma.PhotographerSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhotographerSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>[]
          }
          delete: {
            args: Prisma.PhotographerSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>
          }
          update: {
            args: Prisma.PhotographerSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>
          }
          deleteMany: {
            args: Prisma.PhotographerSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotographerSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhotographerSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerSkillPayload>
          }
          aggregate: {
            args: Prisma.PhotographerSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotographerSkill>
          }
          groupBy: {
            args: Prisma.PhotographerSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotographerSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotographerSkillCountArgs<ExtArgs>
            result: $Utils.Optional<PhotographerSkillCountAggregateOutputType> | number
          }
        }
      }
      PhotographerGear: {
        payload: Prisma.$PhotographerGearPayload<ExtArgs>
        fields: Prisma.PhotographerGearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotographerGearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotographerGearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>
          }
          findFirst: {
            args: Prisma.PhotographerGearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotographerGearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>
          }
          findMany: {
            args: Prisma.PhotographerGearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>[]
          }
          create: {
            args: Prisma.PhotographerGearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>
          }
          createMany: {
            args: Prisma.PhotographerGearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhotographerGearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>[]
          }
          delete: {
            args: Prisma.PhotographerGearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>
          }
          update: {
            args: Prisma.PhotographerGearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>
          }
          deleteMany: {
            args: Prisma.PhotographerGearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotographerGearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhotographerGearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotographerGearPayload>
          }
          aggregate: {
            args: Prisma.PhotographerGearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotographerGear>
          }
          groupBy: {
            args: Prisma.PhotographerGearGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotographerGearGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotographerGearCountArgs<ExtArgs>
            result: $Utils.Optional<PhotographerGearCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Itinerary: {
        payload: Prisma.$ItineraryPayload<ExtArgs>
        fields: Prisma.ItineraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItineraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findFirst: {
            args: Prisma.ItineraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findMany: {
            args: Prisma.ItineraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          create: {
            args: Prisma.ItineraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          createMany: {
            args: Prisma.ItineraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItineraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          delete: {
            args: Prisma.ItineraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          update: {
            args: Prisma.ItineraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItineraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          aggregate: {
            args: Prisma.ItineraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItinerary>
          }
          groupBy: {
            args: Prisma.ItineraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItineraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryCountArgs<ExtArgs>
            result: $Utils.Optional<ItineraryCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      CurrencyConversionLog: {
        payload: Prisma.$CurrencyConversionLogPayload<ExtArgs>
        fields: Prisma.CurrencyConversionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyConversionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyConversionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>
          }
          findFirst: {
            args: Prisma.CurrencyConversionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyConversionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>
          }
          findMany: {
            args: Prisma.CurrencyConversionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>[]
          }
          create: {
            args: Prisma.CurrencyConversionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>
          }
          createMany: {
            args: Prisma.CurrencyConversionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyConversionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>[]
          }
          delete: {
            args: Prisma.CurrencyConversionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>
          }
          update: {
            args: Prisma.CurrencyConversionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyConversionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyConversionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CurrencyConversionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyConversionLogPayload>
          }
          aggregate: {
            args: Prisma.CurrencyConversionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrencyConversionLog>
          }
          groupBy: {
            args: Prisma.CurrencyConversionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyConversionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyConversionLogCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyConversionLogCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Wishlist: {
        payload: Prisma.$WishlistPayload<ExtArgs>
        fields: Prisma.WishlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findFirst: {
            args: Prisma.WishlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findMany: {
            args: Prisma.WishlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          create: {
            args: Prisma.WishlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          createMany: {
            args: Prisma.WishlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          delete: {
            args: Prisma.WishlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          update: {
            args: Prisma.WishlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          deleteMany: {
            args: Prisma.WishlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WishlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          aggregate: {
            args: Prisma.WishlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlist>
          }
          groupBy: {
            args: Prisma.WishlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      HostBadge: {
        payload: Prisma.$HostBadgePayload<ExtArgs>
        fields: Prisma.HostBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HostBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HostBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>
          }
          findFirst: {
            args: Prisma.HostBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HostBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>
          }
          findMany: {
            args: Prisma.HostBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>[]
          }
          create: {
            args: Prisma.HostBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>
          }
          createMany: {
            args: Prisma.HostBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HostBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>[]
          }
          delete: {
            args: Prisma.HostBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>
          }
          update: {
            args: Prisma.HostBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>
          }
          deleteMany: {
            args: Prisma.HostBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HostBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HostBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HostBadgePayload>
          }
          aggregate: {
            args: Prisma.HostBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHostBadge>
          }
          groupBy: {
            args: Prisma.HostBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<HostBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.HostBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<HostBadgeCountAggregateOutputType> | number
          }
        }
      }
      BlockedDate: {
        payload: Prisma.$BlockedDatePayload<ExtArgs>
        fields: Prisma.BlockedDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>
          }
          findFirst: {
            args: Prisma.BlockedDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>
          }
          findMany: {
            args: Prisma.BlockedDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>[]
          }
          create: {
            args: Prisma.BlockedDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>
          }
          createMany: {
            args: Prisma.BlockedDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>[]
          }
          delete: {
            args: Prisma.BlockedDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>
          }
          update: {
            args: Prisma.BlockedDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>
          }
          deleteMany: {
            args: Prisma.BlockedDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockedDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedDatePayload>
          }
          aggregate: {
            args: Prisma.BlockedDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedDate>
          }
          groupBy: {
            args: Prisma.BlockedDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedDateCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedDateCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      Story: {
        payload: Prisma.$StoryPayload<ExtArgs>
        fields: Prisma.StoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findFirst: {
            args: Prisma.StoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findMany: {
            args: Prisma.StoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          create: {
            args: Prisma.StoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          createMany: {
            args: Prisma.StoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          delete: {
            args: Prisma.StoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          update: {
            args: Prisma.StoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          deleteMany: {
            args: Prisma.StoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          aggregate: {
            args: Prisma.StoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStory>
          }
          groupBy: {
            args: Prisma.StoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryCountArgs<ExtArgs>
            result: $Utils.Optional<StoryCountAggregateOutputType> | number
          }
        }
      }
      StoryLike: {
        payload: Prisma.$StoryLikePayload<ExtArgs>
        fields: Prisma.StoryLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>
          }
          findFirst: {
            args: Prisma.StoryLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>
          }
          findMany: {
            args: Prisma.StoryLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>[]
          }
          create: {
            args: Prisma.StoryLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>
          }
          createMany: {
            args: Prisma.StoryLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>[]
          }
          delete: {
            args: Prisma.StoryLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>
          }
          update: {
            args: Prisma.StoryLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>
          }
          deleteMany: {
            args: Prisma.StoryLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoryLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryLikePayload>
          }
          aggregate: {
            args: Prisma.StoryLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryLike>
          }
          groupBy: {
            args: Prisma.StoryLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryLikeCountArgs<ExtArgs>
            result: $Utils.Optional<StoryLikeCountAggregateOutputType> | number
          }
        }
      }
      StoryComment: {
        payload: Prisma.$StoryCommentPayload<ExtArgs>
        fields: Prisma.StoryCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>
          }
          findFirst: {
            args: Prisma.StoryCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>
          }
          findMany: {
            args: Prisma.StoryCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>[]
          }
          create: {
            args: Prisma.StoryCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>
          }
          createMany: {
            args: Prisma.StoryCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>[]
          }
          delete: {
            args: Prisma.StoryCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>
          }
          update: {
            args: Prisma.StoryCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>
          }
          deleteMany: {
            args: Prisma.StoryCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoryCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryCommentPayload>
          }
          aggregate: {
            args: Prisma.StoryCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryComment>
          }
          groupBy: {
            args: Prisma.StoryCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryCommentCountArgs<ExtArgs>
            result: $Utils.Optional<StoryCommentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    cities: number
    users: number
    hosts: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
    users?: boolean | CountryCountOutputTypeCountUsersArgs
    hosts?: boolean | CountryCountOutputTypeCountHostsArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountHostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    users: number
    hosts: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CityCountOutputTypeCountUsersArgs
    hosts?: boolean | CityCountOutputTypeCountHostsArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountHostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    hosts: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hosts?: boolean | LanguageCountOutputTypeCountHostsArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountHostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostLanguageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings: number
    wishlist: number
    stories: number
    storyLikes: number
    storyComments: number
    referrals: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    wishlist?: boolean | UserCountOutputTypeCountWishlistArgs
    stories?: boolean | UserCountOutputTypeCountStoriesArgs
    storyLikes?: boolean | UserCountOutputTypeCountStoryLikesArgs
    storyComments?: boolean | UserCountOutputTypeCountStoryCommentsArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoryLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoryCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }


  /**
   * Count Type HostCountOutputType
   */

  export type HostCountOutputType = {
    languages: number
    services: number
    blockedDates: number
    badges: number
    reviews: number
    photographerSkills: number
    photographerGears: number
  }

  export type HostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    languages?: boolean | HostCountOutputTypeCountLanguagesArgs
    services?: boolean | HostCountOutputTypeCountServicesArgs
    blockedDates?: boolean | HostCountOutputTypeCountBlockedDatesArgs
    badges?: boolean | HostCountOutputTypeCountBadgesArgs
    reviews?: boolean | HostCountOutputTypeCountReviewsArgs
    photographerSkills?: boolean | HostCountOutputTypeCountPhotographerSkillsArgs
    photographerGears?: boolean | HostCountOutputTypeCountPhotographerGearsArgs
  }

  // Custom InputTypes
  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostCountOutputType
     */
    select?: HostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostLanguageWhereInput
  }

  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeCountBlockedDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedDateWhereInput
  }

  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostBadgeWhereInput
  }

  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeCountPhotographerSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotographerSkillWhereInput
  }

  /**
   * HostCountOutputType without action
   */
  export type HostCountOutputTypeCountPhotographerGearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotographerGearWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookings: number
    wishlist: number
    itineraries: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
    wishlist?: boolean | ServiceCountOutputTypeCountWishlistArgs
    itineraries?: boolean | ServiceCountOutputTypeCountItinerariesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountWishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    bookings: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PromoCodeCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type StoryCountOutputType
   */

  export type StoryCountOutputType = {
    likes: number
    comments: number
  }

  export type StoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | StoryCountOutputTypeCountLikesArgs
    comments?: boolean | StoryCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryCountOutputType
     */
    select?: StoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryLikeWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryCommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model TopDestination
   */

  export type AggregateTopDestination = {
    _count: TopDestinationCountAggregateOutputType | null
    _avg: TopDestinationAvgAggregateOutputType | null
    _sum: TopDestinationSumAggregateOutputType | null
    _min: TopDestinationMinAggregateOutputType | null
    _max: TopDestinationMaxAggregateOutputType | null
  }

  export type TopDestinationAvgAggregateOutputType = {
    order: number | null
  }

  export type TopDestinationSumAggregateOutputType = {
    order: number | null
  }

  export type TopDestinationMinAggregateOutputType = {
    id: string | null
    cityId: string | null
    order: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type TopDestinationMaxAggregateOutputType = {
    id: string | null
    cityId: string | null
    order: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type TopDestinationCountAggregateOutputType = {
    id: number
    cityId: number
    order: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type TopDestinationAvgAggregateInputType = {
    order?: true
  }

  export type TopDestinationSumAggregateInputType = {
    order?: true
  }

  export type TopDestinationMinAggregateInputType = {
    id?: true
    cityId?: true
    order?: true
    imageUrl?: true
    createdAt?: true
  }

  export type TopDestinationMaxAggregateInputType = {
    id?: true
    cityId?: true
    order?: true
    imageUrl?: true
    createdAt?: true
  }

  export type TopDestinationCountAggregateInputType = {
    id?: true
    cityId?: true
    order?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type TopDestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopDestination to aggregate.
     */
    where?: TopDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDestinations to fetch.
     */
    orderBy?: TopDestinationOrderByWithRelationInput | TopDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopDestinations
    **/
    _count?: true | TopDestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopDestinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopDestinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopDestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopDestinationMaxAggregateInputType
  }

  export type GetTopDestinationAggregateType<T extends TopDestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateTopDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopDestination[P]>
      : GetScalarType<T[P], AggregateTopDestination[P]>
  }




  export type TopDestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopDestinationWhereInput
    orderBy?: TopDestinationOrderByWithAggregationInput | TopDestinationOrderByWithAggregationInput[]
    by: TopDestinationScalarFieldEnum[] | TopDestinationScalarFieldEnum
    having?: TopDestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopDestinationCountAggregateInputType | true
    _avg?: TopDestinationAvgAggregateInputType
    _sum?: TopDestinationSumAggregateInputType
    _min?: TopDestinationMinAggregateInputType
    _max?: TopDestinationMaxAggregateInputType
  }

  export type TopDestinationGroupByOutputType = {
    id: string
    cityId: string
    order: number
    imageUrl: string | null
    createdAt: Date
    _count: TopDestinationCountAggregateOutputType | null
    _avg: TopDestinationAvgAggregateOutputType | null
    _sum: TopDestinationSumAggregateOutputType | null
    _min: TopDestinationMinAggregateOutputType | null
    _max: TopDestinationMaxAggregateOutputType | null
  }

  type GetTopDestinationGroupByPayload<T extends TopDestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopDestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopDestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopDestinationGroupByOutputType[P]>
            : GetScalarType<T[P], TopDestinationGroupByOutputType[P]>
        }
      >
    >


  export type TopDestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    order?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topDestination"]>

  export type TopDestinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    order?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topDestination"]>

  export type TopDestinationSelectScalar = {
    id?: boolean
    cityId?: boolean
    order?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type TopDestinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type TopDestinationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $TopDestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TopDestination"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityId: string
      order: number
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["topDestination"]>
    composites: {}
  }

  type TopDestinationGetPayload<S extends boolean | null | undefined | TopDestinationDefaultArgs> = $Result.GetResult<Prisma.$TopDestinationPayload, S>

  type TopDestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TopDestinationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopDestinationCountAggregateInputType | true
    }

  export interface TopDestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopDestination'], meta: { name: 'TopDestination' } }
    /**
     * Find zero or one TopDestination that matches the filter.
     * @param {TopDestinationFindUniqueArgs} args - Arguments to find a TopDestination
     * @example
     * // Get one TopDestination
     * const topDestination = await prisma.topDestination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopDestinationFindUniqueArgs>(args: SelectSubset<T, TopDestinationFindUniqueArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TopDestination that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TopDestinationFindUniqueOrThrowArgs} args - Arguments to find a TopDestination
     * @example
     * // Get one TopDestination
     * const topDestination = await prisma.topDestination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopDestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, TopDestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TopDestination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDestinationFindFirstArgs} args - Arguments to find a TopDestination
     * @example
     * // Get one TopDestination
     * const topDestination = await prisma.topDestination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopDestinationFindFirstArgs>(args?: SelectSubset<T, TopDestinationFindFirstArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TopDestination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDestinationFindFirstOrThrowArgs} args - Arguments to find a TopDestination
     * @example
     * // Get one TopDestination
     * const topDestination = await prisma.topDestination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopDestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, TopDestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TopDestinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopDestinations
     * const topDestinations = await prisma.topDestination.findMany()
     * 
     * // Get first 10 TopDestinations
     * const topDestinations = await prisma.topDestination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topDestinationWithIdOnly = await prisma.topDestination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopDestinationFindManyArgs>(args?: SelectSubset<T, TopDestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TopDestination.
     * @param {TopDestinationCreateArgs} args - Arguments to create a TopDestination.
     * @example
     * // Create one TopDestination
     * const TopDestination = await prisma.topDestination.create({
     *   data: {
     *     // ... data to create a TopDestination
     *   }
     * })
     * 
     */
    create<T extends TopDestinationCreateArgs>(args: SelectSubset<T, TopDestinationCreateArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TopDestinations.
     * @param {TopDestinationCreateManyArgs} args - Arguments to create many TopDestinations.
     * @example
     * // Create many TopDestinations
     * const topDestination = await prisma.topDestination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopDestinationCreateManyArgs>(args?: SelectSubset<T, TopDestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TopDestinations and returns the data saved in the database.
     * @param {TopDestinationCreateManyAndReturnArgs} args - Arguments to create many TopDestinations.
     * @example
     * // Create many TopDestinations
     * const topDestination = await prisma.topDestination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TopDestinations and only return the `id`
     * const topDestinationWithIdOnly = await prisma.topDestination.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopDestinationCreateManyAndReturnArgs>(args?: SelectSubset<T, TopDestinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TopDestination.
     * @param {TopDestinationDeleteArgs} args - Arguments to delete one TopDestination.
     * @example
     * // Delete one TopDestination
     * const TopDestination = await prisma.topDestination.delete({
     *   where: {
     *     // ... filter to delete one TopDestination
     *   }
     * })
     * 
     */
    delete<T extends TopDestinationDeleteArgs>(args: SelectSubset<T, TopDestinationDeleteArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TopDestination.
     * @param {TopDestinationUpdateArgs} args - Arguments to update one TopDestination.
     * @example
     * // Update one TopDestination
     * const topDestination = await prisma.topDestination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopDestinationUpdateArgs>(args: SelectSubset<T, TopDestinationUpdateArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TopDestinations.
     * @param {TopDestinationDeleteManyArgs} args - Arguments to filter TopDestinations to delete.
     * @example
     * // Delete a few TopDestinations
     * const { count } = await prisma.topDestination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopDestinationDeleteManyArgs>(args?: SelectSubset<T, TopDestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopDestinations
     * const topDestination = await prisma.topDestination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopDestinationUpdateManyArgs>(args: SelectSubset<T, TopDestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TopDestination.
     * @param {TopDestinationUpsertArgs} args - Arguments to update or create a TopDestination.
     * @example
     * // Update or create a TopDestination
     * const topDestination = await prisma.topDestination.upsert({
     *   create: {
     *     // ... data to create a TopDestination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopDestination we want to update
     *   }
     * })
     */
    upsert<T extends TopDestinationUpsertArgs>(args: SelectSubset<T, TopDestinationUpsertArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TopDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDestinationCountArgs} args - Arguments to filter TopDestinations to count.
     * @example
     * // Count the number of TopDestinations
     * const count = await prisma.topDestination.count({
     *   where: {
     *     // ... the filter for the TopDestinations we want to count
     *   }
     * })
    **/
    count<T extends TopDestinationCountArgs>(
      args?: Subset<T, TopDestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopDestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopDestinationAggregateArgs>(args: Subset<T, TopDestinationAggregateArgs>): Prisma.PrismaPromise<GetTopDestinationAggregateType<T>>

    /**
     * Group by TopDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopDestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopDestinationGroupByArgs['orderBy'] }
        : { orderBy?: TopDestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopDestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TopDestination model
   */
  readonly fields: TopDestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopDestination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopDestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TopDestination model
   */ 
  interface TopDestinationFieldRefs {
    readonly id: FieldRef<"TopDestination", 'String'>
    readonly cityId: FieldRef<"TopDestination", 'String'>
    readonly order: FieldRef<"TopDestination", 'Int'>
    readonly imageUrl: FieldRef<"TopDestination", 'String'>
    readonly createdAt: FieldRef<"TopDestination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TopDestination findUnique
   */
  export type TopDestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * Filter, which TopDestination to fetch.
     */
    where: TopDestinationWhereUniqueInput
  }

  /**
   * TopDestination findUniqueOrThrow
   */
  export type TopDestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * Filter, which TopDestination to fetch.
     */
    where: TopDestinationWhereUniqueInput
  }

  /**
   * TopDestination findFirst
   */
  export type TopDestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * Filter, which TopDestination to fetch.
     */
    where?: TopDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDestinations to fetch.
     */
    orderBy?: TopDestinationOrderByWithRelationInput | TopDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopDestinations.
     */
    cursor?: TopDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopDestinations.
     */
    distinct?: TopDestinationScalarFieldEnum | TopDestinationScalarFieldEnum[]
  }

  /**
   * TopDestination findFirstOrThrow
   */
  export type TopDestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * Filter, which TopDestination to fetch.
     */
    where?: TopDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDestinations to fetch.
     */
    orderBy?: TopDestinationOrderByWithRelationInput | TopDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopDestinations.
     */
    cursor?: TopDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopDestinations.
     */
    distinct?: TopDestinationScalarFieldEnum | TopDestinationScalarFieldEnum[]
  }

  /**
   * TopDestination findMany
   */
  export type TopDestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * Filter, which TopDestinations to fetch.
     */
    where?: TopDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDestinations to fetch.
     */
    orderBy?: TopDestinationOrderByWithRelationInput | TopDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopDestinations.
     */
    cursor?: TopDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDestinations.
     */
    skip?: number
    distinct?: TopDestinationScalarFieldEnum | TopDestinationScalarFieldEnum[]
  }

  /**
   * TopDestination create
   */
  export type TopDestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * The data needed to create a TopDestination.
     */
    data: XOR<TopDestinationCreateInput, TopDestinationUncheckedCreateInput>
  }

  /**
   * TopDestination createMany
   */
  export type TopDestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopDestinations.
     */
    data: TopDestinationCreateManyInput | TopDestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopDestination createManyAndReturn
   */
  export type TopDestinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TopDestinations.
     */
    data: TopDestinationCreateManyInput | TopDestinationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopDestination update
   */
  export type TopDestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * The data needed to update a TopDestination.
     */
    data: XOR<TopDestinationUpdateInput, TopDestinationUncheckedUpdateInput>
    /**
     * Choose, which TopDestination to update.
     */
    where: TopDestinationWhereUniqueInput
  }

  /**
   * TopDestination updateMany
   */
  export type TopDestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopDestinations.
     */
    data: XOR<TopDestinationUpdateManyMutationInput, TopDestinationUncheckedUpdateManyInput>
    /**
     * Filter which TopDestinations to update
     */
    where?: TopDestinationWhereInput
  }

  /**
   * TopDestination upsert
   */
  export type TopDestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * The filter to search for the TopDestination to update in case it exists.
     */
    where: TopDestinationWhereUniqueInput
    /**
     * In case the TopDestination found by the `where` argument doesn't exist, create a new TopDestination with this data.
     */
    create: XOR<TopDestinationCreateInput, TopDestinationUncheckedCreateInput>
    /**
     * In case the TopDestination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopDestinationUpdateInput, TopDestinationUncheckedUpdateInput>
  }

  /**
   * TopDestination delete
   */
  export type TopDestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    /**
     * Filter which TopDestination to delete.
     */
    where: TopDestinationWhereUniqueInput
  }

  /**
   * TopDestination deleteMany
   */
  export type TopDestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopDestinations to delete
     */
    where?: TopDestinationWhereInput
  }

  /**
   * TopDestination without action
   */
  export type TopDestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    code: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    name: string
    code: string
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    cities?: boolean | Country$citiesArgs<ExtArgs>
    users?: boolean | Country$usersArgs<ExtArgs>
    hosts?: boolean | Country$hostsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
  }

  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Country$citiesArgs<ExtArgs>
    users?: boolean | Country$usersArgs<ExtArgs>
    hosts?: boolean | Country$hostsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      hosts: Prisma.$HostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Country$usersArgs<ExtArgs> = {}>(args?: Subset<T, Country$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    hosts<T extends Country$hostsArgs<ExtArgs> = {}>(args?: Subset<T, Country$hostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly code: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country.users
   */
  export type Country$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Country.hosts
   */
  export type Country$hostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    where?: HostWhereInput
    orderBy?: HostOrderByWithRelationInput | HostOrderByWithRelationInput[]
    cursor?: HostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HostScalarFieldEnum | HostScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type CitySumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    countryId: string | null
    lat: number | null
    lng: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    countryId: string | null
    lat: number | null
    lng: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    countryId: number
    lat: number
    lng: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type CitySumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    lat?: true
    lng?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    lat?: true
    lng?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    lat?: true
    lng?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    countryId: string
    lat: number
    lng: number
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    lat?: boolean
    lng?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    hosts?: boolean | City$hostsArgs<ExtArgs>
    topDestination?: boolean | City$topDestinationArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    lat?: boolean
    lng?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    countryId?: boolean
    lat?: boolean
    lng?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    hosts?: boolean | City$hostsArgs<ExtArgs>
    topDestination?: boolean | City$topDestinationArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
      hosts: Prisma.$HostPayload<ExtArgs>[]
      topDestination: Prisma.$TopDestinationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      countryId: string
      lat: number
      lng: number
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends City$usersArgs<ExtArgs> = {}>(args?: Subset<T, City$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    hosts<T extends City$hostsArgs<ExtArgs> = {}>(args?: Subset<T, City$hostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findMany"> | Null>
    topDestination<T extends City$topDestinationArgs<ExtArgs> = {}>(args?: Subset<T, City$topDestinationArgs<ExtArgs>>): Prisma__TopDestinationClient<$Result.GetResult<Prisma.$TopDestinationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly countryId: FieldRef<"City", 'String'>
    readonly lat: FieldRef<"City", 'Float'>
    readonly lng: FieldRef<"City", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City.users
   */
  export type City$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * City.hosts
   */
  export type City$hostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    where?: HostWhereInput
    orderBy?: HostOrderByWithRelationInput | HostOrderByWithRelationInput[]
    cursor?: HostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HostScalarFieldEnum | HostScalarFieldEnum[]
  }

  /**
   * City.topDestination
   */
  export type City$topDestinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDestination
     */
    select?: TopDestinationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopDestinationInclude<ExtArgs> | null
    where?: TopDestinationWhereInput
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    name: string
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hosts?: boolean | Language$hostsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hosts?: boolean | Language$hostsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      hosts: Prisma.$HostLanguagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hosts<T extends Language$hostsArgs<ExtArgs> = {}>(args?: Subset<T, Language$hostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }

  /**
   * Language.hosts
   */
  export type Language$hostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    where?: HostLanguageWhereInput
    orderBy?: HostLanguageOrderByWithRelationInput | HostLanguageOrderByWithRelationInput[]
    cursor?: HostLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HostLanguageScalarFieldEnum | HostLanguageScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatarUrl: string | null
    phone: string | null
    bio: string | null
    role: $Enums.Role | null
    countryId: string | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referredById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatarUrl: string | null
    phone: string | null
    bio: string | null
    role: $Enums.Role | null
    countryId: string | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referredById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    avatarUrl: number
    phone: number
    bio: number
    role: number
    countryId: number
    cityId: number
    createdAt: number
    updatedAt: number
    referredById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatarUrl?: true
    phone?: true
    bio?: true
    role?: true
    countryId?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    referredById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatarUrl?: true
    phone?: true
    bio?: true
    role?: true
    countryId?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    referredById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatarUrl?: true
    phone?: true
    bio?: true
    role?: true
    countryId?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    referredById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    avatarUrl: string | null
    phone: string | null
    bio: string | null
    role: $Enums.Role
    countryId: string | null
    cityId: string | null
    createdAt: Date
    updatedAt: Date
    referredById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatarUrl?: boolean
    phone?: boolean
    bio?: boolean
    role?: boolean
    countryId?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referredById?: boolean
    country?: boolean | User$countryArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    host?: boolean | User$hostArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    wishlist?: boolean | User$wishlistArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    storyLikes?: boolean | User$storyLikesArgs<ExtArgs>
    storyComments?: boolean | User$storyCommentsArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatarUrl?: boolean
    phone?: boolean
    bio?: boolean
    role?: boolean
    countryId?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referredById?: boolean
    country?: boolean | User$countryArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatarUrl?: boolean
    phone?: boolean
    bio?: boolean
    role?: boolean
    countryId?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referredById?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | User$countryArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    host?: boolean | User$hostArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    wishlist?: boolean | User$wishlistArgs<ExtArgs>
    stories?: boolean | User$storiesArgs<ExtArgs>
    storyLikes?: boolean | User$storyLikesArgs<ExtArgs>
    storyComments?: boolean | User$storyCommentsArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | User$countryArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs> | null
      city: Prisma.$CityPayload<ExtArgs> | null
      host: Prisma.$HostPayload<ExtArgs> | null
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      wishlist: Prisma.$WishlistPayload<ExtArgs>[]
      stories: Prisma.$StoryPayload<ExtArgs>[]
      storyLikes: Prisma.$StoryLikePayload<ExtArgs>[]
      storyComments: Prisma.$StoryCommentPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      referredBy: Prisma.$ReferralPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      avatarUrl: string | null
      phone: string | null
      bio: string | null
      role: $Enums.Role
      countryId: string | null
      cityId: string | null
      createdAt: Date
      updatedAt: Date
      referredById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends User$countryArgs<ExtArgs> = {}>(args?: Subset<T, User$countryArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    city<T extends User$cityArgs<ExtArgs> = {}>(args?: Subset<T, User$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    host<T extends User$hostArgs<ExtArgs> = {}>(args?: Subset<T, User$hostArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    wishlist<T extends User$wishlistArgs<ExtArgs> = {}>(args?: Subset<T, User$wishlistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany"> | Null>
    stories<T extends User$storiesArgs<ExtArgs> = {}>(args?: Subset<T, User$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany"> | Null>
    storyLikes<T extends User$storyLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$storyLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "findMany"> | Null>
    storyComments<T extends User$storyCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$storyCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "findMany"> | Null>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    referredBy<T extends User$referredByArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly countryId: FieldRef<"User", 'String'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly referredById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.country
   */
  export type User$countryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    where?: CountryWhereInput
  }

  /**
   * User.city
   */
  export type User$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * User.host
   */
  export type User$hostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    where?: HostWhereInput
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.wishlist
   */
  export type User$wishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    cursor?: WishlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * User.stories
   */
  export type User$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * User.storyLikes
   */
  export type User$storyLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    where?: StoryLikeWhereInput
    orderBy?: StoryLikeOrderByWithRelationInput | StoryLikeOrderByWithRelationInput[]
    cursor?: StoryLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryLikeScalarFieldEnum | StoryLikeScalarFieldEnum[]
  }

  /**
   * User.storyComments
   */
  export type User$storyCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    where?: StoryCommentWhereInput
    orderBy?: StoryCommentOrderByWithRelationInput | StoryCommentOrderByWithRelationInput[]
    cursor?: StoryCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryCommentScalarFieldEnum | StoryCommentScalarFieldEnum[]
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referredBy
   */
  export type User$referredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Host
   */

  export type AggregateHost = {
    _count: HostCountAggregateOutputType | null
    _avg: HostAvgAggregateOutputType | null
    _sum: HostSumAggregateOutputType | null
    _min: HostMinAggregateOutputType | null
    _max: HostMaxAggregateOutputType | null
  }

  export type HostAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type HostSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type HostMinAggregateOutputType = {
    id: string | null
    userId: string | null
    countryId: string | null
    cityId: string | null
    lat: number | null
    lng: number | null
    isGuide: boolean | null
    isPhotographer: boolean | null
    profileVideo: string | null
    isVerified: boolean | null
    createdAt: Date | null
  }

  export type HostMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    countryId: string | null
    cityId: string | null
    lat: number | null
    lng: number | null
    isGuide: boolean | null
    isPhotographer: boolean | null
    profileVideo: string | null
    isVerified: boolean | null
    createdAt: Date | null
  }

  export type HostCountAggregateOutputType = {
    id: number
    userId: number
    countryId: number
    cityId: number
    lat: number
    lng: number
    isGuide: number
    isPhotographer: number
    profileVideo: number
    isVerified: number
    createdAt: number
    _all: number
  }


  export type HostAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type HostSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type HostMinAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    lat?: true
    lng?: true
    isGuide?: true
    isPhotographer?: true
    profileVideo?: true
    isVerified?: true
    createdAt?: true
  }

  export type HostMaxAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    lat?: true
    lng?: true
    isGuide?: true
    isPhotographer?: true
    profileVideo?: true
    isVerified?: true
    createdAt?: true
  }

  export type HostCountAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    lat?: true
    lng?: true
    isGuide?: true
    isPhotographer?: true
    profileVideo?: true
    isVerified?: true
    createdAt?: true
    _all?: true
  }

  export type HostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Host to aggregate.
     */
    where?: HostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hosts to fetch.
     */
    orderBy?: HostOrderByWithRelationInput | HostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hosts
    **/
    _count?: true | HostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HostMaxAggregateInputType
  }

  export type GetHostAggregateType<T extends HostAggregateArgs> = {
        [P in keyof T & keyof AggregateHost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHost[P]>
      : GetScalarType<T[P], AggregateHost[P]>
  }




  export type HostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostWhereInput
    orderBy?: HostOrderByWithAggregationInput | HostOrderByWithAggregationInput[]
    by: HostScalarFieldEnum[] | HostScalarFieldEnum
    having?: HostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HostCountAggregateInputType | true
    _avg?: HostAvgAggregateInputType
    _sum?: HostSumAggregateInputType
    _min?: HostMinAggregateInputType
    _max?: HostMaxAggregateInputType
  }

  export type HostGroupByOutputType = {
    id: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide: boolean
    isPhotographer: boolean
    profileVideo: string | null
    isVerified: boolean
    createdAt: Date
    _count: HostCountAggregateOutputType | null
    _avg: HostAvgAggregateOutputType | null
    _sum: HostSumAggregateOutputType | null
    _min: HostMinAggregateOutputType | null
    _max: HostMaxAggregateOutputType | null
  }

  type GetHostGroupByPayload<T extends HostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HostGroupByOutputType[P]>
            : GetScalarType<T[P], HostGroupByOutputType[P]>
        }
      >
    >


  export type HostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    countryId?: boolean
    cityId?: boolean
    lat?: boolean
    lng?: boolean
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: boolean
    isVerified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    languages?: boolean | Host$languagesArgs<ExtArgs>
    services?: boolean | Host$servicesArgs<ExtArgs>
    blockedDates?: boolean | Host$blockedDatesArgs<ExtArgs>
    badges?: boolean | Host$badgesArgs<ExtArgs>
    reviews?: boolean | Host$reviewsArgs<ExtArgs>
    photographerSkills?: boolean | Host$photographerSkillsArgs<ExtArgs>
    photographerGears?: boolean | Host$photographerGearsArgs<ExtArgs>
    _count?: boolean | HostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["host"]>

  export type HostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    countryId?: boolean
    cityId?: boolean
    lat?: boolean
    lng?: boolean
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: boolean
    isVerified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["host"]>

  export type HostSelectScalar = {
    id?: boolean
    userId?: boolean
    countryId?: boolean
    cityId?: boolean
    lat?: boolean
    lng?: boolean
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: boolean
    isVerified?: boolean
    createdAt?: boolean
  }

  export type HostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    languages?: boolean | Host$languagesArgs<ExtArgs>
    services?: boolean | Host$servicesArgs<ExtArgs>
    blockedDates?: boolean | Host$blockedDatesArgs<ExtArgs>
    badges?: boolean | Host$badgesArgs<ExtArgs>
    reviews?: boolean | Host$reviewsArgs<ExtArgs>
    photographerSkills?: boolean | Host$photographerSkillsArgs<ExtArgs>
    photographerGears?: boolean | Host$photographerGearsArgs<ExtArgs>
    _count?: boolean | HostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $HostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Host"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      languages: Prisma.$HostLanguagePayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      blockedDates: Prisma.$BlockedDatePayload<ExtArgs>[]
      badges: Prisma.$HostBadgePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      photographerSkills: Prisma.$PhotographerSkillPayload<ExtArgs>[]
      photographerGears: Prisma.$PhotographerGearPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      countryId: string
      cityId: string
      lat: number
      lng: number
      isGuide: boolean
      isPhotographer: boolean
      profileVideo: string | null
      isVerified: boolean
      createdAt: Date
    }, ExtArgs["result"]["host"]>
    composites: {}
  }

  type HostGetPayload<S extends boolean | null | undefined | HostDefaultArgs> = $Result.GetResult<Prisma.$HostPayload, S>

  type HostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HostCountAggregateInputType | true
    }

  export interface HostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Host'], meta: { name: 'Host' } }
    /**
     * Find zero or one Host that matches the filter.
     * @param {HostFindUniqueArgs} args - Arguments to find a Host
     * @example
     * // Get one Host
     * const host = await prisma.host.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HostFindUniqueArgs>(args: SelectSubset<T, HostFindUniqueArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Host that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HostFindUniqueOrThrowArgs} args - Arguments to find a Host
     * @example
     * // Get one Host
     * const host = await prisma.host.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HostFindUniqueOrThrowArgs>(args: SelectSubset<T, HostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Host that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostFindFirstArgs} args - Arguments to find a Host
     * @example
     * // Get one Host
     * const host = await prisma.host.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HostFindFirstArgs>(args?: SelectSubset<T, HostFindFirstArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Host that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostFindFirstOrThrowArgs} args - Arguments to find a Host
     * @example
     * // Get one Host
     * const host = await prisma.host.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HostFindFirstOrThrowArgs>(args?: SelectSubset<T, HostFindFirstOrThrowArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hosts
     * const hosts = await prisma.host.findMany()
     * 
     * // Get first 10 Hosts
     * const hosts = await prisma.host.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hostWithIdOnly = await prisma.host.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HostFindManyArgs>(args?: SelectSubset<T, HostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Host.
     * @param {HostCreateArgs} args - Arguments to create a Host.
     * @example
     * // Create one Host
     * const Host = await prisma.host.create({
     *   data: {
     *     // ... data to create a Host
     *   }
     * })
     * 
     */
    create<T extends HostCreateArgs>(args: SelectSubset<T, HostCreateArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hosts.
     * @param {HostCreateManyArgs} args - Arguments to create many Hosts.
     * @example
     * // Create many Hosts
     * const host = await prisma.host.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HostCreateManyArgs>(args?: SelectSubset<T, HostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hosts and returns the data saved in the database.
     * @param {HostCreateManyAndReturnArgs} args - Arguments to create many Hosts.
     * @example
     * // Create many Hosts
     * const host = await prisma.host.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hosts and only return the `id`
     * const hostWithIdOnly = await prisma.host.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HostCreateManyAndReturnArgs>(args?: SelectSubset<T, HostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Host.
     * @param {HostDeleteArgs} args - Arguments to delete one Host.
     * @example
     * // Delete one Host
     * const Host = await prisma.host.delete({
     *   where: {
     *     // ... filter to delete one Host
     *   }
     * })
     * 
     */
    delete<T extends HostDeleteArgs>(args: SelectSubset<T, HostDeleteArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Host.
     * @param {HostUpdateArgs} args - Arguments to update one Host.
     * @example
     * // Update one Host
     * const host = await prisma.host.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HostUpdateArgs>(args: SelectSubset<T, HostUpdateArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hosts.
     * @param {HostDeleteManyArgs} args - Arguments to filter Hosts to delete.
     * @example
     * // Delete a few Hosts
     * const { count } = await prisma.host.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HostDeleteManyArgs>(args?: SelectSubset<T, HostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hosts
     * const host = await prisma.host.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HostUpdateManyArgs>(args: SelectSubset<T, HostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Host.
     * @param {HostUpsertArgs} args - Arguments to update or create a Host.
     * @example
     * // Update or create a Host
     * const host = await prisma.host.upsert({
     *   create: {
     *     // ... data to create a Host
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Host we want to update
     *   }
     * })
     */
    upsert<T extends HostUpsertArgs>(args: SelectSubset<T, HostUpsertArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostCountArgs} args - Arguments to filter Hosts to count.
     * @example
     * // Count the number of Hosts
     * const count = await prisma.host.count({
     *   where: {
     *     // ... the filter for the Hosts we want to count
     *   }
     * })
    **/
    count<T extends HostCountArgs>(
      args?: Subset<T, HostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Host.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HostAggregateArgs>(args: Subset<T, HostAggregateArgs>): Prisma.PrismaPromise<GetHostAggregateType<T>>

    /**
     * Group by Host.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HostGroupByArgs['orderBy'] }
        : { orderBy?: HostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Host model
   */
  readonly fields: HostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Host.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    languages<T extends Host$languagesArgs<ExtArgs> = {}>(args?: Subset<T, Host$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends Host$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Host$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    blockedDates<T extends Host$blockedDatesArgs<ExtArgs> = {}>(args?: Subset<T, Host$blockedDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends Host$badgesArgs<ExtArgs> = {}>(args?: Subset<T, Host$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Host$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Host$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    photographerSkills<T extends Host$photographerSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Host$photographerSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "findMany"> | Null>
    photographerGears<T extends Host$photographerGearsArgs<ExtArgs> = {}>(args?: Subset<T, Host$photographerGearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Host model
   */ 
  interface HostFieldRefs {
    readonly id: FieldRef<"Host", 'String'>
    readonly userId: FieldRef<"Host", 'String'>
    readonly countryId: FieldRef<"Host", 'String'>
    readonly cityId: FieldRef<"Host", 'String'>
    readonly lat: FieldRef<"Host", 'Float'>
    readonly lng: FieldRef<"Host", 'Float'>
    readonly isGuide: FieldRef<"Host", 'Boolean'>
    readonly isPhotographer: FieldRef<"Host", 'Boolean'>
    readonly profileVideo: FieldRef<"Host", 'String'>
    readonly isVerified: FieldRef<"Host", 'Boolean'>
    readonly createdAt: FieldRef<"Host", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Host findUnique
   */
  export type HostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * Filter, which Host to fetch.
     */
    where: HostWhereUniqueInput
  }

  /**
   * Host findUniqueOrThrow
   */
  export type HostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * Filter, which Host to fetch.
     */
    where: HostWhereUniqueInput
  }

  /**
   * Host findFirst
   */
  export type HostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * Filter, which Host to fetch.
     */
    where?: HostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hosts to fetch.
     */
    orderBy?: HostOrderByWithRelationInput | HostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hosts.
     */
    cursor?: HostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hosts.
     */
    distinct?: HostScalarFieldEnum | HostScalarFieldEnum[]
  }

  /**
   * Host findFirstOrThrow
   */
  export type HostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * Filter, which Host to fetch.
     */
    where?: HostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hosts to fetch.
     */
    orderBy?: HostOrderByWithRelationInput | HostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hosts.
     */
    cursor?: HostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hosts.
     */
    distinct?: HostScalarFieldEnum | HostScalarFieldEnum[]
  }

  /**
   * Host findMany
   */
  export type HostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * Filter, which Hosts to fetch.
     */
    where?: HostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hosts to fetch.
     */
    orderBy?: HostOrderByWithRelationInput | HostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hosts.
     */
    cursor?: HostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hosts.
     */
    skip?: number
    distinct?: HostScalarFieldEnum | HostScalarFieldEnum[]
  }

  /**
   * Host create
   */
  export type HostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * The data needed to create a Host.
     */
    data: XOR<HostCreateInput, HostUncheckedCreateInput>
  }

  /**
   * Host createMany
   */
  export type HostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hosts.
     */
    data: HostCreateManyInput | HostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Host createManyAndReturn
   */
  export type HostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hosts.
     */
    data: HostCreateManyInput | HostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Host update
   */
  export type HostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * The data needed to update a Host.
     */
    data: XOR<HostUpdateInput, HostUncheckedUpdateInput>
    /**
     * Choose, which Host to update.
     */
    where: HostWhereUniqueInput
  }

  /**
   * Host updateMany
   */
  export type HostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hosts.
     */
    data: XOR<HostUpdateManyMutationInput, HostUncheckedUpdateManyInput>
    /**
     * Filter which Hosts to update
     */
    where?: HostWhereInput
  }

  /**
   * Host upsert
   */
  export type HostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * The filter to search for the Host to update in case it exists.
     */
    where: HostWhereUniqueInput
    /**
     * In case the Host found by the `where` argument doesn't exist, create a new Host with this data.
     */
    create: XOR<HostCreateInput, HostUncheckedCreateInput>
    /**
     * In case the Host was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HostUpdateInput, HostUncheckedUpdateInput>
  }

  /**
   * Host delete
   */
  export type HostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
    /**
     * Filter which Host to delete.
     */
    where: HostWhereUniqueInput
  }

  /**
   * Host deleteMany
   */
  export type HostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hosts to delete
     */
    where?: HostWhereInput
  }

  /**
   * Host.languages
   */
  export type Host$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    where?: HostLanguageWhereInput
    orderBy?: HostLanguageOrderByWithRelationInput | HostLanguageOrderByWithRelationInput[]
    cursor?: HostLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HostLanguageScalarFieldEnum | HostLanguageScalarFieldEnum[]
  }

  /**
   * Host.services
   */
  export type Host$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Host.blockedDates
   */
  export type Host$blockedDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    where?: BlockedDateWhereInput
    orderBy?: BlockedDateOrderByWithRelationInput | BlockedDateOrderByWithRelationInput[]
    cursor?: BlockedDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedDateScalarFieldEnum | BlockedDateScalarFieldEnum[]
  }

  /**
   * Host.badges
   */
  export type Host$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    where?: HostBadgeWhereInput
    orderBy?: HostBadgeOrderByWithRelationInput | HostBadgeOrderByWithRelationInput[]
    cursor?: HostBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HostBadgeScalarFieldEnum | HostBadgeScalarFieldEnum[]
  }

  /**
   * Host.reviews
   */
  export type Host$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Host.photographerSkills
   */
  export type Host$photographerSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    where?: PhotographerSkillWhereInput
    orderBy?: PhotographerSkillOrderByWithRelationInput | PhotographerSkillOrderByWithRelationInput[]
    cursor?: PhotographerSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotographerSkillScalarFieldEnum | PhotographerSkillScalarFieldEnum[]
  }

  /**
   * Host.photographerGears
   */
  export type Host$photographerGearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    where?: PhotographerGearWhereInput
    orderBy?: PhotographerGearOrderByWithRelationInput | PhotographerGearOrderByWithRelationInput[]
    cursor?: PhotographerGearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotographerGearScalarFieldEnum | PhotographerGearScalarFieldEnum[]
  }

  /**
   * Host without action
   */
  export type HostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Host
     */
    select?: HostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostInclude<ExtArgs> | null
  }


  /**
   * Model HostLanguage
   */

  export type AggregateHostLanguage = {
    _count: HostLanguageCountAggregateOutputType | null
    _min: HostLanguageMinAggregateOutputType | null
    _max: HostLanguageMaxAggregateOutputType | null
  }

  export type HostLanguageMinAggregateOutputType = {
    id: string | null
    hostId: string | null
    languageId: string | null
  }

  export type HostLanguageMaxAggregateOutputType = {
    id: string | null
    hostId: string | null
    languageId: string | null
  }

  export type HostLanguageCountAggregateOutputType = {
    id: number
    hostId: number
    languageId: number
    _all: number
  }


  export type HostLanguageMinAggregateInputType = {
    id?: true
    hostId?: true
    languageId?: true
  }

  export type HostLanguageMaxAggregateInputType = {
    id?: true
    hostId?: true
    languageId?: true
  }

  export type HostLanguageCountAggregateInputType = {
    id?: true
    hostId?: true
    languageId?: true
    _all?: true
  }

  export type HostLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HostLanguage to aggregate.
     */
    where?: HostLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostLanguages to fetch.
     */
    orderBy?: HostLanguageOrderByWithRelationInput | HostLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HostLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HostLanguages
    **/
    _count?: true | HostLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HostLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HostLanguageMaxAggregateInputType
  }

  export type GetHostLanguageAggregateType<T extends HostLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateHostLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHostLanguage[P]>
      : GetScalarType<T[P], AggregateHostLanguage[P]>
  }




  export type HostLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostLanguageWhereInput
    orderBy?: HostLanguageOrderByWithAggregationInput | HostLanguageOrderByWithAggregationInput[]
    by: HostLanguageScalarFieldEnum[] | HostLanguageScalarFieldEnum
    having?: HostLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HostLanguageCountAggregateInputType | true
    _min?: HostLanguageMinAggregateInputType
    _max?: HostLanguageMaxAggregateInputType
  }

  export type HostLanguageGroupByOutputType = {
    id: string
    hostId: string
    languageId: string
    _count: HostLanguageCountAggregateOutputType | null
    _min: HostLanguageMinAggregateOutputType | null
    _max: HostLanguageMaxAggregateOutputType | null
  }

  type GetHostLanguageGroupByPayload<T extends HostLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HostLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HostLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HostLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], HostLanguageGroupByOutputType[P]>
        }
      >
    >


  export type HostLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    languageId?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hostLanguage"]>

  export type HostLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    languageId?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hostLanguage"]>

  export type HostLanguageSelectScalar = {
    id?: boolean
    hostId?: boolean
    languageId?: boolean
  }

  export type HostLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type HostLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $HostLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HostLanguage"
    objects: {
      host: Prisma.$HostPayload<ExtArgs>
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hostId: string
      languageId: string
    }, ExtArgs["result"]["hostLanguage"]>
    composites: {}
  }

  type HostLanguageGetPayload<S extends boolean | null | undefined | HostLanguageDefaultArgs> = $Result.GetResult<Prisma.$HostLanguagePayload, S>

  type HostLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HostLanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HostLanguageCountAggregateInputType | true
    }

  export interface HostLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HostLanguage'], meta: { name: 'HostLanguage' } }
    /**
     * Find zero or one HostLanguage that matches the filter.
     * @param {HostLanguageFindUniqueArgs} args - Arguments to find a HostLanguage
     * @example
     * // Get one HostLanguage
     * const hostLanguage = await prisma.hostLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HostLanguageFindUniqueArgs>(args: SelectSubset<T, HostLanguageFindUniqueArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HostLanguage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HostLanguageFindUniqueOrThrowArgs} args - Arguments to find a HostLanguage
     * @example
     * // Get one HostLanguage
     * const hostLanguage = await prisma.hostLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HostLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, HostLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HostLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostLanguageFindFirstArgs} args - Arguments to find a HostLanguage
     * @example
     * // Get one HostLanguage
     * const hostLanguage = await prisma.hostLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HostLanguageFindFirstArgs>(args?: SelectSubset<T, HostLanguageFindFirstArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HostLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostLanguageFindFirstOrThrowArgs} args - Arguments to find a HostLanguage
     * @example
     * // Get one HostLanguage
     * const hostLanguage = await prisma.hostLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HostLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, HostLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HostLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HostLanguages
     * const hostLanguages = await prisma.hostLanguage.findMany()
     * 
     * // Get first 10 HostLanguages
     * const hostLanguages = await prisma.hostLanguage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hostLanguageWithIdOnly = await prisma.hostLanguage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HostLanguageFindManyArgs>(args?: SelectSubset<T, HostLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HostLanguage.
     * @param {HostLanguageCreateArgs} args - Arguments to create a HostLanguage.
     * @example
     * // Create one HostLanguage
     * const HostLanguage = await prisma.hostLanguage.create({
     *   data: {
     *     // ... data to create a HostLanguage
     *   }
     * })
     * 
     */
    create<T extends HostLanguageCreateArgs>(args: SelectSubset<T, HostLanguageCreateArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HostLanguages.
     * @param {HostLanguageCreateManyArgs} args - Arguments to create many HostLanguages.
     * @example
     * // Create many HostLanguages
     * const hostLanguage = await prisma.hostLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HostLanguageCreateManyArgs>(args?: SelectSubset<T, HostLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HostLanguages and returns the data saved in the database.
     * @param {HostLanguageCreateManyAndReturnArgs} args - Arguments to create many HostLanguages.
     * @example
     * // Create many HostLanguages
     * const hostLanguage = await prisma.hostLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HostLanguages and only return the `id`
     * const hostLanguageWithIdOnly = await prisma.hostLanguage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HostLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, HostLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HostLanguage.
     * @param {HostLanguageDeleteArgs} args - Arguments to delete one HostLanguage.
     * @example
     * // Delete one HostLanguage
     * const HostLanguage = await prisma.hostLanguage.delete({
     *   where: {
     *     // ... filter to delete one HostLanguage
     *   }
     * })
     * 
     */
    delete<T extends HostLanguageDeleteArgs>(args: SelectSubset<T, HostLanguageDeleteArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HostLanguage.
     * @param {HostLanguageUpdateArgs} args - Arguments to update one HostLanguage.
     * @example
     * // Update one HostLanguage
     * const hostLanguage = await prisma.hostLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HostLanguageUpdateArgs>(args: SelectSubset<T, HostLanguageUpdateArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HostLanguages.
     * @param {HostLanguageDeleteManyArgs} args - Arguments to filter HostLanguages to delete.
     * @example
     * // Delete a few HostLanguages
     * const { count } = await prisma.hostLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HostLanguageDeleteManyArgs>(args?: SelectSubset<T, HostLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HostLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HostLanguages
     * const hostLanguage = await prisma.hostLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HostLanguageUpdateManyArgs>(args: SelectSubset<T, HostLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HostLanguage.
     * @param {HostLanguageUpsertArgs} args - Arguments to update or create a HostLanguage.
     * @example
     * // Update or create a HostLanguage
     * const hostLanguage = await prisma.hostLanguage.upsert({
     *   create: {
     *     // ... data to create a HostLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HostLanguage we want to update
     *   }
     * })
     */
    upsert<T extends HostLanguageUpsertArgs>(args: SelectSubset<T, HostLanguageUpsertArgs<ExtArgs>>): Prisma__HostLanguageClient<$Result.GetResult<Prisma.$HostLanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HostLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostLanguageCountArgs} args - Arguments to filter HostLanguages to count.
     * @example
     * // Count the number of HostLanguages
     * const count = await prisma.hostLanguage.count({
     *   where: {
     *     // ... the filter for the HostLanguages we want to count
     *   }
     * })
    **/
    count<T extends HostLanguageCountArgs>(
      args?: Subset<T, HostLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HostLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HostLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HostLanguageAggregateArgs>(args: Subset<T, HostLanguageAggregateArgs>): Prisma.PrismaPromise<GetHostLanguageAggregateType<T>>

    /**
     * Group by HostLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HostLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HostLanguageGroupByArgs['orderBy'] }
        : { orderBy?: HostLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HostLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHostLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HostLanguage model
   */
  readonly fields: HostLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HostLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HostLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends HostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HostDefaultArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HostLanguage model
   */ 
  interface HostLanguageFieldRefs {
    readonly id: FieldRef<"HostLanguage", 'String'>
    readonly hostId: FieldRef<"HostLanguage", 'String'>
    readonly languageId: FieldRef<"HostLanguage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HostLanguage findUnique
   */
  export type HostLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * Filter, which HostLanguage to fetch.
     */
    where: HostLanguageWhereUniqueInput
  }

  /**
   * HostLanguage findUniqueOrThrow
   */
  export type HostLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * Filter, which HostLanguage to fetch.
     */
    where: HostLanguageWhereUniqueInput
  }

  /**
   * HostLanguage findFirst
   */
  export type HostLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * Filter, which HostLanguage to fetch.
     */
    where?: HostLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostLanguages to fetch.
     */
    orderBy?: HostLanguageOrderByWithRelationInput | HostLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HostLanguages.
     */
    cursor?: HostLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HostLanguages.
     */
    distinct?: HostLanguageScalarFieldEnum | HostLanguageScalarFieldEnum[]
  }

  /**
   * HostLanguage findFirstOrThrow
   */
  export type HostLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * Filter, which HostLanguage to fetch.
     */
    where?: HostLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostLanguages to fetch.
     */
    orderBy?: HostLanguageOrderByWithRelationInput | HostLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HostLanguages.
     */
    cursor?: HostLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HostLanguages.
     */
    distinct?: HostLanguageScalarFieldEnum | HostLanguageScalarFieldEnum[]
  }

  /**
   * HostLanguage findMany
   */
  export type HostLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * Filter, which HostLanguages to fetch.
     */
    where?: HostLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostLanguages to fetch.
     */
    orderBy?: HostLanguageOrderByWithRelationInput | HostLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HostLanguages.
     */
    cursor?: HostLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostLanguages.
     */
    skip?: number
    distinct?: HostLanguageScalarFieldEnum | HostLanguageScalarFieldEnum[]
  }

  /**
   * HostLanguage create
   */
  export type HostLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a HostLanguage.
     */
    data: XOR<HostLanguageCreateInput, HostLanguageUncheckedCreateInput>
  }

  /**
   * HostLanguage createMany
   */
  export type HostLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HostLanguages.
     */
    data: HostLanguageCreateManyInput | HostLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HostLanguage createManyAndReturn
   */
  export type HostLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HostLanguages.
     */
    data: HostLanguageCreateManyInput | HostLanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HostLanguage update
   */
  export type HostLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a HostLanguage.
     */
    data: XOR<HostLanguageUpdateInput, HostLanguageUncheckedUpdateInput>
    /**
     * Choose, which HostLanguage to update.
     */
    where: HostLanguageWhereUniqueInput
  }

  /**
   * HostLanguage updateMany
   */
  export type HostLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HostLanguages.
     */
    data: XOR<HostLanguageUpdateManyMutationInput, HostLanguageUncheckedUpdateManyInput>
    /**
     * Filter which HostLanguages to update
     */
    where?: HostLanguageWhereInput
  }

  /**
   * HostLanguage upsert
   */
  export type HostLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the HostLanguage to update in case it exists.
     */
    where: HostLanguageWhereUniqueInput
    /**
     * In case the HostLanguage found by the `where` argument doesn't exist, create a new HostLanguage with this data.
     */
    create: XOR<HostLanguageCreateInput, HostLanguageUncheckedCreateInput>
    /**
     * In case the HostLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HostLanguageUpdateInput, HostLanguageUncheckedUpdateInput>
  }

  /**
   * HostLanguage delete
   */
  export type HostLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
    /**
     * Filter which HostLanguage to delete.
     */
    where: HostLanguageWhereUniqueInput
  }

  /**
   * HostLanguage deleteMany
   */
  export type HostLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HostLanguages to delete
     */
    where?: HostLanguageWhereInput
  }

  /**
   * HostLanguage without action
   */
  export type HostLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostLanguage
     */
    select?: HostLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostLanguageInclude<ExtArgs> | null
  }


  /**
   * Model PhotographerSkill
   */

  export type AggregatePhotographerSkill = {
    _count: PhotographerSkillCountAggregateOutputType | null
    _min: PhotographerSkillMinAggregateOutputType | null
    _max: PhotographerSkillMaxAggregateOutputType | null
  }

  export type PhotographerSkillMinAggregateOutputType = {
    id: string | null
    hostId: string | null
    skill: string | null
  }

  export type PhotographerSkillMaxAggregateOutputType = {
    id: string | null
    hostId: string | null
    skill: string | null
  }

  export type PhotographerSkillCountAggregateOutputType = {
    id: number
    hostId: number
    skill: number
    _all: number
  }


  export type PhotographerSkillMinAggregateInputType = {
    id?: true
    hostId?: true
    skill?: true
  }

  export type PhotographerSkillMaxAggregateInputType = {
    id?: true
    hostId?: true
    skill?: true
  }

  export type PhotographerSkillCountAggregateInputType = {
    id?: true
    hostId?: true
    skill?: true
    _all?: true
  }

  export type PhotographerSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotographerSkill to aggregate.
     */
    where?: PhotographerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerSkills to fetch.
     */
    orderBy?: PhotographerSkillOrderByWithRelationInput | PhotographerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotographerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotographerSkills
    **/
    _count?: true | PhotographerSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotographerSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotographerSkillMaxAggregateInputType
  }

  export type GetPhotographerSkillAggregateType<T extends PhotographerSkillAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotographerSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotographerSkill[P]>
      : GetScalarType<T[P], AggregatePhotographerSkill[P]>
  }




  export type PhotographerSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotographerSkillWhereInput
    orderBy?: PhotographerSkillOrderByWithAggregationInput | PhotographerSkillOrderByWithAggregationInput[]
    by: PhotographerSkillScalarFieldEnum[] | PhotographerSkillScalarFieldEnum
    having?: PhotographerSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotographerSkillCountAggregateInputType | true
    _min?: PhotographerSkillMinAggregateInputType
    _max?: PhotographerSkillMaxAggregateInputType
  }

  export type PhotographerSkillGroupByOutputType = {
    id: string
    hostId: string
    skill: string
    _count: PhotographerSkillCountAggregateOutputType | null
    _min: PhotographerSkillMinAggregateOutputType | null
    _max: PhotographerSkillMaxAggregateOutputType | null
  }

  type GetPhotographerSkillGroupByPayload<T extends PhotographerSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotographerSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotographerSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotographerSkillGroupByOutputType[P]>
            : GetScalarType<T[P], PhotographerSkillGroupByOutputType[P]>
        }
      >
    >


  export type PhotographerSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    skill?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photographerSkill"]>

  export type PhotographerSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    skill?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photographerSkill"]>

  export type PhotographerSkillSelectScalar = {
    id?: boolean
    hostId?: boolean
    skill?: boolean
  }

  export type PhotographerSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }
  export type PhotographerSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }

  export type $PhotographerSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhotographerSkill"
    objects: {
      host: Prisma.$HostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hostId: string
      skill: string
    }, ExtArgs["result"]["photographerSkill"]>
    composites: {}
  }

  type PhotographerSkillGetPayload<S extends boolean | null | undefined | PhotographerSkillDefaultArgs> = $Result.GetResult<Prisma.$PhotographerSkillPayload, S>

  type PhotographerSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhotographerSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhotographerSkillCountAggregateInputType | true
    }

  export interface PhotographerSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhotographerSkill'], meta: { name: 'PhotographerSkill' } }
    /**
     * Find zero or one PhotographerSkill that matches the filter.
     * @param {PhotographerSkillFindUniqueArgs} args - Arguments to find a PhotographerSkill
     * @example
     * // Get one PhotographerSkill
     * const photographerSkill = await prisma.photographerSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotographerSkillFindUniqueArgs>(args: SelectSubset<T, PhotographerSkillFindUniqueArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PhotographerSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhotographerSkillFindUniqueOrThrowArgs} args - Arguments to find a PhotographerSkill
     * @example
     * // Get one PhotographerSkill
     * const photographerSkill = await prisma.photographerSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotographerSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotographerSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PhotographerSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerSkillFindFirstArgs} args - Arguments to find a PhotographerSkill
     * @example
     * // Get one PhotographerSkill
     * const photographerSkill = await prisma.photographerSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotographerSkillFindFirstArgs>(args?: SelectSubset<T, PhotographerSkillFindFirstArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PhotographerSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerSkillFindFirstOrThrowArgs} args - Arguments to find a PhotographerSkill
     * @example
     * // Get one PhotographerSkill
     * const photographerSkill = await prisma.photographerSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotographerSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotographerSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PhotographerSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotographerSkills
     * const photographerSkills = await prisma.photographerSkill.findMany()
     * 
     * // Get first 10 PhotographerSkills
     * const photographerSkills = await prisma.photographerSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photographerSkillWithIdOnly = await prisma.photographerSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotographerSkillFindManyArgs>(args?: SelectSubset<T, PhotographerSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PhotographerSkill.
     * @param {PhotographerSkillCreateArgs} args - Arguments to create a PhotographerSkill.
     * @example
     * // Create one PhotographerSkill
     * const PhotographerSkill = await prisma.photographerSkill.create({
     *   data: {
     *     // ... data to create a PhotographerSkill
     *   }
     * })
     * 
     */
    create<T extends PhotographerSkillCreateArgs>(args: SelectSubset<T, PhotographerSkillCreateArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PhotographerSkills.
     * @param {PhotographerSkillCreateManyArgs} args - Arguments to create many PhotographerSkills.
     * @example
     * // Create many PhotographerSkills
     * const photographerSkill = await prisma.photographerSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotographerSkillCreateManyArgs>(args?: SelectSubset<T, PhotographerSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhotographerSkills and returns the data saved in the database.
     * @param {PhotographerSkillCreateManyAndReturnArgs} args - Arguments to create many PhotographerSkills.
     * @example
     * // Create many PhotographerSkills
     * const photographerSkill = await prisma.photographerSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhotographerSkills and only return the `id`
     * const photographerSkillWithIdOnly = await prisma.photographerSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhotographerSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, PhotographerSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PhotographerSkill.
     * @param {PhotographerSkillDeleteArgs} args - Arguments to delete one PhotographerSkill.
     * @example
     * // Delete one PhotographerSkill
     * const PhotographerSkill = await prisma.photographerSkill.delete({
     *   where: {
     *     // ... filter to delete one PhotographerSkill
     *   }
     * })
     * 
     */
    delete<T extends PhotographerSkillDeleteArgs>(args: SelectSubset<T, PhotographerSkillDeleteArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PhotographerSkill.
     * @param {PhotographerSkillUpdateArgs} args - Arguments to update one PhotographerSkill.
     * @example
     * // Update one PhotographerSkill
     * const photographerSkill = await prisma.photographerSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotographerSkillUpdateArgs>(args: SelectSubset<T, PhotographerSkillUpdateArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PhotographerSkills.
     * @param {PhotographerSkillDeleteManyArgs} args - Arguments to filter PhotographerSkills to delete.
     * @example
     * // Delete a few PhotographerSkills
     * const { count } = await prisma.photographerSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotographerSkillDeleteManyArgs>(args?: SelectSubset<T, PhotographerSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotographerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotographerSkills
     * const photographerSkill = await prisma.photographerSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotographerSkillUpdateManyArgs>(args: SelectSubset<T, PhotographerSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhotographerSkill.
     * @param {PhotographerSkillUpsertArgs} args - Arguments to update or create a PhotographerSkill.
     * @example
     * // Update or create a PhotographerSkill
     * const photographerSkill = await prisma.photographerSkill.upsert({
     *   create: {
     *     // ... data to create a PhotographerSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotographerSkill we want to update
     *   }
     * })
     */
    upsert<T extends PhotographerSkillUpsertArgs>(args: SelectSubset<T, PhotographerSkillUpsertArgs<ExtArgs>>): Prisma__PhotographerSkillClient<$Result.GetResult<Prisma.$PhotographerSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PhotographerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerSkillCountArgs} args - Arguments to filter PhotographerSkills to count.
     * @example
     * // Count the number of PhotographerSkills
     * const count = await prisma.photographerSkill.count({
     *   where: {
     *     // ... the filter for the PhotographerSkills we want to count
     *   }
     * })
    **/
    count<T extends PhotographerSkillCountArgs>(
      args?: Subset<T, PhotographerSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotographerSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotographerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotographerSkillAggregateArgs>(args: Subset<T, PhotographerSkillAggregateArgs>): Prisma.PrismaPromise<GetPhotographerSkillAggregateType<T>>

    /**
     * Group by PhotographerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotographerSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotographerSkillGroupByArgs['orderBy'] }
        : { orderBy?: PhotographerSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotographerSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotographerSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhotographerSkill model
   */
  readonly fields: PhotographerSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotographerSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotographerSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends HostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HostDefaultArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhotographerSkill model
   */ 
  interface PhotographerSkillFieldRefs {
    readonly id: FieldRef<"PhotographerSkill", 'String'>
    readonly hostId: FieldRef<"PhotographerSkill", 'String'>
    readonly skill: FieldRef<"PhotographerSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PhotographerSkill findUnique
   */
  export type PhotographerSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerSkill to fetch.
     */
    where: PhotographerSkillWhereUniqueInput
  }

  /**
   * PhotographerSkill findUniqueOrThrow
   */
  export type PhotographerSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerSkill to fetch.
     */
    where: PhotographerSkillWhereUniqueInput
  }

  /**
   * PhotographerSkill findFirst
   */
  export type PhotographerSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerSkill to fetch.
     */
    where?: PhotographerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerSkills to fetch.
     */
    orderBy?: PhotographerSkillOrderByWithRelationInput | PhotographerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotographerSkills.
     */
    cursor?: PhotographerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotographerSkills.
     */
    distinct?: PhotographerSkillScalarFieldEnum | PhotographerSkillScalarFieldEnum[]
  }

  /**
   * PhotographerSkill findFirstOrThrow
   */
  export type PhotographerSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerSkill to fetch.
     */
    where?: PhotographerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerSkills to fetch.
     */
    orderBy?: PhotographerSkillOrderByWithRelationInput | PhotographerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotographerSkills.
     */
    cursor?: PhotographerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotographerSkills.
     */
    distinct?: PhotographerSkillScalarFieldEnum | PhotographerSkillScalarFieldEnum[]
  }

  /**
   * PhotographerSkill findMany
   */
  export type PhotographerSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerSkills to fetch.
     */
    where?: PhotographerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerSkills to fetch.
     */
    orderBy?: PhotographerSkillOrderByWithRelationInput | PhotographerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotographerSkills.
     */
    cursor?: PhotographerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerSkills.
     */
    skip?: number
    distinct?: PhotographerSkillScalarFieldEnum | PhotographerSkillScalarFieldEnum[]
  }

  /**
   * PhotographerSkill create
   */
  export type PhotographerSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a PhotographerSkill.
     */
    data: XOR<PhotographerSkillCreateInput, PhotographerSkillUncheckedCreateInput>
  }

  /**
   * PhotographerSkill createMany
   */
  export type PhotographerSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhotographerSkills.
     */
    data: PhotographerSkillCreateManyInput | PhotographerSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhotographerSkill createManyAndReturn
   */
  export type PhotographerSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PhotographerSkills.
     */
    data: PhotographerSkillCreateManyInput | PhotographerSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhotographerSkill update
   */
  export type PhotographerSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a PhotographerSkill.
     */
    data: XOR<PhotographerSkillUpdateInput, PhotographerSkillUncheckedUpdateInput>
    /**
     * Choose, which PhotographerSkill to update.
     */
    where: PhotographerSkillWhereUniqueInput
  }

  /**
   * PhotographerSkill updateMany
   */
  export type PhotographerSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhotographerSkills.
     */
    data: XOR<PhotographerSkillUpdateManyMutationInput, PhotographerSkillUncheckedUpdateManyInput>
    /**
     * Filter which PhotographerSkills to update
     */
    where?: PhotographerSkillWhereInput
  }

  /**
   * PhotographerSkill upsert
   */
  export type PhotographerSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the PhotographerSkill to update in case it exists.
     */
    where: PhotographerSkillWhereUniqueInput
    /**
     * In case the PhotographerSkill found by the `where` argument doesn't exist, create a new PhotographerSkill with this data.
     */
    create: XOR<PhotographerSkillCreateInput, PhotographerSkillUncheckedCreateInput>
    /**
     * In case the PhotographerSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotographerSkillUpdateInput, PhotographerSkillUncheckedUpdateInput>
  }

  /**
   * PhotographerSkill delete
   */
  export type PhotographerSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
    /**
     * Filter which PhotographerSkill to delete.
     */
    where: PhotographerSkillWhereUniqueInput
  }

  /**
   * PhotographerSkill deleteMany
   */
  export type PhotographerSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotographerSkills to delete
     */
    where?: PhotographerSkillWhereInput
  }

  /**
   * PhotographerSkill without action
   */
  export type PhotographerSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerSkill
     */
    select?: PhotographerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerSkillInclude<ExtArgs> | null
  }


  /**
   * Model PhotographerGear
   */

  export type AggregatePhotographerGear = {
    _count: PhotographerGearCountAggregateOutputType | null
    _min: PhotographerGearMinAggregateOutputType | null
    _max: PhotographerGearMaxAggregateOutputType | null
  }

  export type PhotographerGearMinAggregateOutputType = {
    id: string | null
    hostId: string | null
    gearType: string | null
    name: string | null
  }

  export type PhotographerGearMaxAggregateOutputType = {
    id: string | null
    hostId: string | null
    gearType: string | null
    name: string | null
  }

  export type PhotographerGearCountAggregateOutputType = {
    id: number
    hostId: number
    gearType: number
    name: number
    _all: number
  }


  export type PhotographerGearMinAggregateInputType = {
    id?: true
    hostId?: true
    gearType?: true
    name?: true
  }

  export type PhotographerGearMaxAggregateInputType = {
    id?: true
    hostId?: true
    gearType?: true
    name?: true
  }

  export type PhotographerGearCountAggregateInputType = {
    id?: true
    hostId?: true
    gearType?: true
    name?: true
    _all?: true
  }

  export type PhotographerGearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotographerGear to aggregate.
     */
    where?: PhotographerGearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerGears to fetch.
     */
    orderBy?: PhotographerGearOrderByWithRelationInput | PhotographerGearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotographerGearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerGears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerGears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotographerGears
    **/
    _count?: true | PhotographerGearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotographerGearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotographerGearMaxAggregateInputType
  }

  export type GetPhotographerGearAggregateType<T extends PhotographerGearAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotographerGear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotographerGear[P]>
      : GetScalarType<T[P], AggregatePhotographerGear[P]>
  }




  export type PhotographerGearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotographerGearWhereInput
    orderBy?: PhotographerGearOrderByWithAggregationInput | PhotographerGearOrderByWithAggregationInput[]
    by: PhotographerGearScalarFieldEnum[] | PhotographerGearScalarFieldEnum
    having?: PhotographerGearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotographerGearCountAggregateInputType | true
    _min?: PhotographerGearMinAggregateInputType
    _max?: PhotographerGearMaxAggregateInputType
  }

  export type PhotographerGearGroupByOutputType = {
    id: string
    hostId: string
    gearType: string
    name: string
    _count: PhotographerGearCountAggregateOutputType | null
    _min: PhotographerGearMinAggregateOutputType | null
    _max: PhotographerGearMaxAggregateOutputType | null
  }

  type GetPhotographerGearGroupByPayload<T extends PhotographerGearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotographerGearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotographerGearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotographerGearGroupByOutputType[P]>
            : GetScalarType<T[P], PhotographerGearGroupByOutputType[P]>
        }
      >
    >


  export type PhotographerGearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    gearType?: boolean
    name?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photographerGear"]>

  export type PhotographerGearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    gearType?: boolean
    name?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photographerGear"]>

  export type PhotographerGearSelectScalar = {
    id?: boolean
    hostId?: boolean
    gearType?: boolean
    name?: boolean
  }

  export type PhotographerGearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }
  export type PhotographerGearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }

  export type $PhotographerGearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhotographerGear"
    objects: {
      host: Prisma.$HostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hostId: string
      gearType: string
      name: string
    }, ExtArgs["result"]["photographerGear"]>
    composites: {}
  }

  type PhotographerGearGetPayload<S extends boolean | null | undefined | PhotographerGearDefaultArgs> = $Result.GetResult<Prisma.$PhotographerGearPayload, S>

  type PhotographerGearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhotographerGearFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhotographerGearCountAggregateInputType | true
    }

  export interface PhotographerGearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhotographerGear'], meta: { name: 'PhotographerGear' } }
    /**
     * Find zero or one PhotographerGear that matches the filter.
     * @param {PhotographerGearFindUniqueArgs} args - Arguments to find a PhotographerGear
     * @example
     * // Get one PhotographerGear
     * const photographerGear = await prisma.photographerGear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotographerGearFindUniqueArgs>(args: SelectSubset<T, PhotographerGearFindUniqueArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PhotographerGear that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhotographerGearFindUniqueOrThrowArgs} args - Arguments to find a PhotographerGear
     * @example
     * // Get one PhotographerGear
     * const photographerGear = await prisma.photographerGear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotographerGearFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotographerGearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PhotographerGear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerGearFindFirstArgs} args - Arguments to find a PhotographerGear
     * @example
     * // Get one PhotographerGear
     * const photographerGear = await prisma.photographerGear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotographerGearFindFirstArgs>(args?: SelectSubset<T, PhotographerGearFindFirstArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PhotographerGear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerGearFindFirstOrThrowArgs} args - Arguments to find a PhotographerGear
     * @example
     * // Get one PhotographerGear
     * const photographerGear = await prisma.photographerGear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotographerGearFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotographerGearFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PhotographerGears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerGearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotographerGears
     * const photographerGears = await prisma.photographerGear.findMany()
     * 
     * // Get first 10 PhotographerGears
     * const photographerGears = await prisma.photographerGear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photographerGearWithIdOnly = await prisma.photographerGear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotographerGearFindManyArgs>(args?: SelectSubset<T, PhotographerGearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PhotographerGear.
     * @param {PhotographerGearCreateArgs} args - Arguments to create a PhotographerGear.
     * @example
     * // Create one PhotographerGear
     * const PhotographerGear = await prisma.photographerGear.create({
     *   data: {
     *     // ... data to create a PhotographerGear
     *   }
     * })
     * 
     */
    create<T extends PhotographerGearCreateArgs>(args: SelectSubset<T, PhotographerGearCreateArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PhotographerGears.
     * @param {PhotographerGearCreateManyArgs} args - Arguments to create many PhotographerGears.
     * @example
     * // Create many PhotographerGears
     * const photographerGear = await prisma.photographerGear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotographerGearCreateManyArgs>(args?: SelectSubset<T, PhotographerGearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhotographerGears and returns the data saved in the database.
     * @param {PhotographerGearCreateManyAndReturnArgs} args - Arguments to create many PhotographerGears.
     * @example
     * // Create many PhotographerGears
     * const photographerGear = await prisma.photographerGear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhotographerGears and only return the `id`
     * const photographerGearWithIdOnly = await prisma.photographerGear.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhotographerGearCreateManyAndReturnArgs>(args?: SelectSubset<T, PhotographerGearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PhotographerGear.
     * @param {PhotographerGearDeleteArgs} args - Arguments to delete one PhotographerGear.
     * @example
     * // Delete one PhotographerGear
     * const PhotographerGear = await prisma.photographerGear.delete({
     *   where: {
     *     // ... filter to delete one PhotographerGear
     *   }
     * })
     * 
     */
    delete<T extends PhotographerGearDeleteArgs>(args: SelectSubset<T, PhotographerGearDeleteArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PhotographerGear.
     * @param {PhotographerGearUpdateArgs} args - Arguments to update one PhotographerGear.
     * @example
     * // Update one PhotographerGear
     * const photographerGear = await prisma.photographerGear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotographerGearUpdateArgs>(args: SelectSubset<T, PhotographerGearUpdateArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PhotographerGears.
     * @param {PhotographerGearDeleteManyArgs} args - Arguments to filter PhotographerGears to delete.
     * @example
     * // Delete a few PhotographerGears
     * const { count } = await prisma.photographerGear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotographerGearDeleteManyArgs>(args?: SelectSubset<T, PhotographerGearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotographerGears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerGearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotographerGears
     * const photographerGear = await prisma.photographerGear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotographerGearUpdateManyArgs>(args: SelectSubset<T, PhotographerGearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhotographerGear.
     * @param {PhotographerGearUpsertArgs} args - Arguments to update or create a PhotographerGear.
     * @example
     * // Update or create a PhotographerGear
     * const photographerGear = await prisma.photographerGear.upsert({
     *   create: {
     *     // ... data to create a PhotographerGear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotographerGear we want to update
     *   }
     * })
     */
    upsert<T extends PhotographerGearUpsertArgs>(args: SelectSubset<T, PhotographerGearUpsertArgs<ExtArgs>>): Prisma__PhotographerGearClient<$Result.GetResult<Prisma.$PhotographerGearPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PhotographerGears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerGearCountArgs} args - Arguments to filter PhotographerGears to count.
     * @example
     * // Count the number of PhotographerGears
     * const count = await prisma.photographerGear.count({
     *   where: {
     *     // ... the filter for the PhotographerGears we want to count
     *   }
     * })
    **/
    count<T extends PhotographerGearCountArgs>(
      args?: Subset<T, PhotographerGearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotographerGearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotographerGear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerGearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotographerGearAggregateArgs>(args: Subset<T, PhotographerGearAggregateArgs>): Prisma.PrismaPromise<GetPhotographerGearAggregateType<T>>

    /**
     * Group by PhotographerGear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotographerGearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotographerGearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotographerGearGroupByArgs['orderBy'] }
        : { orderBy?: PhotographerGearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotographerGearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotographerGearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhotographerGear model
   */
  readonly fields: PhotographerGearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotographerGear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotographerGearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends HostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HostDefaultArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhotographerGear model
   */ 
  interface PhotographerGearFieldRefs {
    readonly id: FieldRef<"PhotographerGear", 'String'>
    readonly hostId: FieldRef<"PhotographerGear", 'String'>
    readonly gearType: FieldRef<"PhotographerGear", 'String'>
    readonly name: FieldRef<"PhotographerGear", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PhotographerGear findUnique
   */
  export type PhotographerGearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerGear to fetch.
     */
    where: PhotographerGearWhereUniqueInput
  }

  /**
   * PhotographerGear findUniqueOrThrow
   */
  export type PhotographerGearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerGear to fetch.
     */
    where: PhotographerGearWhereUniqueInput
  }

  /**
   * PhotographerGear findFirst
   */
  export type PhotographerGearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerGear to fetch.
     */
    where?: PhotographerGearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerGears to fetch.
     */
    orderBy?: PhotographerGearOrderByWithRelationInput | PhotographerGearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotographerGears.
     */
    cursor?: PhotographerGearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerGears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerGears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotographerGears.
     */
    distinct?: PhotographerGearScalarFieldEnum | PhotographerGearScalarFieldEnum[]
  }

  /**
   * PhotographerGear findFirstOrThrow
   */
  export type PhotographerGearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerGear to fetch.
     */
    where?: PhotographerGearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerGears to fetch.
     */
    orderBy?: PhotographerGearOrderByWithRelationInput | PhotographerGearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotographerGears.
     */
    cursor?: PhotographerGearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerGears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerGears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotographerGears.
     */
    distinct?: PhotographerGearScalarFieldEnum | PhotographerGearScalarFieldEnum[]
  }

  /**
   * PhotographerGear findMany
   */
  export type PhotographerGearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * Filter, which PhotographerGears to fetch.
     */
    where?: PhotographerGearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotographerGears to fetch.
     */
    orderBy?: PhotographerGearOrderByWithRelationInput | PhotographerGearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotographerGears.
     */
    cursor?: PhotographerGearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotographerGears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotographerGears.
     */
    skip?: number
    distinct?: PhotographerGearScalarFieldEnum | PhotographerGearScalarFieldEnum[]
  }

  /**
   * PhotographerGear create
   */
  export type PhotographerGearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * The data needed to create a PhotographerGear.
     */
    data: XOR<PhotographerGearCreateInput, PhotographerGearUncheckedCreateInput>
  }

  /**
   * PhotographerGear createMany
   */
  export type PhotographerGearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhotographerGears.
     */
    data: PhotographerGearCreateManyInput | PhotographerGearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhotographerGear createManyAndReturn
   */
  export type PhotographerGearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PhotographerGears.
     */
    data: PhotographerGearCreateManyInput | PhotographerGearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhotographerGear update
   */
  export type PhotographerGearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * The data needed to update a PhotographerGear.
     */
    data: XOR<PhotographerGearUpdateInput, PhotographerGearUncheckedUpdateInput>
    /**
     * Choose, which PhotographerGear to update.
     */
    where: PhotographerGearWhereUniqueInput
  }

  /**
   * PhotographerGear updateMany
   */
  export type PhotographerGearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhotographerGears.
     */
    data: XOR<PhotographerGearUpdateManyMutationInput, PhotographerGearUncheckedUpdateManyInput>
    /**
     * Filter which PhotographerGears to update
     */
    where?: PhotographerGearWhereInput
  }

  /**
   * PhotographerGear upsert
   */
  export type PhotographerGearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * The filter to search for the PhotographerGear to update in case it exists.
     */
    where: PhotographerGearWhereUniqueInput
    /**
     * In case the PhotographerGear found by the `where` argument doesn't exist, create a new PhotographerGear with this data.
     */
    create: XOR<PhotographerGearCreateInput, PhotographerGearUncheckedCreateInput>
    /**
     * In case the PhotographerGear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotographerGearUpdateInput, PhotographerGearUncheckedUpdateInput>
  }

  /**
   * PhotographerGear delete
   */
  export type PhotographerGearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
    /**
     * Filter which PhotographerGear to delete.
     */
    where: PhotographerGearWhereUniqueInput
  }

  /**
   * PhotographerGear deleteMany
   */
  export type PhotographerGearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotographerGears to delete
     */
    where?: PhotographerGearWhereInput
  }

  /**
   * PhotographerGear without action
   */
  export type PhotographerGearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotographerGear
     */
    select?: PhotographerGearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotographerGearInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    hostId: string | null
    title: string | null
    description: string | null
    type: $Enums.ServiceType | null
    price: number | null
    currency: $Enums.CurrencyCode | null
    duration: number | null
    createdAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    hostId: string | null
    title: string | null
    description: string | null
    type: $Enums.ServiceType | null
    price: number | null
    currency: $Enums.CurrencyCode | null
    duration: number | null
    createdAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    hostId: number
    title: number
    description: number
    type: number
    price: number
    currency: number
    duration: number
    tags: number
    images: number
    createdAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    hostId?: true
    title?: true
    description?: true
    type?: true
    price?: true
    currency?: true
    duration?: true
    createdAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    hostId?: true
    title?: true
    description?: true
    type?: true
    price?: true
    currency?: true
    duration?: true
    createdAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    hostId?: true
    title?: true
    description?: true
    type?: true
    price?: true
    currency?: true
    duration?: true
    tags?: true
    images?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    hostId: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency: $Enums.CurrencyCode
    duration: number
    tags: string[]
    images: string[]
    createdAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    tags?: boolean
    images?: boolean
    createdAt?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    wishlist?: boolean | Service$wishlistArgs<ExtArgs>
    itineraries?: boolean | Service$itinerariesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    tags?: boolean
    images?: boolean
    createdAt?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    hostId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    tags?: boolean
    images?: boolean
    createdAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    wishlist?: boolean | Service$wishlistArgs<ExtArgs>
    itineraries?: boolean | Service$itinerariesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      host: Prisma.$HostPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      wishlist: Prisma.$WishlistPayload<ExtArgs>[]
      itineraries: Prisma.$ItineraryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hostId: string
      title: string
      description: string
      type: $Enums.ServiceType
      price: number
      currency: $Enums.CurrencyCode
      duration: number
      tags: string[]
      images: string[]
      createdAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends HostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HostDefaultArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    wishlist<T extends Service$wishlistArgs<ExtArgs> = {}>(args?: Subset<T, Service$wishlistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany"> | Null>
    itineraries<T extends Service$itinerariesArgs<ExtArgs> = {}>(args?: Subset<T, Service$itinerariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly hostId: FieldRef<"Service", 'String'>
    readonly title: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly type: FieldRef<"Service", 'ServiceType'>
    readonly price: FieldRef<"Service", 'Int'>
    readonly currency: FieldRef<"Service", 'CurrencyCode'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly tags: FieldRef<"Service", 'String[]'>
    readonly images: FieldRef<"Service", 'String[]'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Service.wishlist
   */
  export type Service$wishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    cursor?: WishlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Service.itineraries
   */
  export type Service$itinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Itinerary
   */

  export type AggregateItinerary = {
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  export type ItineraryAvgAggregateOutputType = {
    step: number | null
    duration: number | null
  }

  export type ItinerarySumAggregateOutputType = {
    step: number | null
    duration: number | null
  }

  export type ItineraryMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    step: number | null
    title: string | null
    description: string | null
    duration: number | null
  }

  export type ItineraryMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    step: number | null
    title: string | null
    description: string | null
    duration: number | null
  }

  export type ItineraryCountAggregateOutputType = {
    id: number
    serviceId: number
    step: number
    title: number
    description: number
    duration: number
    _all: number
  }


  export type ItineraryAvgAggregateInputType = {
    step?: true
    duration?: true
  }

  export type ItinerarySumAggregateInputType = {
    step?: true
    duration?: true
  }

  export type ItineraryMinAggregateInputType = {
    id?: true
    serviceId?: true
    step?: true
    title?: true
    description?: true
    duration?: true
  }

  export type ItineraryMaxAggregateInputType = {
    id?: true
    serviceId?: true
    step?: true
    title?: true
    description?: true
    duration?: true
  }

  export type ItineraryCountAggregateInputType = {
    id?: true
    serviceId?: true
    step?: true
    title?: true
    description?: true
    duration?: true
    _all?: true
  }

  export type ItineraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itinerary to aggregate.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Itineraries
    **/
    _count?: true | ItineraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItineraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryMaxAggregateInputType
  }

  export type GetItineraryAggregateType<T extends ItineraryAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerary[P]>
      : GetScalarType<T[P], AggregateItinerary[P]>
  }




  export type ItineraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithAggregationInput | ItineraryOrderByWithAggregationInput[]
    by: ItineraryScalarFieldEnum[] | ItineraryScalarFieldEnum
    having?: ItineraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryCountAggregateInputType | true
    _avg?: ItineraryAvgAggregateInputType
    _sum?: ItinerarySumAggregateInputType
    _min?: ItineraryMinAggregateInputType
    _max?: ItineraryMaxAggregateInputType
  }

  export type ItineraryGroupByOutputType = {
    id: string
    serviceId: string
    step: number
    title: string
    description: string
    duration: number
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  type GetItineraryGroupByPayload<T extends ItineraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItineraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    step?: boolean
    title?: boolean
    description?: boolean
    duration?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    step?: boolean
    title?: boolean
    description?: boolean
    duration?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectScalar = {
    id?: boolean
    serviceId?: boolean
    step?: boolean
    title?: boolean
    description?: boolean
    duration?: boolean
  }

  export type ItineraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ItineraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ItineraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Itinerary"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      step: number
      title: string
      description: string
      duration: number
    }, ExtArgs["result"]["itinerary"]>
    composites: {}
  }

  type ItineraryGetPayload<S extends boolean | null | undefined | ItineraryDefaultArgs> = $Result.GetResult<Prisma.$ItineraryPayload, S>

  type ItineraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItineraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItineraryCountAggregateInputType | true
    }

  export interface ItineraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Itinerary'], meta: { name: 'Itinerary' } }
    /**
     * Find zero or one Itinerary that matches the filter.
     * @param {ItineraryFindUniqueArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItineraryFindUniqueArgs>(args: SelectSubset<T, ItineraryFindUniqueArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Itinerary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItineraryFindUniqueOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItineraryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItineraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItineraryFindFirstArgs>(args?: SelectSubset<T, ItineraryFindFirstArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItineraryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItineraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Itineraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itineraries
     * const itineraries = await prisma.itinerary.findMany()
     * 
     * // Get first 10 Itineraries
     * const itineraries = await prisma.itinerary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItineraryFindManyArgs>(args?: SelectSubset<T, ItineraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Itinerary.
     * @param {ItineraryCreateArgs} args - Arguments to create a Itinerary.
     * @example
     * // Create one Itinerary
     * const Itinerary = await prisma.itinerary.create({
     *   data: {
     *     // ... data to create a Itinerary
     *   }
     * })
     * 
     */
    create<T extends ItineraryCreateArgs>(args: SelectSubset<T, ItineraryCreateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Itineraries.
     * @param {ItineraryCreateManyArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItineraryCreateManyArgs>(args?: SelectSubset<T, ItineraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Itineraries and returns the data saved in the database.
     * @param {ItineraryCreateManyAndReturnArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Itineraries and only return the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItineraryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItineraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Itinerary.
     * @param {ItineraryDeleteArgs} args - Arguments to delete one Itinerary.
     * @example
     * // Delete one Itinerary
     * const Itinerary = await prisma.itinerary.delete({
     *   where: {
     *     // ... filter to delete one Itinerary
     *   }
     * })
     * 
     */
    delete<T extends ItineraryDeleteArgs>(args: SelectSubset<T, ItineraryDeleteArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Itinerary.
     * @param {ItineraryUpdateArgs} args - Arguments to update one Itinerary.
     * @example
     * // Update one Itinerary
     * const itinerary = await prisma.itinerary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItineraryUpdateArgs>(args: SelectSubset<T, ItineraryUpdateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Itineraries.
     * @param {ItineraryDeleteManyArgs} args - Arguments to filter Itineraries to delete.
     * @example
     * // Delete a few Itineraries
     * const { count } = await prisma.itinerary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItineraryDeleteManyArgs>(args?: SelectSubset<T, ItineraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itineraries
     * const itinerary = await prisma.itinerary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItineraryUpdateManyArgs>(args: SelectSubset<T, ItineraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Itinerary.
     * @param {ItineraryUpsertArgs} args - Arguments to update or create a Itinerary.
     * @example
     * // Update or create a Itinerary
     * const itinerary = await prisma.itinerary.upsert({
     *   create: {
     *     // ... data to create a Itinerary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itinerary we want to update
     *   }
     * })
     */
    upsert<T extends ItineraryUpsertArgs>(args: SelectSubset<T, ItineraryUpsertArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryCountArgs} args - Arguments to filter Itineraries to count.
     * @example
     * // Count the number of Itineraries
     * const count = await prisma.itinerary.count({
     *   where: {
     *     // ... the filter for the Itineraries we want to count
     *   }
     * })
    **/
    count<T extends ItineraryCountArgs>(
      args?: Subset<T, ItineraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryAggregateArgs>(args: Subset<T, ItineraryAggregateArgs>): Prisma.PrismaPromise<GetItineraryAggregateType<T>>

    /**
     * Group by Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Itinerary model
   */
  readonly fields: ItineraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Itinerary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItineraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Itinerary model
   */ 
  interface ItineraryFieldRefs {
    readonly id: FieldRef<"Itinerary", 'String'>
    readonly serviceId: FieldRef<"Itinerary", 'String'>
    readonly step: FieldRef<"Itinerary", 'Int'>
    readonly title: FieldRef<"Itinerary", 'String'>
    readonly description: FieldRef<"Itinerary", 'String'>
    readonly duration: FieldRef<"Itinerary", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Itinerary findUnique
   */
  export type ItineraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findUniqueOrThrow
   */
  export type ItineraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findFirst
   */
  export type ItineraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findFirstOrThrow
   */
  export type ItineraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findMany
   */
  export type ItineraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itineraries to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary create
   */
  export type ItineraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Itinerary.
     */
    data: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
  }

  /**
   * Itinerary createMany
   */
  export type ItineraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Itinerary createManyAndReturn
   */
  export type ItineraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Itinerary update
   */
  export type ItineraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Itinerary.
     */
    data: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
    /**
     * Choose, which Itinerary to update.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary updateMany
   */
  export type ItineraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Itineraries.
     */
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyInput>
    /**
     * Filter which Itineraries to update
     */
    where?: ItineraryWhereInput
  }

  /**
   * Itinerary upsert
   */
  export type ItineraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Itinerary to update in case it exists.
     */
    where: ItineraryWhereUniqueInput
    /**
     * In case the Itinerary found by the `where` argument doesn't exist, create a new Itinerary with this data.
     */
    create: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
    /**
     * In case the Itinerary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
  }

  /**
   * Itinerary delete
   */
  export type ItineraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter which Itinerary to delete.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary deleteMany
   */
  export type ItineraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itineraries to delete
     */
    where?: ItineraryWhereInput
  }

  /**
   * Itinerary without action
   */
  export type ItineraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    adults: number | null
    children: number | null
    totalPrice: number | null
  }

  export type BookingSumAggregateOutputType = {
    adults: number | null
    children: number | null
    totalPrice: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    date: Date | null
    adults: number | null
    children: number | null
    contactMethod: $Enums.ContactMethod | null
    contactDetail: string | null
    meetingPoint: string | null
    totalPrice: number | null
    currency: $Enums.CurrencyCode | null
    status: $Enums.BookingStatus | null
    promoCodeId: string | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    date: Date | null
    adults: number | null
    children: number | null
    contactMethod: $Enums.ContactMethod | null
    contactDetail: string | null
    meetingPoint: string | null
    totalPrice: number | null
    currency: $Enums.CurrencyCode | null
    status: $Enums.BookingStatus | null
    promoCodeId: string | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    date: number
    adults: number
    children: number
    contactMethod: number
    contactDetail: number
    meetingPoint: number
    totalPrice: number
    currency: number
    status: number
    promoCodeId: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    adults?: true
    children?: true
    totalPrice?: true
  }

  export type BookingSumAggregateInputType = {
    adults?: true
    children?: true
    totalPrice?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    date?: true
    adults?: true
    children?: true
    contactMethod?: true
    contactDetail?: true
    meetingPoint?: true
    totalPrice?: true
    currency?: true
    status?: true
    promoCodeId?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    date?: true
    adults?: true
    children?: true
    contactMethod?: true
    contactDetail?: true
    meetingPoint?: true
    totalPrice?: true
    currency?: true
    status?: true
    promoCodeId?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    date?: true
    adults?: true
    children?: true
    contactMethod?: true
    contactDetail?: true
    meetingPoint?: true
    totalPrice?: true
    currency?: true
    status?: true
    promoCodeId?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    date: Date
    adults: number
    children: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint: string | null
    totalPrice: number
    currency: $Enums.CurrencyCode
    status: $Enums.BookingStatus
    promoCodeId: string | null
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    date?: boolean
    adults?: boolean
    children?: boolean
    contactMethod?: boolean
    contactDetail?: boolean
    meetingPoint?: boolean
    totalPrice?: boolean
    currency?: boolean
    status?: boolean
    promoCodeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
    review?: boolean | Booking$reviewArgs<ExtArgs>
    currencyConversionLog?: boolean | Booking$currencyConversionLogArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    date?: boolean
    adults?: boolean
    children?: boolean
    contactMethod?: boolean
    contactDetail?: boolean
    meetingPoint?: boolean
    totalPrice?: boolean
    currency?: boolean
    status?: boolean
    promoCodeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    date?: boolean
    adults?: boolean
    children?: boolean
    contactMethod?: boolean
    contactDetail?: boolean
    meetingPoint?: boolean
    totalPrice?: boolean
    currency?: boolean
    status?: boolean
    promoCodeId?: boolean
    createdAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
    review?: boolean | Booking$reviewArgs<ExtArgs>
    currencyConversionLog?: boolean | Booking$currencyConversionLogArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    promoCode?: boolean | Booking$promoCodeArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      promoCode: Prisma.$PromoCodePayload<ExtArgs> | null
      review: Prisma.$ReviewPayload<ExtArgs> | null
      currencyConversionLog: Prisma.$CurrencyConversionLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceId: string
      date: Date
      adults: number
      children: number
      contactMethod: $Enums.ContactMethod
      contactDetail: string
      meetingPoint: string | null
      totalPrice: number
      currency: $Enums.CurrencyCode
      status: $Enums.BookingStatus
      promoCodeId: string | null
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    promoCode<T extends Booking$promoCodeArgs<ExtArgs> = {}>(args?: Subset<T, Booking$promoCodeArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    review<T extends Booking$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Booking$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    currencyConversionLog<T extends Booking$currencyConversionLogArgs<ExtArgs> = {}>(args?: Subset<T, Booking$currencyConversionLogArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly serviceId: FieldRef<"Booking", 'String'>
    readonly date: FieldRef<"Booking", 'DateTime'>
    readonly adults: FieldRef<"Booking", 'Int'>
    readonly children: FieldRef<"Booking", 'Int'>
    readonly contactMethod: FieldRef<"Booking", 'ContactMethod'>
    readonly contactDetail: FieldRef<"Booking", 'String'>
    readonly meetingPoint: FieldRef<"Booking", 'String'>
    readonly totalPrice: FieldRef<"Booking", 'Int'>
    readonly currency: FieldRef<"Booking", 'CurrencyCode'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly promoCodeId: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.promoCode
   */
  export type Booking$promoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
  }

  /**
   * Booking.review
   */
  export type Booking$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * Booking.currencyConversionLog
   */
  export type Booking$currencyConversionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    where?: CurrencyConversionLogWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model CurrencyConversionLog
   */

  export type AggregateCurrencyConversionLog = {
    _count: CurrencyConversionLogCountAggregateOutputType | null
    _avg: CurrencyConversionLogAvgAggregateOutputType | null
    _sum: CurrencyConversionLogSumAggregateOutputType | null
    _min: CurrencyConversionLogMinAggregateOutputType | null
    _max: CurrencyConversionLogMaxAggregateOutputType | null
  }

  export type CurrencyConversionLogAvgAggregateOutputType = {
    rate: number | null
    convertedAmount: number | null
  }

  export type CurrencyConversionLogSumAggregateOutputType = {
    rate: number | null
    convertedAmount: number | null
  }

  export type CurrencyConversionLogMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    sourceCurrency: $Enums.CurrencyCode | null
    targetCurrency: $Enums.CurrencyCode | null
    rate: number | null
    convertedAmount: number | null
    createdAt: Date | null
  }

  export type CurrencyConversionLogMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    sourceCurrency: $Enums.CurrencyCode | null
    targetCurrency: $Enums.CurrencyCode | null
    rate: number | null
    convertedAmount: number | null
    createdAt: Date | null
  }

  export type CurrencyConversionLogCountAggregateOutputType = {
    id: number
    bookingId: number
    sourceCurrency: number
    targetCurrency: number
    rate: number
    convertedAmount: number
    createdAt: number
    _all: number
  }


  export type CurrencyConversionLogAvgAggregateInputType = {
    rate?: true
    convertedAmount?: true
  }

  export type CurrencyConversionLogSumAggregateInputType = {
    rate?: true
    convertedAmount?: true
  }

  export type CurrencyConversionLogMinAggregateInputType = {
    id?: true
    bookingId?: true
    sourceCurrency?: true
    targetCurrency?: true
    rate?: true
    convertedAmount?: true
    createdAt?: true
  }

  export type CurrencyConversionLogMaxAggregateInputType = {
    id?: true
    bookingId?: true
    sourceCurrency?: true
    targetCurrency?: true
    rate?: true
    convertedAmount?: true
    createdAt?: true
  }

  export type CurrencyConversionLogCountAggregateInputType = {
    id?: true
    bookingId?: true
    sourceCurrency?: true
    targetCurrency?: true
    rate?: true
    convertedAmount?: true
    createdAt?: true
    _all?: true
  }

  export type CurrencyConversionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrencyConversionLog to aggregate.
     */
    where?: CurrencyConversionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyConversionLogs to fetch.
     */
    orderBy?: CurrencyConversionLogOrderByWithRelationInput | CurrencyConversionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyConversionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyConversionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyConversionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurrencyConversionLogs
    **/
    _count?: true | CurrencyConversionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyConversionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencyConversionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyConversionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyConversionLogMaxAggregateInputType
  }

  export type GetCurrencyConversionLogAggregateType<T extends CurrencyConversionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrencyConversionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrencyConversionLog[P]>
      : GetScalarType<T[P], AggregateCurrencyConversionLog[P]>
  }




  export type CurrencyConversionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyConversionLogWhereInput
    orderBy?: CurrencyConversionLogOrderByWithAggregationInput | CurrencyConversionLogOrderByWithAggregationInput[]
    by: CurrencyConversionLogScalarFieldEnum[] | CurrencyConversionLogScalarFieldEnum
    having?: CurrencyConversionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyConversionLogCountAggregateInputType | true
    _avg?: CurrencyConversionLogAvgAggregateInputType
    _sum?: CurrencyConversionLogSumAggregateInputType
    _min?: CurrencyConversionLogMinAggregateInputType
    _max?: CurrencyConversionLogMaxAggregateInputType
  }

  export type CurrencyConversionLogGroupByOutputType = {
    id: string
    bookingId: string
    sourceCurrency: $Enums.CurrencyCode
    targetCurrency: $Enums.CurrencyCode
    rate: number
    convertedAmount: number
    createdAt: Date
    _count: CurrencyConversionLogCountAggregateOutputType | null
    _avg: CurrencyConversionLogAvgAggregateOutputType | null
    _sum: CurrencyConversionLogSumAggregateOutputType | null
    _min: CurrencyConversionLogMinAggregateOutputType | null
    _max: CurrencyConversionLogMaxAggregateOutputType | null
  }

  type GetCurrencyConversionLogGroupByPayload<T extends CurrencyConversionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyConversionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyConversionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyConversionLogGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyConversionLogGroupByOutputType[P]>
        }
      >
    >


  export type CurrencyConversionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    sourceCurrency?: boolean
    targetCurrency?: boolean
    rate?: boolean
    convertedAmount?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currencyConversionLog"]>

  export type CurrencyConversionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    sourceCurrency?: boolean
    targetCurrency?: boolean
    rate?: boolean
    convertedAmount?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currencyConversionLog"]>

  export type CurrencyConversionLogSelectScalar = {
    id?: boolean
    bookingId?: boolean
    sourceCurrency?: boolean
    targetCurrency?: boolean
    rate?: boolean
    convertedAmount?: boolean
    createdAt?: boolean
  }

  export type CurrencyConversionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type CurrencyConversionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $CurrencyConversionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurrencyConversionLog"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      sourceCurrency: $Enums.CurrencyCode
      targetCurrency: $Enums.CurrencyCode
      rate: number
      convertedAmount: number
      createdAt: Date
    }, ExtArgs["result"]["currencyConversionLog"]>
    composites: {}
  }

  type CurrencyConversionLogGetPayload<S extends boolean | null | undefined | CurrencyConversionLogDefaultArgs> = $Result.GetResult<Prisma.$CurrencyConversionLogPayload, S>

  type CurrencyConversionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CurrencyConversionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CurrencyConversionLogCountAggregateInputType | true
    }

  export interface CurrencyConversionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurrencyConversionLog'], meta: { name: 'CurrencyConversionLog' } }
    /**
     * Find zero or one CurrencyConversionLog that matches the filter.
     * @param {CurrencyConversionLogFindUniqueArgs} args - Arguments to find a CurrencyConversionLog
     * @example
     * // Get one CurrencyConversionLog
     * const currencyConversionLog = await prisma.currencyConversionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyConversionLogFindUniqueArgs>(args: SelectSubset<T, CurrencyConversionLogFindUniqueArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CurrencyConversionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CurrencyConversionLogFindUniqueOrThrowArgs} args - Arguments to find a CurrencyConversionLog
     * @example
     * // Get one CurrencyConversionLog
     * const currencyConversionLog = await prisma.currencyConversionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyConversionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyConversionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CurrencyConversionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyConversionLogFindFirstArgs} args - Arguments to find a CurrencyConversionLog
     * @example
     * // Get one CurrencyConversionLog
     * const currencyConversionLog = await prisma.currencyConversionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyConversionLogFindFirstArgs>(args?: SelectSubset<T, CurrencyConversionLogFindFirstArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CurrencyConversionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyConversionLogFindFirstOrThrowArgs} args - Arguments to find a CurrencyConversionLog
     * @example
     * // Get one CurrencyConversionLog
     * const currencyConversionLog = await prisma.currencyConversionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyConversionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyConversionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CurrencyConversionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyConversionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurrencyConversionLogs
     * const currencyConversionLogs = await prisma.currencyConversionLog.findMany()
     * 
     * // Get first 10 CurrencyConversionLogs
     * const currencyConversionLogs = await prisma.currencyConversionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyConversionLogWithIdOnly = await prisma.currencyConversionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyConversionLogFindManyArgs>(args?: SelectSubset<T, CurrencyConversionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CurrencyConversionLog.
     * @param {CurrencyConversionLogCreateArgs} args - Arguments to create a CurrencyConversionLog.
     * @example
     * // Create one CurrencyConversionLog
     * const CurrencyConversionLog = await prisma.currencyConversionLog.create({
     *   data: {
     *     // ... data to create a CurrencyConversionLog
     *   }
     * })
     * 
     */
    create<T extends CurrencyConversionLogCreateArgs>(args: SelectSubset<T, CurrencyConversionLogCreateArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CurrencyConversionLogs.
     * @param {CurrencyConversionLogCreateManyArgs} args - Arguments to create many CurrencyConversionLogs.
     * @example
     * // Create many CurrencyConversionLogs
     * const currencyConversionLog = await prisma.currencyConversionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyConversionLogCreateManyArgs>(args?: SelectSubset<T, CurrencyConversionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CurrencyConversionLogs and returns the data saved in the database.
     * @param {CurrencyConversionLogCreateManyAndReturnArgs} args - Arguments to create many CurrencyConversionLogs.
     * @example
     * // Create many CurrencyConversionLogs
     * const currencyConversionLog = await prisma.currencyConversionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CurrencyConversionLogs and only return the `id`
     * const currencyConversionLogWithIdOnly = await prisma.currencyConversionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyConversionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyConversionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CurrencyConversionLog.
     * @param {CurrencyConversionLogDeleteArgs} args - Arguments to delete one CurrencyConversionLog.
     * @example
     * // Delete one CurrencyConversionLog
     * const CurrencyConversionLog = await prisma.currencyConversionLog.delete({
     *   where: {
     *     // ... filter to delete one CurrencyConversionLog
     *   }
     * })
     * 
     */
    delete<T extends CurrencyConversionLogDeleteArgs>(args: SelectSubset<T, CurrencyConversionLogDeleteArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CurrencyConversionLog.
     * @param {CurrencyConversionLogUpdateArgs} args - Arguments to update one CurrencyConversionLog.
     * @example
     * // Update one CurrencyConversionLog
     * const currencyConversionLog = await prisma.currencyConversionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyConversionLogUpdateArgs>(args: SelectSubset<T, CurrencyConversionLogUpdateArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CurrencyConversionLogs.
     * @param {CurrencyConversionLogDeleteManyArgs} args - Arguments to filter CurrencyConversionLogs to delete.
     * @example
     * // Delete a few CurrencyConversionLogs
     * const { count } = await prisma.currencyConversionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyConversionLogDeleteManyArgs>(args?: SelectSubset<T, CurrencyConversionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrencyConversionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyConversionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurrencyConversionLogs
     * const currencyConversionLog = await prisma.currencyConversionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyConversionLogUpdateManyArgs>(args: SelectSubset<T, CurrencyConversionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CurrencyConversionLog.
     * @param {CurrencyConversionLogUpsertArgs} args - Arguments to update or create a CurrencyConversionLog.
     * @example
     * // Update or create a CurrencyConversionLog
     * const currencyConversionLog = await prisma.currencyConversionLog.upsert({
     *   create: {
     *     // ... data to create a CurrencyConversionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurrencyConversionLog we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyConversionLogUpsertArgs>(args: SelectSubset<T, CurrencyConversionLogUpsertArgs<ExtArgs>>): Prisma__CurrencyConversionLogClient<$Result.GetResult<Prisma.$CurrencyConversionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CurrencyConversionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyConversionLogCountArgs} args - Arguments to filter CurrencyConversionLogs to count.
     * @example
     * // Count the number of CurrencyConversionLogs
     * const count = await prisma.currencyConversionLog.count({
     *   where: {
     *     // ... the filter for the CurrencyConversionLogs we want to count
     *   }
     * })
    **/
    count<T extends CurrencyConversionLogCountArgs>(
      args?: Subset<T, CurrencyConversionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyConversionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurrencyConversionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyConversionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyConversionLogAggregateArgs>(args: Subset<T, CurrencyConversionLogAggregateArgs>): Prisma.PrismaPromise<GetCurrencyConversionLogAggregateType<T>>

    /**
     * Group by CurrencyConversionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyConversionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyConversionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyConversionLogGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyConversionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyConversionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyConversionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurrencyConversionLog model
   */
  readonly fields: CurrencyConversionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurrencyConversionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyConversionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurrencyConversionLog model
   */ 
  interface CurrencyConversionLogFieldRefs {
    readonly id: FieldRef<"CurrencyConversionLog", 'String'>
    readonly bookingId: FieldRef<"CurrencyConversionLog", 'String'>
    readonly sourceCurrency: FieldRef<"CurrencyConversionLog", 'CurrencyCode'>
    readonly targetCurrency: FieldRef<"CurrencyConversionLog", 'CurrencyCode'>
    readonly rate: FieldRef<"CurrencyConversionLog", 'Float'>
    readonly convertedAmount: FieldRef<"CurrencyConversionLog", 'Int'>
    readonly createdAt: FieldRef<"CurrencyConversionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CurrencyConversionLog findUnique
   */
  export type CurrencyConversionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyConversionLog to fetch.
     */
    where: CurrencyConversionLogWhereUniqueInput
  }

  /**
   * CurrencyConversionLog findUniqueOrThrow
   */
  export type CurrencyConversionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyConversionLog to fetch.
     */
    where: CurrencyConversionLogWhereUniqueInput
  }

  /**
   * CurrencyConversionLog findFirst
   */
  export type CurrencyConversionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyConversionLog to fetch.
     */
    where?: CurrencyConversionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyConversionLogs to fetch.
     */
    orderBy?: CurrencyConversionLogOrderByWithRelationInput | CurrencyConversionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrencyConversionLogs.
     */
    cursor?: CurrencyConversionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyConversionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyConversionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrencyConversionLogs.
     */
    distinct?: CurrencyConversionLogScalarFieldEnum | CurrencyConversionLogScalarFieldEnum[]
  }

  /**
   * CurrencyConversionLog findFirstOrThrow
   */
  export type CurrencyConversionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyConversionLog to fetch.
     */
    where?: CurrencyConversionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyConversionLogs to fetch.
     */
    orderBy?: CurrencyConversionLogOrderByWithRelationInput | CurrencyConversionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrencyConversionLogs.
     */
    cursor?: CurrencyConversionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyConversionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyConversionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrencyConversionLogs.
     */
    distinct?: CurrencyConversionLogScalarFieldEnum | CurrencyConversionLogScalarFieldEnum[]
  }

  /**
   * CurrencyConversionLog findMany
   */
  export type CurrencyConversionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * Filter, which CurrencyConversionLogs to fetch.
     */
    where?: CurrencyConversionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrencyConversionLogs to fetch.
     */
    orderBy?: CurrencyConversionLogOrderByWithRelationInput | CurrencyConversionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurrencyConversionLogs.
     */
    cursor?: CurrencyConversionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrencyConversionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrencyConversionLogs.
     */
    skip?: number
    distinct?: CurrencyConversionLogScalarFieldEnum | CurrencyConversionLogScalarFieldEnum[]
  }

  /**
   * CurrencyConversionLog create
   */
  export type CurrencyConversionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CurrencyConversionLog.
     */
    data: XOR<CurrencyConversionLogCreateInput, CurrencyConversionLogUncheckedCreateInput>
  }

  /**
   * CurrencyConversionLog createMany
   */
  export type CurrencyConversionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurrencyConversionLogs.
     */
    data: CurrencyConversionLogCreateManyInput | CurrencyConversionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CurrencyConversionLog createManyAndReturn
   */
  export type CurrencyConversionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CurrencyConversionLogs.
     */
    data: CurrencyConversionLogCreateManyInput | CurrencyConversionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrencyConversionLog update
   */
  export type CurrencyConversionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CurrencyConversionLog.
     */
    data: XOR<CurrencyConversionLogUpdateInput, CurrencyConversionLogUncheckedUpdateInput>
    /**
     * Choose, which CurrencyConversionLog to update.
     */
    where: CurrencyConversionLogWhereUniqueInput
  }

  /**
   * CurrencyConversionLog updateMany
   */
  export type CurrencyConversionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurrencyConversionLogs.
     */
    data: XOR<CurrencyConversionLogUpdateManyMutationInput, CurrencyConversionLogUncheckedUpdateManyInput>
    /**
     * Filter which CurrencyConversionLogs to update
     */
    where?: CurrencyConversionLogWhereInput
  }

  /**
   * CurrencyConversionLog upsert
   */
  export type CurrencyConversionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CurrencyConversionLog to update in case it exists.
     */
    where: CurrencyConversionLogWhereUniqueInput
    /**
     * In case the CurrencyConversionLog found by the `where` argument doesn't exist, create a new CurrencyConversionLog with this data.
     */
    create: XOR<CurrencyConversionLogCreateInput, CurrencyConversionLogUncheckedCreateInput>
    /**
     * In case the CurrencyConversionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyConversionLogUpdateInput, CurrencyConversionLogUncheckedUpdateInput>
  }

  /**
   * CurrencyConversionLog delete
   */
  export type CurrencyConversionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
    /**
     * Filter which CurrencyConversionLog to delete.
     */
    where: CurrencyConversionLogWhereUniqueInput
  }

  /**
   * CurrencyConversionLog deleteMany
   */
  export type CurrencyConversionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrencyConversionLogs to delete
     */
    where?: CurrencyConversionLogWhereInput
  }

  /**
   * CurrencyConversionLog without action
   */
  export type CurrencyConversionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyConversionLog
     */
    select?: CurrencyConversionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyConversionLogInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    hostId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    hostId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    bookingId: number
    hostId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    bookingId?: true
    hostId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    bookingId?: true
    hostId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    bookingId?: true
    hostId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    bookingId: string
    hostId: string
    rating: number
    comment: string
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    hostId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    hostId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    bookingId?: boolean
    hostId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    host?: boolean | HostDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    host?: boolean | HostDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      host: Prisma.$HostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      hostId: string
      rating: number
      comment: string
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    host<T extends HostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HostDefaultArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly bookingId: FieldRef<"Review", 'String'>
    readonly hostId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Wishlist
   */

  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  export type WishlistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type WishlistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type WishlistCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    createdAt: number
    _all: number
  }


  export type WishlistMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    createdAt?: true
  }

  export type WishlistMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    createdAt?: true
  }

  export type WishlistCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    createdAt?: true
    _all?: true
  }

  export type WishlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlist to aggregate.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wishlists
    **/
    _count?: true | WishlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistMaxAggregateInputType
  }

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>
  }




  export type WishlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithAggregationInput | WishlistOrderByWithAggregationInput[]
    by: WishlistScalarFieldEnum[] | WishlistScalarFieldEnum
    having?: WishlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistCountAggregateInputType | true
    _min?: WishlistMinAggregateInputType
    _max?: WishlistMaxAggregateInputType
  }

  export type WishlistGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    createdAt: Date
    _count: WishlistCountAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
        }
      >
    >


  export type WishlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    createdAt?: boolean
  }

  export type WishlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type WishlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $WishlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wishlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceId: string
      createdAt: Date
    }, ExtArgs["result"]["wishlist"]>
    composites: {}
  }

  type WishlistGetPayload<S extends boolean | null | undefined | WishlistDefaultArgs> = $Result.GetResult<Prisma.$WishlistPayload, S>

  type WishlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WishlistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WishlistCountAggregateInputType | true
    }

  export interface WishlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wishlist'], meta: { name: 'Wishlist' } }
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {WishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistFindUniqueArgs>(args: SelectSubset<T, WishlistFindUniqueArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wishlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistFindFirstArgs>(args?: SelectSubset<T, WishlistFindFirstArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wishlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     * 
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistFindManyArgs>(args?: SelectSubset<T, WishlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wishlist.
     * @param {WishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     * 
     */
    create<T extends WishlistCreateArgs>(args: SelectSubset<T, WishlistCreateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wishlists.
     * @param {WishlistCreateManyArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistCreateManyArgs>(args?: SelectSubset<T, WishlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wishlists and returns the data saved in the database.
     * @param {WishlistCreateManyAndReturnArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wishlists and only return the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wishlist.
     * @param {WishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     * 
     */
    delete<T extends WishlistDeleteArgs>(args: SelectSubset<T, WishlistDeleteArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wishlist.
     * @param {WishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistUpdateArgs>(args: SelectSubset<T, WishlistUpdateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wishlists.
     * @param {WishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistDeleteManyArgs>(args?: SelectSubset<T, WishlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistUpdateManyArgs>(args: SelectSubset<T, WishlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wishlist.
     * @param {WishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
     */
    upsert<T extends WishlistUpsertArgs>(args: SelectSubset<T, WishlistUpsertArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
    **/
    count<T extends WishlistCountArgs>(
      args?: Subset<T, WishlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistAggregateArgs>(args: Subset<T, WishlistAggregateArgs>): Prisma.PrismaPromise<GetWishlistAggregateType<T>>

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wishlist model
   */
  readonly fields: WishlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wishlist model
   */ 
  interface WishlistFieldRefs {
    readonly id: FieldRef<"Wishlist", 'String'>
    readonly userId: FieldRef<"Wishlist", 'String'>
    readonly serviceId: FieldRef<"Wishlist", 'String'>
    readonly createdAt: FieldRef<"Wishlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wishlist findUnique
   */
  export type WishlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findUniqueOrThrow
   */
  export type WishlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findFirst
   */
  export type WishlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findFirstOrThrow
   */
  export type WishlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findMany
   */
  export type WishlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlists to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist create
   */
  export type WishlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Wishlist.
     */
    data: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
  }

  /**
   * Wishlist createMany
   */
  export type WishlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wishlist createManyAndReturn
   */
  export type WishlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wishlist update
   */
  export type WishlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Wishlist.
     */
    data: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
    /**
     * Choose, which Wishlist to update.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist updateMany
   */
  export type WishlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput
  }

  /**
   * Wishlist upsert
   */
  export type WishlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Wishlist to update in case it exists.
     */
    where: WishlistWhereUniqueInput
    /**
     * In case the Wishlist found by the `where` argument doesn't exist, create a new Wishlist with this data.
     */
    create: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
    /**
     * In case the Wishlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
  }

  /**
   * Wishlist delete
   */
  export type WishlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter which Wishlist to delete.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist deleteMany
   */
  export type WishlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlists to delete
     */
    where?: WishlistWhereInput
  }

  /**
   * Wishlist without action
   */
  export type WishlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    amount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    amount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    description: string | null
    discountType: string | null
    amount: number | null
    validFrom: Date | null
    validUntil: Date | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    description: string | null
    discountType: string | null
    amount: number | null
    validFrom: Date | null
    validUntil: Date | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    title: number
    description: number
    discountType: number
    amount: number
    validFrom: number
    validUntil: number
    usageLimit: number
    usedCount: number
    isActive: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    amount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeSumAggregateInputType = {
    amount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    description?: true
    discountType?: true
    amount?: true
    validFrom?: true
    validUntil?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    description?: true
    discountType?: true
    amount?: true
    validFrom?: true
    validUntil?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    description?: true
    discountType?: true
    amount?: true
    validFrom?: true
    validUntil?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    title: string
    description: string
    discountType: string
    amount: number
    validFrom: Date
    validUntil: Date
    usageLimit: number | null
    usedCount: number
    isActive: boolean
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    discountType?: boolean
    amount?: boolean
    validFrom?: boolean
    validUntil?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    bookings?: boolean | PromoCode$bookingsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    discountType?: boolean
    amount?: boolean
    validFrom?: boolean
    validUntil?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    discountType?: boolean
    amount?: boolean
    validFrom?: boolean
    validUntil?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
  }

  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PromoCode$bookingsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      description: string
      discountType: string
      amount: number
      validFrom: Date
      validUntil: Date
      usageLimit: number | null
      usedCount: number
      isActive: boolean
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends PromoCode$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */ 
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly title: FieldRef<"PromoCode", 'String'>
    readonly description: FieldRef<"PromoCode", 'String'>
    readonly discountType: FieldRef<"PromoCode", 'String'>
    readonly amount: FieldRef<"PromoCode", 'Int'>
    readonly validFrom: FieldRef<"PromoCode", 'DateTime'>
    readonly validUntil: FieldRef<"PromoCode", 'DateTime'>
    readonly usageLimit: FieldRef<"PromoCode", 'Int'>
    readonly usedCount: FieldRef<"PromoCode", 'Int'>
    readonly isActive: FieldRef<"PromoCode", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
  }

  /**
   * PromoCode.bookings
   */
  export type PromoCode$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model HostBadge
   */

  export type AggregateHostBadge = {
    _count: HostBadgeCountAggregateOutputType | null
    _min: HostBadgeMinAggregateOutputType | null
    _max: HostBadgeMaxAggregateOutputType | null
  }

  export type HostBadgeMinAggregateOutputType = {
    id: string | null
    hostId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type HostBadgeMaxAggregateOutputType = {
    id: string | null
    hostId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type HostBadgeCountAggregateOutputType = {
    id: number
    hostId: number
    type: number
    createdAt: number
    _all: number
  }


  export type HostBadgeMinAggregateInputType = {
    id?: true
    hostId?: true
    type?: true
    createdAt?: true
  }

  export type HostBadgeMaxAggregateInputType = {
    id?: true
    hostId?: true
    type?: true
    createdAt?: true
  }

  export type HostBadgeCountAggregateInputType = {
    id?: true
    hostId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type HostBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HostBadge to aggregate.
     */
    where?: HostBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostBadges to fetch.
     */
    orderBy?: HostBadgeOrderByWithRelationInput | HostBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HostBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HostBadges
    **/
    _count?: true | HostBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HostBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HostBadgeMaxAggregateInputType
  }

  export type GetHostBadgeAggregateType<T extends HostBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateHostBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHostBadge[P]>
      : GetScalarType<T[P], AggregateHostBadge[P]>
  }




  export type HostBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HostBadgeWhereInput
    orderBy?: HostBadgeOrderByWithAggregationInput | HostBadgeOrderByWithAggregationInput[]
    by: HostBadgeScalarFieldEnum[] | HostBadgeScalarFieldEnum
    having?: HostBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HostBadgeCountAggregateInputType | true
    _min?: HostBadgeMinAggregateInputType
    _max?: HostBadgeMaxAggregateInputType
  }

  export type HostBadgeGroupByOutputType = {
    id: string
    hostId: string
    type: string
    createdAt: Date
    _count: HostBadgeCountAggregateOutputType | null
    _min: HostBadgeMinAggregateOutputType | null
    _max: HostBadgeMaxAggregateOutputType | null
  }

  type GetHostBadgeGroupByPayload<T extends HostBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HostBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HostBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HostBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], HostBadgeGroupByOutputType[P]>
        }
      >
    >


  export type HostBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    type?: boolean
    createdAt?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hostBadge"]>

  export type HostBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    type?: boolean
    createdAt?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hostBadge"]>

  export type HostBadgeSelectScalar = {
    id?: boolean
    hostId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type HostBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }
  export type HostBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }

  export type $HostBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HostBadge"
    objects: {
      host: Prisma.$HostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hostId: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["hostBadge"]>
    composites: {}
  }

  type HostBadgeGetPayload<S extends boolean | null | undefined | HostBadgeDefaultArgs> = $Result.GetResult<Prisma.$HostBadgePayload, S>

  type HostBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HostBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HostBadgeCountAggregateInputType | true
    }

  export interface HostBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HostBadge'], meta: { name: 'HostBadge' } }
    /**
     * Find zero or one HostBadge that matches the filter.
     * @param {HostBadgeFindUniqueArgs} args - Arguments to find a HostBadge
     * @example
     * // Get one HostBadge
     * const hostBadge = await prisma.hostBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HostBadgeFindUniqueArgs>(args: SelectSubset<T, HostBadgeFindUniqueArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HostBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HostBadgeFindUniqueOrThrowArgs} args - Arguments to find a HostBadge
     * @example
     * // Get one HostBadge
     * const hostBadge = await prisma.hostBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HostBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, HostBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HostBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostBadgeFindFirstArgs} args - Arguments to find a HostBadge
     * @example
     * // Get one HostBadge
     * const hostBadge = await prisma.hostBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HostBadgeFindFirstArgs>(args?: SelectSubset<T, HostBadgeFindFirstArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HostBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostBadgeFindFirstOrThrowArgs} args - Arguments to find a HostBadge
     * @example
     * // Get one HostBadge
     * const hostBadge = await prisma.hostBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HostBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, HostBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HostBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HostBadges
     * const hostBadges = await prisma.hostBadge.findMany()
     * 
     * // Get first 10 HostBadges
     * const hostBadges = await prisma.hostBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hostBadgeWithIdOnly = await prisma.hostBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HostBadgeFindManyArgs>(args?: SelectSubset<T, HostBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HostBadge.
     * @param {HostBadgeCreateArgs} args - Arguments to create a HostBadge.
     * @example
     * // Create one HostBadge
     * const HostBadge = await prisma.hostBadge.create({
     *   data: {
     *     // ... data to create a HostBadge
     *   }
     * })
     * 
     */
    create<T extends HostBadgeCreateArgs>(args: SelectSubset<T, HostBadgeCreateArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HostBadges.
     * @param {HostBadgeCreateManyArgs} args - Arguments to create many HostBadges.
     * @example
     * // Create many HostBadges
     * const hostBadge = await prisma.hostBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HostBadgeCreateManyArgs>(args?: SelectSubset<T, HostBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HostBadges and returns the data saved in the database.
     * @param {HostBadgeCreateManyAndReturnArgs} args - Arguments to create many HostBadges.
     * @example
     * // Create many HostBadges
     * const hostBadge = await prisma.hostBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HostBadges and only return the `id`
     * const hostBadgeWithIdOnly = await prisma.hostBadge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HostBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, HostBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HostBadge.
     * @param {HostBadgeDeleteArgs} args - Arguments to delete one HostBadge.
     * @example
     * // Delete one HostBadge
     * const HostBadge = await prisma.hostBadge.delete({
     *   where: {
     *     // ... filter to delete one HostBadge
     *   }
     * })
     * 
     */
    delete<T extends HostBadgeDeleteArgs>(args: SelectSubset<T, HostBadgeDeleteArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HostBadge.
     * @param {HostBadgeUpdateArgs} args - Arguments to update one HostBadge.
     * @example
     * // Update one HostBadge
     * const hostBadge = await prisma.hostBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HostBadgeUpdateArgs>(args: SelectSubset<T, HostBadgeUpdateArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HostBadges.
     * @param {HostBadgeDeleteManyArgs} args - Arguments to filter HostBadges to delete.
     * @example
     * // Delete a few HostBadges
     * const { count } = await prisma.hostBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HostBadgeDeleteManyArgs>(args?: SelectSubset<T, HostBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HostBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HostBadges
     * const hostBadge = await prisma.hostBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HostBadgeUpdateManyArgs>(args: SelectSubset<T, HostBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HostBadge.
     * @param {HostBadgeUpsertArgs} args - Arguments to update or create a HostBadge.
     * @example
     * // Update or create a HostBadge
     * const hostBadge = await prisma.hostBadge.upsert({
     *   create: {
     *     // ... data to create a HostBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HostBadge we want to update
     *   }
     * })
     */
    upsert<T extends HostBadgeUpsertArgs>(args: SelectSubset<T, HostBadgeUpsertArgs<ExtArgs>>): Prisma__HostBadgeClient<$Result.GetResult<Prisma.$HostBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HostBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostBadgeCountArgs} args - Arguments to filter HostBadges to count.
     * @example
     * // Count the number of HostBadges
     * const count = await prisma.hostBadge.count({
     *   where: {
     *     // ... the filter for the HostBadges we want to count
     *   }
     * })
    **/
    count<T extends HostBadgeCountArgs>(
      args?: Subset<T, HostBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HostBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HostBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HostBadgeAggregateArgs>(args: Subset<T, HostBadgeAggregateArgs>): Prisma.PrismaPromise<GetHostBadgeAggregateType<T>>

    /**
     * Group by HostBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HostBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HostBadgeGroupByArgs['orderBy'] }
        : { orderBy?: HostBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HostBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHostBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HostBadge model
   */
  readonly fields: HostBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HostBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HostBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends HostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HostDefaultArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HostBadge model
   */ 
  interface HostBadgeFieldRefs {
    readonly id: FieldRef<"HostBadge", 'String'>
    readonly hostId: FieldRef<"HostBadge", 'String'>
    readonly type: FieldRef<"HostBadge", 'String'>
    readonly createdAt: FieldRef<"HostBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HostBadge findUnique
   */
  export type HostBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * Filter, which HostBadge to fetch.
     */
    where: HostBadgeWhereUniqueInput
  }

  /**
   * HostBadge findUniqueOrThrow
   */
  export type HostBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * Filter, which HostBadge to fetch.
     */
    where: HostBadgeWhereUniqueInput
  }

  /**
   * HostBadge findFirst
   */
  export type HostBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * Filter, which HostBadge to fetch.
     */
    where?: HostBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostBadges to fetch.
     */
    orderBy?: HostBadgeOrderByWithRelationInput | HostBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HostBadges.
     */
    cursor?: HostBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HostBadges.
     */
    distinct?: HostBadgeScalarFieldEnum | HostBadgeScalarFieldEnum[]
  }

  /**
   * HostBadge findFirstOrThrow
   */
  export type HostBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * Filter, which HostBadge to fetch.
     */
    where?: HostBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostBadges to fetch.
     */
    orderBy?: HostBadgeOrderByWithRelationInput | HostBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HostBadges.
     */
    cursor?: HostBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HostBadges.
     */
    distinct?: HostBadgeScalarFieldEnum | HostBadgeScalarFieldEnum[]
  }

  /**
   * HostBadge findMany
   */
  export type HostBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * Filter, which HostBadges to fetch.
     */
    where?: HostBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HostBadges to fetch.
     */
    orderBy?: HostBadgeOrderByWithRelationInput | HostBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HostBadges.
     */
    cursor?: HostBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HostBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HostBadges.
     */
    skip?: number
    distinct?: HostBadgeScalarFieldEnum | HostBadgeScalarFieldEnum[]
  }

  /**
   * HostBadge create
   */
  export type HostBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a HostBadge.
     */
    data: XOR<HostBadgeCreateInput, HostBadgeUncheckedCreateInput>
  }

  /**
   * HostBadge createMany
   */
  export type HostBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HostBadges.
     */
    data: HostBadgeCreateManyInput | HostBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HostBadge createManyAndReturn
   */
  export type HostBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HostBadges.
     */
    data: HostBadgeCreateManyInput | HostBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HostBadge update
   */
  export type HostBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a HostBadge.
     */
    data: XOR<HostBadgeUpdateInput, HostBadgeUncheckedUpdateInput>
    /**
     * Choose, which HostBadge to update.
     */
    where: HostBadgeWhereUniqueInput
  }

  /**
   * HostBadge updateMany
   */
  export type HostBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HostBadges.
     */
    data: XOR<HostBadgeUpdateManyMutationInput, HostBadgeUncheckedUpdateManyInput>
    /**
     * Filter which HostBadges to update
     */
    where?: HostBadgeWhereInput
  }

  /**
   * HostBadge upsert
   */
  export type HostBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the HostBadge to update in case it exists.
     */
    where: HostBadgeWhereUniqueInput
    /**
     * In case the HostBadge found by the `where` argument doesn't exist, create a new HostBadge with this data.
     */
    create: XOR<HostBadgeCreateInput, HostBadgeUncheckedCreateInput>
    /**
     * In case the HostBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HostBadgeUpdateInput, HostBadgeUncheckedUpdateInput>
  }

  /**
   * HostBadge delete
   */
  export type HostBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
    /**
     * Filter which HostBadge to delete.
     */
    where: HostBadgeWhereUniqueInput
  }

  /**
   * HostBadge deleteMany
   */
  export type HostBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HostBadges to delete
     */
    where?: HostBadgeWhereInput
  }

  /**
   * HostBadge without action
   */
  export type HostBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HostBadge
     */
    select?: HostBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostBadgeInclude<ExtArgs> | null
  }


  /**
   * Model BlockedDate
   */

  export type AggregateBlockedDate = {
    _count: BlockedDateCountAggregateOutputType | null
    _min: BlockedDateMinAggregateOutputType | null
    _max: BlockedDateMaxAggregateOutputType | null
  }

  export type BlockedDateMinAggregateOutputType = {
    id: string | null
    hostId: string | null
    date: Date | null
  }

  export type BlockedDateMaxAggregateOutputType = {
    id: string | null
    hostId: string | null
    date: Date | null
  }

  export type BlockedDateCountAggregateOutputType = {
    id: number
    hostId: number
    date: number
    _all: number
  }


  export type BlockedDateMinAggregateInputType = {
    id?: true
    hostId?: true
    date?: true
  }

  export type BlockedDateMaxAggregateInputType = {
    id?: true
    hostId?: true
    date?: true
  }

  export type BlockedDateCountAggregateInputType = {
    id?: true
    hostId?: true
    date?: true
    _all?: true
  }

  export type BlockedDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedDate to aggregate.
     */
    where?: BlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedDates to fetch.
     */
    orderBy?: BlockedDateOrderByWithRelationInput | BlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedDates
    **/
    _count?: true | BlockedDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedDateMaxAggregateInputType
  }

  export type GetBlockedDateAggregateType<T extends BlockedDateAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedDate[P]>
      : GetScalarType<T[P], AggregateBlockedDate[P]>
  }




  export type BlockedDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedDateWhereInput
    orderBy?: BlockedDateOrderByWithAggregationInput | BlockedDateOrderByWithAggregationInput[]
    by: BlockedDateScalarFieldEnum[] | BlockedDateScalarFieldEnum
    having?: BlockedDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedDateCountAggregateInputType | true
    _min?: BlockedDateMinAggregateInputType
    _max?: BlockedDateMaxAggregateInputType
  }

  export type BlockedDateGroupByOutputType = {
    id: string
    hostId: string
    date: Date
    _count: BlockedDateCountAggregateOutputType | null
    _min: BlockedDateMinAggregateOutputType | null
    _max: BlockedDateMaxAggregateOutputType | null
  }

  type GetBlockedDateGroupByPayload<T extends BlockedDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedDateGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedDateGroupByOutputType[P]>
        }
      >
    >


  export type BlockedDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    date?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedDate"]>

  export type BlockedDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hostId?: boolean
    date?: boolean
    host?: boolean | HostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedDate"]>

  export type BlockedDateSelectScalar = {
    id?: boolean
    hostId?: boolean
    date?: boolean
  }

  export type BlockedDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }
  export type BlockedDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | HostDefaultArgs<ExtArgs>
  }

  export type $BlockedDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedDate"
    objects: {
      host: Prisma.$HostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hostId: string
      date: Date
    }, ExtArgs["result"]["blockedDate"]>
    composites: {}
  }

  type BlockedDateGetPayload<S extends boolean | null | undefined | BlockedDateDefaultArgs> = $Result.GetResult<Prisma.$BlockedDatePayload, S>

  type BlockedDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockedDateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockedDateCountAggregateInputType | true
    }

  export interface BlockedDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedDate'], meta: { name: 'BlockedDate' } }
    /**
     * Find zero or one BlockedDate that matches the filter.
     * @param {BlockedDateFindUniqueArgs} args - Arguments to find a BlockedDate
     * @example
     * // Get one BlockedDate
     * const blockedDate = await prisma.blockedDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedDateFindUniqueArgs>(args: SelectSubset<T, BlockedDateFindUniqueArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockedDate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockedDateFindUniqueOrThrowArgs} args - Arguments to find a BlockedDate
     * @example
     * // Get one BlockedDate
     * const blockedDate = await prisma.blockedDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedDateFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockedDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedDateFindFirstArgs} args - Arguments to find a BlockedDate
     * @example
     * // Get one BlockedDate
     * const blockedDate = await prisma.blockedDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedDateFindFirstArgs>(args?: SelectSubset<T, BlockedDateFindFirstArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockedDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedDateFindFirstOrThrowArgs} args - Arguments to find a BlockedDate
     * @example
     * // Get one BlockedDate
     * const blockedDate = await prisma.blockedDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedDateFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockedDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedDates
     * const blockedDates = await prisma.blockedDate.findMany()
     * 
     * // Get first 10 BlockedDates
     * const blockedDates = await prisma.blockedDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedDateWithIdOnly = await prisma.blockedDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedDateFindManyArgs>(args?: SelectSubset<T, BlockedDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockedDate.
     * @param {BlockedDateCreateArgs} args - Arguments to create a BlockedDate.
     * @example
     * // Create one BlockedDate
     * const BlockedDate = await prisma.blockedDate.create({
     *   data: {
     *     // ... data to create a BlockedDate
     *   }
     * })
     * 
     */
    create<T extends BlockedDateCreateArgs>(args: SelectSubset<T, BlockedDateCreateArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockedDates.
     * @param {BlockedDateCreateManyArgs} args - Arguments to create many BlockedDates.
     * @example
     * // Create many BlockedDates
     * const blockedDate = await prisma.blockedDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedDateCreateManyArgs>(args?: SelectSubset<T, BlockedDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedDates and returns the data saved in the database.
     * @param {BlockedDateCreateManyAndReturnArgs} args - Arguments to create many BlockedDates.
     * @example
     * // Create many BlockedDates
     * const blockedDate = await prisma.blockedDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedDates and only return the `id`
     * const blockedDateWithIdOnly = await prisma.blockedDate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedDateCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockedDate.
     * @param {BlockedDateDeleteArgs} args - Arguments to delete one BlockedDate.
     * @example
     * // Delete one BlockedDate
     * const BlockedDate = await prisma.blockedDate.delete({
     *   where: {
     *     // ... filter to delete one BlockedDate
     *   }
     * })
     * 
     */
    delete<T extends BlockedDateDeleteArgs>(args: SelectSubset<T, BlockedDateDeleteArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockedDate.
     * @param {BlockedDateUpdateArgs} args - Arguments to update one BlockedDate.
     * @example
     * // Update one BlockedDate
     * const blockedDate = await prisma.blockedDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedDateUpdateArgs>(args: SelectSubset<T, BlockedDateUpdateArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockedDates.
     * @param {BlockedDateDeleteManyArgs} args - Arguments to filter BlockedDates to delete.
     * @example
     * // Delete a few BlockedDates
     * const { count } = await prisma.blockedDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedDateDeleteManyArgs>(args?: SelectSubset<T, BlockedDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedDates
     * const blockedDate = await prisma.blockedDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedDateUpdateManyArgs>(args: SelectSubset<T, BlockedDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockedDate.
     * @param {BlockedDateUpsertArgs} args - Arguments to update or create a BlockedDate.
     * @example
     * // Update or create a BlockedDate
     * const blockedDate = await prisma.blockedDate.upsert({
     *   create: {
     *     // ... data to create a BlockedDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedDate we want to update
     *   }
     * })
     */
    upsert<T extends BlockedDateUpsertArgs>(args: SelectSubset<T, BlockedDateUpsertArgs<ExtArgs>>): Prisma__BlockedDateClient<$Result.GetResult<Prisma.$BlockedDatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockedDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedDateCountArgs} args - Arguments to filter BlockedDates to count.
     * @example
     * // Count the number of BlockedDates
     * const count = await prisma.blockedDate.count({
     *   where: {
     *     // ... the filter for the BlockedDates we want to count
     *   }
     * })
    **/
    count<T extends BlockedDateCountArgs>(
      args?: Subset<T, BlockedDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedDateAggregateArgs>(args: Subset<T, BlockedDateAggregateArgs>): Prisma.PrismaPromise<GetBlockedDateAggregateType<T>>

    /**
     * Group by BlockedDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedDateGroupByArgs['orderBy'] }
        : { orderBy?: BlockedDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedDate model
   */
  readonly fields: BlockedDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends HostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HostDefaultArgs<ExtArgs>>): Prisma__HostClient<$Result.GetResult<Prisma.$HostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedDate model
   */ 
  interface BlockedDateFieldRefs {
    readonly id: FieldRef<"BlockedDate", 'String'>
    readonly hostId: FieldRef<"BlockedDate", 'String'>
    readonly date: FieldRef<"BlockedDate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedDate findUnique
   */
  export type BlockedDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which BlockedDate to fetch.
     */
    where: BlockedDateWhereUniqueInput
  }

  /**
   * BlockedDate findUniqueOrThrow
   */
  export type BlockedDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which BlockedDate to fetch.
     */
    where: BlockedDateWhereUniqueInput
  }

  /**
   * BlockedDate findFirst
   */
  export type BlockedDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which BlockedDate to fetch.
     */
    where?: BlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedDates to fetch.
     */
    orderBy?: BlockedDateOrderByWithRelationInput | BlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedDates.
     */
    cursor?: BlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedDates.
     */
    distinct?: BlockedDateScalarFieldEnum | BlockedDateScalarFieldEnum[]
  }

  /**
   * BlockedDate findFirstOrThrow
   */
  export type BlockedDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which BlockedDate to fetch.
     */
    where?: BlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedDates to fetch.
     */
    orderBy?: BlockedDateOrderByWithRelationInput | BlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedDates.
     */
    cursor?: BlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedDates.
     */
    distinct?: BlockedDateScalarFieldEnum | BlockedDateScalarFieldEnum[]
  }

  /**
   * BlockedDate findMany
   */
  export type BlockedDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which BlockedDates to fetch.
     */
    where?: BlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedDates to fetch.
     */
    orderBy?: BlockedDateOrderByWithRelationInput | BlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedDates.
     */
    cursor?: BlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedDates.
     */
    skip?: number
    distinct?: BlockedDateScalarFieldEnum | BlockedDateScalarFieldEnum[]
  }

  /**
   * BlockedDate create
   */
  export type BlockedDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockedDate.
     */
    data: XOR<BlockedDateCreateInput, BlockedDateUncheckedCreateInput>
  }

  /**
   * BlockedDate createMany
   */
  export type BlockedDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedDates.
     */
    data: BlockedDateCreateManyInput | BlockedDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedDate createManyAndReturn
   */
  export type BlockedDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockedDates.
     */
    data: BlockedDateCreateManyInput | BlockedDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedDate update
   */
  export type BlockedDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockedDate.
     */
    data: XOR<BlockedDateUpdateInput, BlockedDateUncheckedUpdateInput>
    /**
     * Choose, which BlockedDate to update.
     */
    where: BlockedDateWhereUniqueInput
  }

  /**
   * BlockedDate updateMany
   */
  export type BlockedDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedDates.
     */
    data: XOR<BlockedDateUpdateManyMutationInput, BlockedDateUncheckedUpdateManyInput>
    /**
     * Filter which BlockedDates to update
     */
    where?: BlockedDateWhereInput
  }

  /**
   * BlockedDate upsert
   */
  export type BlockedDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockedDate to update in case it exists.
     */
    where: BlockedDateWhereUniqueInput
    /**
     * In case the BlockedDate found by the `where` argument doesn't exist, create a new BlockedDate with this data.
     */
    create: XOR<BlockedDateCreateInput, BlockedDateUncheckedCreateInput>
    /**
     * In case the BlockedDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedDateUpdateInput, BlockedDateUncheckedUpdateInput>
  }

  /**
   * BlockedDate delete
   */
  export type BlockedDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
    /**
     * Filter which BlockedDate to delete.
     */
    where: BlockedDateWhereUniqueInput
  }

  /**
   * BlockedDate deleteMany
   */
  export type BlockedDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedDates to delete
     */
    where?: BlockedDateWhereInput
  }

  /**
   * BlockedDate without action
   */
  export type BlockedDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedDate
     */
    select?: BlockedDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedDateInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    usedAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    usedAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    refereeId: number
    usedAt: number
    _all: number
  }


  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    usedAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    usedAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    usedAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerId: string
    refereeId: string
    usedAt: Date | null
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    usedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    usedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    usedAt?: boolean
  }

  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      refereeId: string
      usedAt: Date | null
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly refereeId: FieldRef<"Referral", 'String'>
    readonly usedAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model Story
   */

  export type AggregateStory = {
    _count: StoryCountAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  export type StoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.StoryType | null
    title: string | null
    content: string | null
    imageUrl: string | null
    location: string | null
    postedAt: Date | null
    createdAt: Date | null
  }

  export type StoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.StoryType | null
    title: string | null
    content: string | null
    imageUrl: string | null
    location: string | null
    postedAt: Date | null
    createdAt: Date | null
  }

  export type StoryCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    content: number
    imageUrl: number
    location: number
    postedAt: number
    createdAt: number
    _all: number
  }


  export type StoryMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    imageUrl?: true
    location?: true
    postedAt?: true
    createdAt?: true
  }

  export type StoryMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    imageUrl?: true
    location?: true
    postedAt?: true
    createdAt?: true
  }

  export type StoryCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    imageUrl?: true
    location?: true
    postedAt?: true
    createdAt?: true
    _all?: true
  }

  export type StoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Story to aggregate.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stories
    **/
    _count?: true | StoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryMaxAggregateInputType
  }

  export type GetStoryAggregateType<T extends StoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStory[P]>
      : GetScalarType<T[P], AggregateStory[P]>
  }




  export type StoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithAggregationInput | StoryOrderByWithAggregationInput[]
    by: StoryScalarFieldEnum[] | StoryScalarFieldEnum
    having?: StoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryCountAggregateInputType | true
    _min?: StoryMinAggregateInputType
    _max?: StoryMaxAggregateInputType
  }

  export type StoryGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date
    createdAt: Date
    _count: StoryCountAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  type GetStoryGroupByPayload<T extends StoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryGroupByOutputType[P]>
            : GetScalarType<T[P], StoryGroupByOutputType[P]>
        }
      >
    >


  export type StorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    location?: boolean
    postedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    likes?: boolean | Story$likesArgs<ExtArgs>
    comments?: boolean | Story$commentsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    location?: boolean
    postedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    location?: boolean
    postedAt?: boolean
    createdAt?: boolean
  }

  export type StoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    likes?: boolean | Story$likesArgs<ExtArgs>
    comments?: boolean | Story$commentsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Story"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      likes: Prisma.$StoryLikePayload<ExtArgs>[]
      comments: Prisma.$StoryCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.StoryType
      title: string
      content: string
      imageUrl: string
      location: string
      postedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["story"]>
    composites: {}
  }

  type StoryGetPayload<S extends boolean | null | undefined | StoryDefaultArgs> = $Result.GetResult<Prisma.$StoryPayload, S>

  type StoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoryCountAggregateInputType | true
    }

  export interface StoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Story'], meta: { name: 'Story' } }
    /**
     * Find zero or one Story that matches the filter.
     * @param {StoryFindUniqueArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryFindUniqueArgs>(args: SelectSubset<T, StoryFindUniqueArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Story that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoryFindUniqueOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryFindFirstArgs>(args?: SelectSubset<T, StoryFindFirstArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stories
     * const stories = await prisma.story.findMany()
     * 
     * // Get first 10 Stories
     * const stories = await prisma.story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyWithIdOnly = await prisma.story.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryFindManyArgs>(args?: SelectSubset<T, StoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Story.
     * @param {StoryCreateArgs} args - Arguments to create a Story.
     * @example
     * // Create one Story
     * const Story = await prisma.story.create({
     *   data: {
     *     // ... data to create a Story
     *   }
     * })
     * 
     */
    create<T extends StoryCreateArgs>(args: SelectSubset<T, StoryCreateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stories.
     * @param {StoryCreateManyArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryCreateManyArgs>(args?: SelectSubset<T, StoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stories and returns the data saved in the database.
     * @param {StoryCreateManyAndReturnArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Story.
     * @param {StoryDeleteArgs} args - Arguments to delete one Story.
     * @example
     * // Delete one Story
     * const Story = await prisma.story.delete({
     *   where: {
     *     // ... filter to delete one Story
     *   }
     * })
     * 
     */
    delete<T extends StoryDeleteArgs>(args: SelectSubset<T, StoryDeleteArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Story.
     * @param {StoryUpdateArgs} args - Arguments to update one Story.
     * @example
     * // Update one Story
     * const story = await prisma.story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryUpdateArgs>(args: SelectSubset<T, StoryUpdateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stories.
     * @param {StoryDeleteManyArgs} args - Arguments to filter Stories to delete.
     * @example
     * // Delete a few Stories
     * const { count } = await prisma.story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryDeleteManyArgs>(args?: SelectSubset<T, StoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryUpdateManyArgs>(args: SelectSubset<T, StoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Story.
     * @param {StoryUpsertArgs} args - Arguments to update or create a Story.
     * @example
     * // Update or create a Story
     * const story = await prisma.story.upsert({
     *   create: {
     *     // ... data to create a Story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Story we want to update
     *   }
     * })
     */
    upsert<T extends StoryUpsertArgs>(args: SelectSubset<T, StoryUpsertArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCountArgs} args - Arguments to filter Stories to count.
     * @example
     * // Count the number of Stories
     * const count = await prisma.story.count({
     *   where: {
     *     // ... the filter for the Stories we want to count
     *   }
     * })
    **/
    count<T extends StoryCountArgs>(
      args?: Subset<T, StoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryAggregateArgs>(args: Subset<T, StoryAggregateArgs>): Prisma.PrismaPromise<GetStoryAggregateType<T>>

    /**
     * Group by Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryGroupByArgs['orderBy'] }
        : { orderBy?: StoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Story model
   */
  readonly fields: StoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    likes<T extends Story$likesArgs<ExtArgs> = {}>(args?: Subset<T, Story$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Story$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Story$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Story model
   */ 
  interface StoryFieldRefs {
    readonly id: FieldRef<"Story", 'String'>
    readonly userId: FieldRef<"Story", 'String'>
    readonly type: FieldRef<"Story", 'StoryType'>
    readonly title: FieldRef<"Story", 'String'>
    readonly content: FieldRef<"Story", 'String'>
    readonly imageUrl: FieldRef<"Story", 'String'>
    readonly location: FieldRef<"Story", 'String'>
    readonly postedAt: FieldRef<"Story", 'DateTime'>
    readonly createdAt: FieldRef<"Story", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Story findUnique
   */
  export type StoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findUniqueOrThrow
   */
  export type StoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findFirst
   */
  export type StoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findFirstOrThrow
   */
  export type StoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findMany
   */
  export type StoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Stories to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story create
   */
  export type StoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Story.
     */
    data: XOR<StoryCreateInput, StoryUncheckedCreateInput>
  }

  /**
   * Story createMany
   */
  export type StoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Story createManyAndReturn
   */
  export type StoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story update
   */
  export type StoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Story.
     */
    data: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
    /**
     * Choose, which Story to update.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story updateMany
   */
  export type StoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
  }

  /**
   * Story upsert
   */
  export type StoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Story to update in case it exists.
     */
    where: StoryWhereUniqueInput
    /**
     * In case the Story found by the `where` argument doesn't exist, create a new Story with this data.
     */
    create: XOR<StoryCreateInput, StoryUncheckedCreateInput>
    /**
     * In case the Story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
  }

  /**
   * Story delete
   */
  export type StoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter which Story to delete.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story deleteMany
   */
  export type StoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stories to delete
     */
    where?: StoryWhereInput
  }

  /**
   * Story.likes
   */
  export type Story$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    where?: StoryLikeWhereInput
    orderBy?: StoryLikeOrderByWithRelationInput | StoryLikeOrderByWithRelationInput[]
    cursor?: StoryLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryLikeScalarFieldEnum | StoryLikeScalarFieldEnum[]
  }

  /**
   * Story.comments
   */
  export type Story$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    where?: StoryCommentWhereInput
    orderBy?: StoryCommentOrderByWithRelationInput | StoryCommentOrderByWithRelationInput[]
    cursor?: StoryCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryCommentScalarFieldEnum | StoryCommentScalarFieldEnum[]
  }

  /**
   * Story without action
   */
  export type StoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
  }


  /**
   * Model StoryLike
   */

  export type AggregateStoryLike = {
    _count: StoryLikeCountAggregateOutputType | null
    _min: StoryLikeMinAggregateOutputType | null
    _max: StoryLikeMaxAggregateOutputType | null
  }

  export type StoryLikeMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type StoryLikeMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type StoryLikeCountAggregateOutputType = {
    id: number
    storyId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type StoryLikeMinAggregateInputType = {
    id?: true
    storyId?: true
    userId?: true
    createdAt?: true
  }

  export type StoryLikeMaxAggregateInputType = {
    id?: true
    storyId?: true
    userId?: true
    createdAt?: true
  }

  export type StoryLikeCountAggregateInputType = {
    id?: true
    storyId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type StoryLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryLike to aggregate.
     */
    where?: StoryLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryLikes to fetch.
     */
    orderBy?: StoryLikeOrderByWithRelationInput | StoryLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryLikes
    **/
    _count?: true | StoryLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryLikeMaxAggregateInputType
  }

  export type GetStoryLikeAggregateType<T extends StoryLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryLike[P]>
      : GetScalarType<T[P], AggregateStoryLike[P]>
  }




  export type StoryLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryLikeWhereInput
    orderBy?: StoryLikeOrderByWithAggregationInput | StoryLikeOrderByWithAggregationInput[]
    by: StoryLikeScalarFieldEnum[] | StoryLikeScalarFieldEnum
    having?: StoryLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryLikeCountAggregateInputType | true
    _min?: StoryLikeMinAggregateInputType
    _max?: StoryLikeMaxAggregateInputType
  }

  export type StoryLikeGroupByOutputType = {
    id: string
    storyId: string
    userId: string
    createdAt: Date
    _count: StoryLikeCountAggregateOutputType | null
    _min: StoryLikeMinAggregateOutputType | null
    _max: StoryLikeMaxAggregateOutputType | null
  }

  type GetStoryLikeGroupByPayload<T extends StoryLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryLikeGroupByOutputType[P]>
            : GetScalarType<T[P], StoryLikeGroupByOutputType[P]>
        }
      >
    >


  export type StoryLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    userId?: boolean
    createdAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyLike"]>

  export type StoryLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    userId?: boolean
    createdAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyLike"]>

  export type StoryLikeSelectScalar = {
    id?: boolean
    storyId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type StoryLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoryLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StoryLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryLike"
    objects: {
      story: Prisma.$StoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["storyLike"]>
    composites: {}
  }

  type StoryLikeGetPayload<S extends boolean | null | undefined | StoryLikeDefaultArgs> = $Result.GetResult<Prisma.$StoryLikePayload, S>

  type StoryLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoryLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoryLikeCountAggregateInputType | true
    }

  export interface StoryLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryLike'], meta: { name: 'StoryLike' } }
    /**
     * Find zero or one StoryLike that matches the filter.
     * @param {StoryLikeFindUniqueArgs} args - Arguments to find a StoryLike
     * @example
     * // Get one StoryLike
     * const storyLike = await prisma.storyLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryLikeFindUniqueArgs>(args: SelectSubset<T, StoryLikeFindUniqueArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoryLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoryLikeFindUniqueOrThrowArgs} args - Arguments to find a StoryLike
     * @example
     * // Get one StoryLike
     * const storyLike = await prisma.storyLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoryLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryLikeFindFirstArgs} args - Arguments to find a StoryLike
     * @example
     * // Get one StoryLike
     * const storyLike = await prisma.storyLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryLikeFindFirstArgs>(args?: SelectSubset<T, StoryLikeFindFirstArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoryLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryLikeFindFirstOrThrowArgs} args - Arguments to find a StoryLike
     * @example
     * // Get one StoryLike
     * const storyLike = await prisma.storyLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoryLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryLikes
     * const storyLikes = await prisma.storyLike.findMany()
     * 
     * // Get first 10 StoryLikes
     * const storyLikes = await prisma.storyLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyLikeWithIdOnly = await prisma.storyLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryLikeFindManyArgs>(args?: SelectSubset<T, StoryLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoryLike.
     * @param {StoryLikeCreateArgs} args - Arguments to create a StoryLike.
     * @example
     * // Create one StoryLike
     * const StoryLike = await prisma.storyLike.create({
     *   data: {
     *     // ... data to create a StoryLike
     *   }
     * })
     * 
     */
    create<T extends StoryLikeCreateArgs>(args: SelectSubset<T, StoryLikeCreateArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoryLikes.
     * @param {StoryLikeCreateManyArgs} args - Arguments to create many StoryLikes.
     * @example
     * // Create many StoryLikes
     * const storyLike = await prisma.storyLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryLikeCreateManyArgs>(args?: SelectSubset<T, StoryLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryLikes and returns the data saved in the database.
     * @param {StoryLikeCreateManyAndReturnArgs} args - Arguments to create many StoryLikes.
     * @example
     * // Create many StoryLikes
     * const storyLike = await prisma.storyLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryLikes and only return the `id`
     * const storyLikeWithIdOnly = await prisma.storyLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoryLike.
     * @param {StoryLikeDeleteArgs} args - Arguments to delete one StoryLike.
     * @example
     * // Delete one StoryLike
     * const StoryLike = await prisma.storyLike.delete({
     *   where: {
     *     // ... filter to delete one StoryLike
     *   }
     * })
     * 
     */
    delete<T extends StoryLikeDeleteArgs>(args: SelectSubset<T, StoryLikeDeleteArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoryLike.
     * @param {StoryLikeUpdateArgs} args - Arguments to update one StoryLike.
     * @example
     * // Update one StoryLike
     * const storyLike = await prisma.storyLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryLikeUpdateArgs>(args: SelectSubset<T, StoryLikeUpdateArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoryLikes.
     * @param {StoryLikeDeleteManyArgs} args - Arguments to filter StoryLikes to delete.
     * @example
     * // Delete a few StoryLikes
     * const { count } = await prisma.storyLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryLikeDeleteManyArgs>(args?: SelectSubset<T, StoryLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryLikes
     * const storyLike = await prisma.storyLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryLikeUpdateManyArgs>(args: SelectSubset<T, StoryLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoryLike.
     * @param {StoryLikeUpsertArgs} args - Arguments to update or create a StoryLike.
     * @example
     * // Update or create a StoryLike
     * const storyLike = await prisma.storyLike.upsert({
     *   create: {
     *     // ... data to create a StoryLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryLike we want to update
     *   }
     * })
     */
    upsert<T extends StoryLikeUpsertArgs>(args: SelectSubset<T, StoryLikeUpsertArgs<ExtArgs>>): Prisma__StoryLikeClient<$Result.GetResult<Prisma.$StoryLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoryLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryLikeCountArgs} args - Arguments to filter StoryLikes to count.
     * @example
     * // Count the number of StoryLikes
     * const count = await prisma.storyLike.count({
     *   where: {
     *     // ... the filter for the StoryLikes we want to count
     *   }
     * })
    **/
    count<T extends StoryLikeCountArgs>(
      args?: Subset<T, StoryLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryLikeAggregateArgs>(args: Subset<T, StoryLikeAggregateArgs>): Prisma.PrismaPromise<GetStoryLikeAggregateType<T>>

    /**
     * Group by StoryLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryLikeGroupByArgs['orderBy'] }
        : { orderBy?: StoryLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryLike model
   */
  readonly fields: StoryLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends StoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryDefaultArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryLike model
   */ 
  interface StoryLikeFieldRefs {
    readonly id: FieldRef<"StoryLike", 'String'>
    readonly storyId: FieldRef<"StoryLike", 'String'>
    readonly userId: FieldRef<"StoryLike", 'String'>
    readonly createdAt: FieldRef<"StoryLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryLike findUnique
   */
  export type StoryLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * Filter, which StoryLike to fetch.
     */
    where: StoryLikeWhereUniqueInput
  }

  /**
   * StoryLike findUniqueOrThrow
   */
  export type StoryLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * Filter, which StoryLike to fetch.
     */
    where: StoryLikeWhereUniqueInput
  }

  /**
   * StoryLike findFirst
   */
  export type StoryLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * Filter, which StoryLike to fetch.
     */
    where?: StoryLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryLikes to fetch.
     */
    orderBy?: StoryLikeOrderByWithRelationInput | StoryLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryLikes.
     */
    cursor?: StoryLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryLikes.
     */
    distinct?: StoryLikeScalarFieldEnum | StoryLikeScalarFieldEnum[]
  }

  /**
   * StoryLike findFirstOrThrow
   */
  export type StoryLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * Filter, which StoryLike to fetch.
     */
    where?: StoryLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryLikes to fetch.
     */
    orderBy?: StoryLikeOrderByWithRelationInput | StoryLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryLikes.
     */
    cursor?: StoryLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryLikes.
     */
    distinct?: StoryLikeScalarFieldEnum | StoryLikeScalarFieldEnum[]
  }

  /**
   * StoryLike findMany
   */
  export type StoryLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * Filter, which StoryLikes to fetch.
     */
    where?: StoryLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryLikes to fetch.
     */
    orderBy?: StoryLikeOrderByWithRelationInput | StoryLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryLikes.
     */
    cursor?: StoryLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryLikes.
     */
    skip?: number
    distinct?: StoryLikeScalarFieldEnum | StoryLikeScalarFieldEnum[]
  }

  /**
   * StoryLike create
   */
  export type StoryLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryLike.
     */
    data: XOR<StoryLikeCreateInput, StoryLikeUncheckedCreateInput>
  }

  /**
   * StoryLike createMany
   */
  export type StoryLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryLikes.
     */
    data: StoryLikeCreateManyInput | StoryLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryLike createManyAndReturn
   */
  export type StoryLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoryLikes.
     */
    data: StoryLikeCreateManyInput | StoryLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryLike update
   */
  export type StoryLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryLike.
     */
    data: XOR<StoryLikeUpdateInput, StoryLikeUncheckedUpdateInput>
    /**
     * Choose, which StoryLike to update.
     */
    where: StoryLikeWhereUniqueInput
  }

  /**
   * StoryLike updateMany
   */
  export type StoryLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryLikes.
     */
    data: XOR<StoryLikeUpdateManyMutationInput, StoryLikeUncheckedUpdateManyInput>
    /**
     * Filter which StoryLikes to update
     */
    where?: StoryLikeWhereInput
  }

  /**
   * StoryLike upsert
   */
  export type StoryLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryLike to update in case it exists.
     */
    where: StoryLikeWhereUniqueInput
    /**
     * In case the StoryLike found by the `where` argument doesn't exist, create a new StoryLike with this data.
     */
    create: XOR<StoryLikeCreateInput, StoryLikeUncheckedCreateInput>
    /**
     * In case the StoryLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryLikeUpdateInput, StoryLikeUncheckedUpdateInput>
  }

  /**
   * StoryLike delete
   */
  export type StoryLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
    /**
     * Filter which StoryLike to delete.
     */
    where: StoryLikeWhereUniqueInput
  }

  /**
   * StoryLike deleteMany
   */
  export type StoryLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryLikes to delete
     */
    where?: StoryLikeWhereInput
  }

  /**
   * StoryLike without action
   */
  export type StoryLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryLike
     */
    select?: StoryLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryLikeInclude<ExtArgs> | null
  }


  /**
   * Model StoryComment
   */

  export type AggregateStoryComment = {
    _count: StoryCommentCountAggregateOutputType | null
    _min: StoryCommentMinAggregateOutputType | null
    _max: StoryCommentMaxAggregateOutputType | null
  }

  export type StoryCommentMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type StoryCommentMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type StoryCommentCountAggregateOutputType = {
    id: number
    storyId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type StoryCommentMinAggregateInputType = {
    id?: true
    storyId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type StoryCommentMaxAggregateInputType = {
    id?: true
    storyId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type StoryCommentCountAggregateInputType = {
    id?: true
    storyId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type StoryCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryComment to aggregate.
     */
    where?: StoryCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryComments to fetch.
     */
    orderBy?: StoryCommentOrderByWithRelationInput | StoryCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryComments
    **/
    _count?: true | StoryCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryCommentMaxAggregateInputType
  }

  export type GetStoryCommentAggregateType<T extends StoryCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryComment[P]>
      : GetScalarType<T[P], AggregateStoryComment[P]>
  }




  export type StoryCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryCommentWhereInput
    orderBy?: StoryCommentOrderByWithAggregationInput | StoryCommentOrderByWithAggregationInput[]
    by: StoryCommentScalarFieldEnum[] | StoryCommentScalarFieldEnum
    having?: StoryCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryCommentCountAggregateInputType | true
    _min?: StoryCommentMinAggregateInputType
    _max?: StoryCommentMaxAggregateInputType
  }

  export type StoryCommentGroupByOutputType = {
    id: string
    storyId: string
    userId: string
    content: string
    createdAt: Date
    _count: StoryCommentCountAggregateOutputType | null
    _min: StoryCommentMinAggregateOutputType | null
    _max: StoryCommentMaxAggregateOutputType | null
  }

  type GetStoryCommentGroupByPayload<T extends StoryCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryCommentGroupByOutputType[P]>
            : GetScalarType<T[P], StoryCommentGroupByOutputType[P]>
        }
      >
    >


  export type StoryCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyComment"]>

  export type StoryCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyComment"]>

  export type StoryCommentSelectScalar = {
    id?: boolean
    storyId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type StoryCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoryCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StoryCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryComment"
    objects: {
      story: Prisma.$StoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      userId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["storyComment"]>
    composites: {}
  }

  type StoryCommentGetPayload<S extends boolean | null | undefined | StoryCommentDefaultArgs> = $Result.GetResult<Prisma.$StoryCommentPayload, S>

  type StoryCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoryCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoryCommentCountAggregateInputType | true
    }

  export interface StoryCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryComment'], meta: { name: 'StoryComment' } }
    /**
     * Find zero or one StoryComment that matches the filter.
     * @param {StoryCommentFindUniqueArgs} args - Arguments to find a StoryComment
     * @example
     * // Get one StoryComment
     * const storyComment = await prisma.storyComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryCommentFindUniqueArgs>(args: SelectSubset<T, StoryCommentFindUniqueArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoryComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoryCommentFindUniqueOrThrowArgs} args - Arguments to find a StoryComment
     * @example
     * // Get one StoryComment
     * const storyComment = await prisma.storyComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoryComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCommentFindFirstArgs} args - Arguments to find a StoryComment
     * @example
     * // Get one StoryComment
     * const storyComment = await prisma.storyComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryCommentFindFirstArgs>(args?: SelectSubset<T, StoryCommentFindFirstArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoryComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCommentFindFirstOrThrowArgs} args - Arguments to find a StoryComment
     * @example
     * // Get one StoryComment
     * const storyComment = await prisma.storyComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoryComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryComments
     * const storyComments = await prisma.storyComment.findMany()
     * 
     * // Get first 10 StoryComments
     * const storyComments = await prisma.storyComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyCommentWithIdOnly = await prisma.storyComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryCommentFindManyArgs>(args?: SelectSubset<T, StoryCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoryComment.
     * @param {StoryCommentCreateArgs} args - Arguments to create a StoryComment.
     * @example
     * // Create one StoryComment
     * const StoryComment = await prisma.storyComment.create({
     *   data: {
     *     // ... data to create a StoryComment
     *   }
     * })
     * 
     */
    create<T extends StoryCommentCreateArgs>(args: SelectSubset<T, StoryCommentCreateArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoryComments.
     * @param {StoryCommentCreateManyArgs} args - Arguments to create many StoryComments.
     * @example
     * // Create many StoryComments
     * const storyComment = await prisma.storyComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryCommentCreateManyArgs>(args?: SelectSubset<T, StoryCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryComments and returns the data saved in the database.
     * @param {StoryCommentCreateManyAndReturnArgs} args - Arguments to create many StoryComments.
     * @example
     * // Create many StoryComments
     * const storyComment = await prisma.storyComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryComments and only return the `id`
     * const storyCommentWithIdOnly = await prisma.storyComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoryComment.
     * @param {StoryCommentDeleteArgs} args - Arguments to delete one StoryComment.
     * @example
     * // Delete one StoryComment
     * const StoryComment = await prisma.storyComment.delete({
     *   where: {
     *     // ... filter to delete one StoryComment
     *   }
     * })
     * 
     */
    delete<T extends StoryCommentDeleteArgs>(args: SelectSubset<T, StoryCommentDeleteArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoryComment.
     * @param {StoryCommentUpdateArgs} args - Arguments to update one StoryComment.
     * @example
     * // Update one StoryComment
     * const storyComment = await prisma.storyComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryCommentUpdateArgs>(args: SelectSubset<T, StoryCommentUpdateArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoryComments.
     * @param {StoryCommentDeleteManyArgs} args - Arguments to filter StoryComments to delete.
     * @example
     * // Delete a few StoryComments
     * const { count } = await prisma.storyComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryCommentDeleteManyArgs>(args?: SelectSubset<T, StoryCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryComments
     * const storyComment = await prisma.storyComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryCommentUpdateManyArgs>(args: SelectSubset<T, StoryCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoryComment.
     * @param {StoryCommentUpsertArgs} args - Arguments to update or create a StoryComment.
     * @example
     * // Update or create a StoryComment
     * const storyComment = await prisma.storyComment.upsert({
     *   create: {
     *     // ... data to create a StoryComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryComment we want to update
     *   }
     * })
     */
    upsert<T extends StoryCommentUpsertArgs>(args: SelectSubset<T, StoryCommentUpsertArgs<ExtArgs>>): Prisma__StoryCommentClient<$Result.GetResult<Prisma.$StoryCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoryComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCommentCountArgs} args - Arguments to filter StoryComments to count.
     * @example
     * // Count the number of StoryComments
     * const count = await prisma.storyComment.count({
     *   where: {
     *     // ... the filter for the StoryComments we want to count
     *   }
     * })
    **/
    count<T extends StoryCommentCountArgs>(
      args?: Subset<T, StoryCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryCommentAggregateArgs>(args: Subset<T, StoryCommentAggregateArgs>): Prisma.PrismaPromise<GetStoryCommentAggregateType<T>>

    /**
     * Group by StoryComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryCommentGroupByArgs['orderBy'] }
        : { orderBy?: StoryCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryComment model
   */
  readonly fields: StoryCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends StoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryDefaultArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryComment model
   */ 
  interface StoryCommentFieldRefs {
    readonly id: FieldRef<"StoryComment", 'String'>
    readonly storyId: FieldRef<"StoryComment", 'String'>
    readonly userId: FieldRef<"StoryComment", 'String'>
    readonly content: FieldRef<"StoryComment", 'String'>
    readonly createdAt: FieldRef<"StoryComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryComment findUnique
   */
  export type StoryCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * Filter, which StoryComment to fetch.
     */
    where: StoryCommentWhereUniqueInput
  }

  /**
   * StoryComment findUniqueOrThrow
   */
  export type StoryCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * Filter, which StoryComment to fetch.
     */
    where: StoryCommentWhereUniqueInput
  }

  /**
   * StoryComment findFirst
   */
  export type StoryCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * Filter, which StoryComment to fetch.
     */
    where?: StoryCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryComments to fetch.
     */
    orderBy?: StoryCommentOrderByWithRelationInput | StoryCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryComments.
     */
    cursor?: StoryCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryComments.
     */
    distinct?: StoryCommentScalarFieldEnum | StoryCommentScalarFieldEnum[]
  }

  /**
   * StoryComment findFirstOrThrow
   */
  export type StoryCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * Filter, which StoryComment to fetch.
     */
    where?: StoryCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryComments to fetch.
     */
    orderBy?: StoryCommentOrderByWithRelationInput | StoryCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryComments.
     */
    cursor?: StoryCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryComments.
     */
    distinct?: StoryCommentScalarFieldEnum | StoryCommentScalarFieldEnum[]
  }

  /**
   * StoryComment findMany
   */
  export type StoryCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * Filter, which StoryComments to fetch.
     */
    where?: StoryCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryComments to fetch.
     */
    orderBy?: StoryCommentOrderByWithRelationInput | StoryCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryComments.
     */
    cursor?: StoryCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryComments.
     */
    skip?: number
    distinct?: StoryCommentScalarFieldEnum | StoryCommentScalarFieldEnum[]
  }

  /**
   * StoryComment create
   */
  export type StoryCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryComment.
     */
    data: XOR<StoryCommentCreateInput, StoryCommentUncheckedCreateInput>
  }

  /**
   * StoryComment createMany
   */
  export type StoryCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryComments.
     */
    data: StoryCommentCreateManyInput | StoryCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryComment createManyAndReturn
   */
  export type StoryCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoryComments.
     */
    data: StoryCommentCreateManyInput | StoryCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryComment update
   */
  export type StoryCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryComment.
     */
    data: XOR<StoryCommentUpdateInput, StoryCommentUncheckedUpdateInput>
    /**
     * Choose, which StoryComment to update.
     */
    where: StoryCommentWhereUniqueInput
  }

  /**
   * StoryComment updateMany
   */
  export type StoryCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryComments.
     */
    data: XOR<StoryCommentUpdateManyMutationInput, StoryCommentUncheckedUpdateManyInput>
    /**
     * Filter which StoryComments to update
     */
    where?: StoryCommentWhereInput
  }

  /**
   * StoryComment upsert
   */
  export type StoryCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryComment to update in case it exists.
     */
    where: StoryCommentWhereUniqueInput
    /**
     * In case the StoryComment found by the `where` argument doesn't exist, create a new StoryComment with this data.
     */
    create: XOR<StoryCommentCreateInput, StoryCommentUncheckedCreateInput>
    /**
     * In case the StoryComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryCommentUpdateInput, StoryCommentUncheckedUpdateInput>
  }

  /**
   * StoryComment delete
   */
  export type StoryCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
    /**
     * Filter which StoryComment to delete.
     */
    where: StoryCommentWhereUniqueInput
  }

  /**
   * StoryComment deleteMany
   */
  export type StoryCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryComments to delete
     */
    where?: StoryCommentWhereInput
  }

  /**
   * StoryComment without action
   */
  export type StoryCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryComment
     */
    select?: StoryCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryCommentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TopDestinationScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    order: 'order',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type TopDestinationScalarFieldEnum = (typeof TopDestinationScalarFieldEnum)[keyof typeof TopDestinationScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countryId: 'countryId',
    lat: 'lat',
    lng: 'lng'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    avatarUrl: 'avatarUrl',
    phone: 'phone',
    bio: 'bio',
    role: 'role',
    countryId: 'countryId',
    cityId: 'cityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referredById: 'referredById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const HostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    countryId: 'countryId',
    cityId: 'cityId',
    lat: 'lat',
    lng: 'lng',
    isGuide: 'isGuide',
    isPhotographer: 'isPhotographer',
    profileVideo: 'profileVideo',
    isVerified: 'isVerified',
    createdAt: 'createdAt'
  };

  export type HostScalarFieldEnum = (typeof HostScalarFieldEnum)[keyof typeof HostScalarFieldEnum]


  export const HostLanguageScalarFieldEnum: {
    id: 'id',
    hostId: 'hostId',
    languageId: 'languageId'
  };

  export type HostLanguageScalarFieldEnum = (typeof HostLanguageScalarFieldEnum)[keyof typeof HostLanguageScalarFieldEnum]


  export const PhotographerSkillScalarFieldEnum: {
    id: 'id',
    hostId: 'hostId',
    skill: 'skill'
  };

  export type PhotographerSkillScalarFieldEnum = (typeof PhotographerSkillScalarFieldEnum)[keyof typeof PhotographerSkillScalarFieldEnum]


  export const PhotographerGearScalarFieldEnum: {
    id: 'id',
    hostId: 'hostId',
    gearType: 'gearType',
    name: 'name'
  };

  export type PhotographerGearScalarFieldEnum = (typeof PhotographerGearScalarFieldEnum)[keyof typeof PhotographerGearScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    hostId: 'hostId',
    title: 'title',
    description: 'description',
    type: 'type',
    price: 'price',
    currency: 'currency',
    duration: 'duration',
    tags: 'tags',
    images: 'images',
    createdAt: 'createdAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ItineraryScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    step: 'step',
    title: 'title',
    description: 'description',
    duration: 'duration'
  };

  export type ItineraryScalarFieldEnum = (typeof ItineraryScalarFieldEnum)[keyof typeof ItineraryScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    date: 'date',
    adults: 'adults',
    children: 'children',
    contactMethod: 'contactMethod',
    contactDetail: 'contactDetail',
    meetingPoint: 'meetingPoint',
    totalPrice: 'totalPrice',
    currency: 'currency',
    status: 'status',
    promoCodeId: 'promoCodeId',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const CurrencyConversionLogScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    sourceCurrency: 'sourceCurrency',
    targetCurrency: 'targetCurrency',
    rate: 'rate',
    convertedAmount: 'convertedAmount',
    createdAt: 'createdAt'
  };

  export type CurrencyConversionLogScalarFieldEnum = (typeof CurrencyConversionLogScalarFieldEnum)[keyof typeof CurrencyConversionLogScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    hostId: 'hostId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const WishlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    createdAt: 'createdAt'
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    description: 'description',
    discountType: 'discountType',
    amount: 'amount',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    usageLimit: 'usageLimit',
    usedCount: 'usedCount',
    isActive: 'isActive'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const HostBadgeScalarFieldEnum: {
    id: 'id',
    hostId: 'hostId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type HostBadgeScalarFieldEnum = (typeof HostBadgeScalarFieldEnum)[keyof typeof HostBadgeScalarFieldEnum]


  export const BlockedDateScalarFieldEnum: {
    id: 'id',
    hostId: 'hostId',
    date: 'date'
  };

  export type BlockedDateScalarFieldEnum = (typeof BlockedDateScalarFieldEnum)[keyof typeof BlockedDateScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    usedAt: 'usedAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const StoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    content: 'content',
    imageUrl: 'imageUrl',
    location: 'location',
    postedAt: 'postedAt',
    createdAt: 'createdAt'
  };

  export type StoryScalarFieldEnum = (typeof StoryScalarFieldEnum)[keyof typeof StoryScalarFieldEnum]


  export const StoryLikeScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type StoryLikeScalarFieldEnum = (typeof StoryLikeScalarFieldEnum)[keyof typeof StoryLikeScalarFieldEnum]


  export const StoryCommentScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type StoryCommentScalarFieldEnum = (typeof StoryCommentScalarFieldEnum)[keyof typeof StoryCommentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'CurrencyCode'
   */
  export type EnumCurrencyCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyCode'>
    


  /**
   * Reference to a field of type 'CurrencyCode[]'
   */
  export type ListEnumCurrencyCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyCode[]'>
    


  /**
   * Reference to a field of type 'ContactMethod'
   */
  export type EnumContactMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactMethod'>
    


  /**
   * Reference to a field of type 'ContactMethod[]'
   */
  export type ListEnumContactMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactMethod[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'StoryType'
   */
  export type EnumStoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryType'>
    


  /**
   * Reference to a field of type 'StoryType[]'
   */
  export type ListEnumStoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryType[]'>
    
  /**
   * Deep Input Types
   */


  export type TopDestinationWhereInput = {
    AND?: TopDestinationWhereInput | TopDestinationWhereInput[]
    OR?: TopDestinationWhereInput[]
    NOT?: TopDestinationWhereInput | TopDestinationWhereInput[]
    id?: StringFilter<"TopDestination"> | string
    cityId?: StringFilter<"TopDestination"> | string
    order?: IntFilter<"TopDestination"> | number
    imageUrl?: StringNullableFilter<"TopDestination"> | string | null
    createdAt?: DateTimeFilter<"TopDestination"> | Date | string
    city?: XOR<CityRelationFilter, CityWhereInput>
  }

  export type TopDestinationOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type TopDestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cityId?: string
    AND?: TopDestinationWhereInput | TopDestinationWhereInput[]
    OR?: TopDestinationWhereInput[]
    NOT?: TopDestinationWhereInput | TopDestinationWhereInput[]
    order?: IntFilter<"TopDestination"> | number
    imageUrl?: StringNullableFilter<"TopDestination"> | string | null
    createdAt?: DateTimeFilter<"TopDestination"> | Date | string
    city?: XOR<CityRelationFilter, CityWhereInput>
  }, "id" | "cityId">

  export type TopDestinationOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TopDestinationCountOrderByAggregateInput
    _avg?: TopDestinationAvgOrderByAggregateInput
    _max?: TopDestinationMaxOrderByAggregateInput
    _min?: TopDestinationMinOrderByAggregateInput
    _sum?: TopDestinationSumOrderByAggregateInput
  }

  export type TopDestinationScalarWhereWithAggregatesInput = {
    AND?: TopDestinationScalarWhereWithAggregatesInput | TopDestinationScalarWhereWithAggregatesInput[]
    OR?: TopDestinationScalarWhereWithAggregatesInput[]
    NOT?: TopDestinationScalarWhereWithAggregatesInput | TopDestinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TopDestination"> | string
    cityId?: StringWithAggregatesFilter<"TopDestination"> | string
    order?: IntWithAggregatesFilter<"TopDestination"> | number
    imageUrl?: StringNullableWithAggregatesFilter<"TopDestination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TopDestination"> | Date | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    code?: StringFilter<"Country"> | string
    cities?: CityListRelationFilter
    users?: UserListRelationFilter
    hosts?: HostListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    hosts?: HostOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    cities?: CityListRelationFilter
    users?: UserListRelationFilter
    hosts?: HostListRelationFilter
  }, "id" | "name" | "code">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    code?: StringWithAggregatesFilter<"Country"> | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    countryId?: StringFilter<"City"> | string
    lat?: FloatFilter<"City"> | number
    lng?: FloatFilter<"City"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    users?: UserListRelationFilter
    hosts?: HostListRelationFilter
    topDestination?: XOR<TopDestinationNullableRelationFilter, TopDestinationWhereInput> | null
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    country?: CountryOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    hosts?: HostOrderByRelationAggregateInput
    topDestination?: TopDestinationOrderByWithRelationInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_countryId?: CityNameCountryIdCompoundUniqueInput
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    countryId?: StringFilter<"City"> | string
    lat?: FloatFilter<"City"> | number
    lng?: FloatFilter<"City"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    users?: UserListRelationFilter
    hosts?: HostListRelationFilter
    topDestination?: XOR<TopDestinationNullableRelationFilter, TopDestinationWhereInput> | null
  }, "id" | "name_countryId">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    countryId?: StringWithAggregatesFilter<"City"> | string
    lat?: FloatWithAggregatesFilter<"City"> | number
    lng?: FloatWithAggregatesFilter<"City"> | number
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    hosts?: HostLanguageListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    hosts?: HostLanguageOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    hosts?: HostLanguageListRelationFilter
  }, "id" | "name">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    countryId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: StringNullableFilter<"User"> | string | null
    country?: XOR<CountryNullableRelationFilter, CountryWhereInput> | null
    city?: XOR<CityNullableRelationFilter, CityWhereInput> | null
    host?: XOR<HostNullableRelationFilter, HostWhereInput> | null
    bookings?: BookingListRelationFilter
    wishlist?: WishlistListRelationFilter
    stories?: StoryListRelationFilter
    storyLikes?: StoryLikeListRelationFilter
    storyComments?: StoryCommentListRelationFilter
    referrals?: ReferralListRelationFilter
    referredBy?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrder
    countryId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    host?: HostOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    wishlist?: WishlistOrderByRelationAggregateInput
    stories?: StoryOrderByRelationAggregateInput
    storyLikes?: StoryLikeOrderByRelationAggregateInput
    storyComments?: StoryCommentOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    referredBy?: ReferralOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    countryId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: StringNullableFilter<"User"> | string | null
    country?: XOR<CountryNullableRelationFilter, CountryWhereInput> | null
    city?: XOR<CityNullableRelationFilter, CityWhereInput> | null
    host?: XOR<HostNullableRelationFilter, HostWhereInput> | null
    bookings?: BookingListRelationFilter
    wishlist?: WishlistListRelationFilter
    stories?: StoryListRelationFilter
    storyLikes?: StoryLikeListRelationFilter
    storyComments?: StoryCommentListRelationFilter
    referrals?: ReferralListRelationFilter
    referredBy?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrder
    countryId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    countryId?: StringNullableWithAggregatesFilter<"User"> | string | null
    cityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    referredById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type HostWhereInput = {
    AND?: HostWhereInput | HostWhereInput[]
    OR?: HostWhereInput[]
    NOT?: HostWhereInput | HostWhereInput[]
    id?: StringFilter<"Host"> | string
    userId?: StringFilter<"Host"> | string
    countryId?: StringFilter<"Host"> | string
    cityId?: StringFilter<"Host"> | string
    lat?: FloatFilter<"Host"> | number
    lng?: FloatFilter<"Host"> | number
    isGuide?: BoolFilter<"Host"> | boolean
    isPhotographer?: BoolFilter<"Host"> | boolean
    profileVideo?: StringNullableFilter<"Host"> | string | null
    isVerified?: BoolFilter<"Host"> | boolean
    createdAt?: DateTimeFilter<"Host"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    languages?: HostLanguageListRelationFilter
    services?: ServiceListRelationFilter
    blockedDates?: BlockedDateListRelationFilter
    badges?: HostBadgeListRelationFilter
    reviews?: ReviewListRelationFilter
    photographerSkills?: PhotographerSkillListRelationFilter
    photographerGears?: PhotographerGearListRelationFilter
  }

  export type HostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isGuide?: SortOrder
    isPhotographer?: SortOrder
    profileVideo?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    languages?: HostLanguageOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    blockedDates?: BlockedDateOrderByRelationAggregateInput
    badges?: HostBadgeOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    photographerSkills?: PhotographerSkillOrderByRelationAggregateInput
    photographerGears?: PhotographerGearOrderByRelationAggregateInput
  }

  export type HostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: HostWhereInput | HostWhereInput[]
    OR?: HostWhereInput[]
    NOT?: HostWhereInput | HostWhereInput[]
    countryId?: StringFilter<"Host"> | string
    cityId?: StringFilter<"Host"> | string
    lat?: FloatFilter<"Host"> | number
    lng?: FloatFilter<"Host"> | number
    isGuide?: BoolFilter<"Host"> | boolean
    isPhotographer?: BoolFilter<"Host"> | boolean
    profileVideo?: StringNullableFilter<"Host"> | string | null
    isVerified?: BoolFilter<"Host"> | boolean
    createdAt?: DateTimeFilter<"Host"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    languages?: HostLanguageListRelationFilter
    services?: ServiceListRelationFilter
    blockedDates?: BlockedDateListRelationFilter
    badges?: HostBadgeListRelationFilter
    reviews?: ReviewListRelationFilter
    photographerSkills?: PhotographerSkillListRelationFilter
    photographerGears?: PhotographerGearListRelationFilter
  }, "id" | "userId">

  export type HostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isGuide?: SortOrder
    isPhotographer?: SortOrder
    profileVideo?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    _count?: HostCountOrderByAggregateInput
    _avg?: HostAvgOrderByAggregateInput
    _max?: HostMaxOrderByAggregateInput
    _min?: HostMinOrderByAggregateInput
    _sum?: HostSumOrderByAggregateInput
  }

  export type HostScalarWhereWithAggregatesInput = {
    AND?: HostScalarWhereWithAggregatesInput | HostScalarWhereWithAggregatesInput[]
    OR?: HostScalarWhereWithAggregatesInput[]
    NOT?: HostScalarWhereWithAggregatesInput | HostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Host"> | string
    userId?: StringWithAggregatesFilter<"Host"> | string
    countryId?: StringWithAggregatesFilter<"Host"> | string
    cityId?: StringWithAggregatesFilter<"Host"> | string
    lat?: FloatWithAggregatesFilter<"Host"> | number
    lng?: FloatWithAggregatesFilter<"Host"> | number
    isGuide?: BoolWithAggregatesFilter<"Host"> | boolean
    isPhotographer?: BoolWithAggregatesFilter<"Host"> | boolean
    profileVideo?: StringNullableWithAggregatesFilter<"Host"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Host"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Host"> | Date | string
  }

  export type HostLanguageWhereInput = {
    AND?: HostLanguageWhereInput | HostLanguageWhereInput[]
    OR?: HostLanguageWhereInput[]
    NOT?: HostLanguageWhereInput | HostLanguageWhereInput[]
    id?: StringFilter<"HostLanguage"> | string
    hostId?: StringFilter<"HostLanguage"> | string
    languageId?: StringFilter<"HostLanguage"> | string
    host?: XOR<HostRelationFilter, HostWhereInput>
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }

  export type HostLanguageOrderByWithRelationInput = {
    id?: SortOrder
    hostId?: SortOrder
    languageId?: SortOrder
    host?: HostOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
  }

  export type HostLanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hostId_languageId?: HostLanguageHostIdLanguageIdCompoundUniqueInput
    AND?: HostLanguageWhereInput | HostLanguageWhereInput[]
    OR?: HostLanguageWhereInput[]
    NOT?: HostLanguageWhereInput | HostLanguageWhereInput[]
    hostId?: StringFilter<"HostLanguage"> | string
    languageId?: StringFilter<"HostLanguage"> | string
    host?: XOR<HostRelationFilter, HostWhereInput>
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }, "id" | "hostId_languageId">

  export type HostLanguageOrderByWithAggregationInput = {
    id?: SortOrder
    hostId?: SortOrder
    languageId?: SortOrder
    _count?: HostLanguageCountOrderByAggregateInput
    _max?: HostLanguageMaxOrderByAggregateInput
    _min?: HostLanguageMinOrderByAggregateInput
  }

  export type HostLanguageScalarWhereWithAggregatesInput = {
    AND?: HostLanguageScalarWhereWithAggregatesInput | HostLanguageScalarWhereWithAggregatesInput[]
    OR?: HostLanguageScalarWhereWithAggregatesInput[]
    NOT?: HostLanguageScalarWhereWithAggregatesInput | HostLanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HostLanguage"> | string
    hostId?: StringWithAggregatesFilter<"HostLanguage"> | string
    languageId?: StringWithAggregatesFilter<"HostLanguage"> | string
  }

  export type PhotographerSkillWhereInput = {
    AND?: PhotographerSkillWhereInput | PhotographerSkillWhereInput[]
    OR?: PhotographerSkillWhereInput[]
    NOT?: PhotographerSkillWhereInput | PhotographerSkillWhereInput[]
    id?: StringFilter<"PhotographerSkill"> | string
    hostId?: StringFilter<"PhotographerSkill"> | string
    skill?: StringFilter<"PhotographerSkill"> | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }

  export type PhotographerSkillOrderByWithRelationInput = {
    id?: SortOrder
    hostId?: SortOrder
    skill?: SortOrder
    host?: HostOrderByWithRelationInput
  }

  export type PhotographerSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhotographerSkillWhereInput | PhotographerSkillWhereInput[]
    OR?: PhotographerSkillWhereInput[]
    NOT?: PhotographerSkillWhereInput | PhotographerSkillWhereInput[]
    hostId?: StringFilter<"PhotographerSkill"> | string
    skill?: StringFilter<"PhotographerSkill"> | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }, "id">

  export type PhotographerSkillOrderByWithAggregationInput = {
    id?: SortOrder
    hostId?: SortOrder
    skill?: SortOrder
    _count?: PhotographerSkillCountOrderByAggregateInput
    _max?: PhotographerSkillMaxOrderByAggregateInput
    _min?: PhotographerSkillMinOrderByAggregateInput
  }

  export type PhotographerSkillScalarWhereWithAggregatesInput = {
    AND?: PhotographerSkillScalarWhereWithAggregatesInput | PhotographerSkillScalarWhereWithAggregatesInput[]
    OR?: PhotographerSkillScalarWhereWithAggregatesInput[]
    NOT?: PhotographerSkillScalarWhereWithAggregatesInput | PhotographerSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhotographerSkill"> | string
    hostId?: StringWithAggregatesFilter<"PhotographerSkill"> | string
    skill?: StringWithAggregatesFilter<"PhotographerSkill"> | string
  }

  export type PhotographerGearWhereInput = {
    AND?: PhotographerGearWhereInput | PhotographerGearWhereInput[]
    OR?: PhotographerGearWhereInput[]
    NOT?: PhotographerGearWhereInput | PhotographerGearWhereInput[]
    id?: StringFilter<"PhotographerGear"> | string
    hostId?: StringFilter<"PhotographerGear"> | string
    gearType?: StringFilter<"PhotographerGear"> | string
    name?: StringFilter<"PhotographerGear"> | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }

  export type PhotographerGearOrderByWithRelationInput = {
    id?: SortOrder
    hostId?: SortOrder
    gearType?: SortOrder
    name?: SortOrder
    host?: HostOrderByWithRelationInput
  }

  export type PhotographerGearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhotographerGearWhereInput | PhotographerGearWhereInput[]
    OR?: PhotographerGearWhereInput[]
    NOT?: PhotographerGearWhereInput | PhotographerGearWhereInput[]
    hostId?: StringFilter<"PhotographerGear"> | string
    gearType?: StringFilter<"PhotographerGear"> | string
    name?: StringFilter<"PhotographerGear"> | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }, "id">

  export type PhotographerGearOrderByWithAggregationInput = {
    id?: SortOrder
    hostId?: SortOrder
    gearType?: SortOrder
    name?: SortOrder
    _count?: PhotographerGearCountOrderByAggregateInput
    _max?: PhotographerGearMaxOrderByAggregateInput
    _min?: PhotographerGearMinOrderByAggregateInput
  }

  export type PhotographerGearScalarWhereWithAggregatesInput = {
    AND?: PhotographerGearScalarWhereWithAggregatesInput | PhotographerGearScalarWhereWithAggregatesInput[]
    OR?: PhotographerGearScalarWhereWithAggregatesInput[]
    NOT?: PhotographerGearScalarWhereWithAggregatesInput | PhotographerGearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhotographerGear"> | string
    hostId?: StringWithAggregatesFilter<"PhotographerGear"> | string
    gearType?: StringWithAggregatesFilter<"PhotographerGear"> | string
    name?: StringWithAggregatesFilter<"PhotographerGear"> | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    hostId?: StringFilter<"Service"> | string
    title?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    price?: IntFilter<"Service"> | number
    currency?: EnumCurrencyCodeFilter<"Service"> | $Enums.CurrencyCode
    duration?: IntFilter<"Service"> | number
    tags?: StringNullableListFilter<"Service">
    images?: StringNullableListFilter<"Service">
    createdAt?: DateTimeFilter<"Service"> | Date | string
    host?: XOR<HostRelationFilter, HostWhereInput>
    bookings?: BookingListRelationFilter
    wishlist?: WishlistListRelationFilter
    itineraries?: ItineraryListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    hostId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    host?: HostOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    wishlist?: WishlistOrderByRelationAggregateInput
    itineraries?: ItineraryOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    hostId?: StringFilter<"Service"> | string
    title?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    price?: IntFilter<"Service"> | number
    currency?: EnumCurrencyCodeFilter<"Service"> | $Enums.CurrencyCode
    duration?: IntFilter<"Service"> | number
    tags?: StringNullableListFilter<"Service">
    images?: StringNullableListFilter<"Service">
    createdAt?: DateTimeFilter<"Service"> | Date | string
    host?: XOR<HostRelationFilter, HostWhereInput>
    bookings?: BookingListRelationFilter
    wishlist?: WishlistListRelationFilter
    itineraries?: ItineraryListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    hostId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    hostId?: StringWithAggregatesFilter<"Service"> | string
    title?: StringWithAggregatesFilter<"Service"> | string
    description?: StringWithAggregatesFilter<"Service"> | string
    type?: EnumServiceTypeWithAggregatesFilter<"Service"> | $Enums.ServiceType
    price?: IntWithAggregatesFilter<"Service"> | number
    currency?: EnumCurrencyCodeWithAggregatesFilter<"Service"> | $Enums.CurrencyCode
    duration?: IntWithAggregatesFilter<"Service"> | number
    tags?: StringNullableListFilter<"Service">
    images?: StringNullableListFilter<"Service">
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ItineraryWhereInput = {
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    id?: StringFilter<"Itinerary"> | string
    serviceId?: StringFilter<"Itinerary"> | string
    step?: IntFilter<"Itinerary"> | number
    title?: StringFilter<"Itinerary"> | string
    description?: StringFilter<"Itinerary"> | string
    duration?: IntFilter<"Itinerary"> | number
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type ItineraryOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ItineraryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    serviceId?: StringFilter<"Itinerary"> | string
    step?: IntFilter<"Itinerary"> | number
    title?: StringFilter<"Itinerary"> | string
    description?: StringFilter<"Itinerary"> | string
    duration?: IntFilter<"Itinerary"> | number
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id">

  export type ItineraryOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    _count?: ItineraryCountOrderByAggregateInput
    _avg?: ItineraryAvgOrderByAggregateInput
    _max?: ItineraryMaxOrderByAggregateInput
    _min?: ItineraryMinOrderByAggregateInput
    _sum?: ItinerarySumOrderByAggregateInput
  }

  export type ItineraryScalarWhereWithAggregatesInput = {
    AND?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    OR?: ItineraryScalarWhereWithAggregatesInput[]
    NOT?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Itinerary"> | string
    serviceId?: StringWithAggregatesFilter<"Itinerary"> | string
    step?: IntWithAggregatesFilter<"Itinerary"> | number
    title?: StringWithAggregatesFilter<"Itinerary"> | string
    description?: StringWithAggregatesFilter<"Itinerary"> | string
    duration?: IntWithAggregatesFilter<"Itinerary"> | number
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    serviceId?: StringFilter<"Booking"> | string
    date?: DateTimeFilter<"Booking"> | Date | string
    adults?: IntFilter<"Booking"> | number
    children?: IntFilter<"Booking"> | number
    contactMethod?: EnumContactMethodFilter<"Booking"> | $Enums.ContactMethod
    contactDetail?: StringFilter<"Booking"> | string
    meetingPoint?: StringNullableFilter<"Booking"> | string | null
    totalPrice?: IntFilter<"Booking"> | number
    currency?: EnumCurrencyCodeFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    promoCodeId?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    promoCode?: XOR<PromoCodeNullableRelationFilter, PromoCodeWhereInput> | null
    review?: XOR<ReviewNullableRelationFilter, ReviewWhereInput> | null
    currencyConversionLog?: XOR<CurrencyConversionLogNullableRelationFilter, CurrencyConversionLogWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    date?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    contactMethod?: SortOrder
    contactDetail?: SortOrder
    meetingPoint?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    promoCode?: PromoCodeOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
    currencyConversionLog?: CurrencyConversionLogOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: StringFilter<"Booking"> | string
    serviceId?: StringFilter<"Booking"> | string
    date?: DateTimeFilter<"Booking"> | Date | string
    adults?: IntFilter<"Booking"> | number
    children?: IntFilter<"Booking"> | number
    contactMethod?: EnumContactMethodFilter<"Booking"> | $Enums.ContactMethod
    contactDetail?: StringFilter<"Booking"> | string
    meetingPoint?: StringNullableFilter<"Booking"> | string | null
    totalPrice?: IntFilter<"Booking"> | number
    currency?: EnumCurrencyCodeFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    promoCodeId?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    promoCode?: XOR<PromoCodeNullableRelationFilter, PromoCodeWhereInput> | null
    review?: XOR<ReviewNullableRelationFilter, ReviewWhereInput> | null
    currencyConversionLog?: XOR<CurrencyConversionLogNullableRelationFilter, CurrencyConversionLogWhereInput> | null
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    date?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    contactMethod?: SortOrder
    contactDetail?: SortOrder
    meetingPoint?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    serviceId?: StringWithAggregatesFilter<"Booking"> | string
    date?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    adults?: IntWithAggregatesFilter<"Booking"> | number
    children?: IntWithAggregatesFilter<"Booking"> | number
    contactMethod?: EnumContactMethodWithAggregatesFilter<"Booking"> | $Enums.ContactMethod
    contactDetail?: StringWithAggregatesFilter<"Booking"> | string
    meetingPoint?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    totalPrice?: IntWithAggregatesFilter<"Booking"> | number
    currency?: EnumCurrencyCodeWithAggregatesFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    promoCodeId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type CurrencyConversionLogWhereInput = {
    AND?: CurrencyConversionLogWhereInput | CurrencyConversionLogWhereInput[]
    OR?: CurrencyConversionLogWhereInput[]
    NOT?: CurrencyConversionLogWhereInput | CurrencyConversionLogWhereInput[]
    id?: StringFilter<"CurrencyConversionLog"> | string
    bookingId?: StringFilter<"CurrencyConversionLog"> | string
    sourceCurrency?: EnumCurrencyCodeFilter<"CurrencyConversionLog"> | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFilter<"CurrencyConversionLog"> | $Enums.CurrencyCode
    rate?: FloatFilter<"CurrencyConversionLog"> | number
    convertedAmount?: IntFilter<"CurrencyConversionLog"> | number
    createdAt?: DateTimeFilter<"CurrencyConversionLog"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type CurrencyConversionLogOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    sourceCurrency?: SortOrder
    targetCurrency?: SortOrder
    rate?: SortOrder
    convertedAmount?: SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type CurrencyConversionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    AND?: CurrencyConversionLogWhereInput | CurrencyConversionLogWhereInput[]
    OR?: CurrencyConversionLogWhereInput[]
    NOT?: CurrencyConversionLogWhereInput | CurrencyConversionLogWhereInput[]
    sourceCurrency?: EnumCurrencyCodeFilter<"CurrencyConversionLog"> | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFilter<"CurrencyConversionLog"> | $Enums.CurrencyCode
    rate?: FloatFilter<"CurrencyConversionLog"> | number
    convertedAmount?: IntFilter<"CurrencyConversionLog"> | number
    createdAt?: DateTimeFilter<"CurrencyConversionLog"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id" | "bookingId">

  export type CurrencyConversionLogOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    sourceCurrency?: SortOrder
    targetCurrency?: SortOrder
    rate?: SortOrder
    convertedAmount?: SortOrder
    createdAt?: SortOrder
    _count?: CurrencyConversionLogCountOrderByAggregateInput
    _avg?: CurrencyConversionLogAvgOrderByAggregateInput
    _max?: CurrencyConversionLogMaxOrderByAggregateInput
    _min?: CurrencyConversionLogMinOrderByAggregateInput
    _sum?: CurrencyConversionLogSumOrderByAggregateInput
  }

  export type CurrencyConversionLogScalarWhereWithAggregatesInput = {
    AND?: CurrencyConversionLogScalarWhereWithAggregatesInput | CurrencyConversionLogScalarWhereWithAggregatesInput[]
    OR?: CurrencyConversionLogScalarWhereWithAggregatesInput[]
    NOT?: CurrencyConversionLogScalarWhereWithAggregatesInput | CurrencyConversionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CurrencyConversionLog"> | string
    bookingId?: StringWithAggregatesFilter<"CurrencyConversionLog"> | string
    sourceCurrency?: EnumCurrencyCodeWithAggregatesFilter<"CurrencyConversionLog"> | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeWithAggregatesFilter<"CurrencyConversionLog"> | $Enums.CurrencyCode
    rate?: FloatWithAggregatesFilter<"CurrencyConversionLog"> | number
    convertedAmount?: IntWithAggregatesFilter<"CurrencyConversionLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CurrencyConversionLog"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    bookingId?: StringFilter<"Review"> | string
    hostId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    host?: XOR<HostRelationFilter, HostWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hostId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    host?: HostOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    hostId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    host?: XOR<HostRelationFilter, HostWhereInput>
  }, "id" | "bookingId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hostId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    bookingId?: StringWithAggregatesFilter<"Review"> | string
    hostId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringWithAggregatesFilter<"Review"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type WishlistWhereInput = {
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    id?: StringFilter<"Wishlist"> | string
    userId?: StringFilter<"Wishlist"> | string
    serviceId?: StringFilter<"Wishlist"> | string
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type WishlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type WishlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_serviceId?: WishlistUserIdServiceIdCompoundUniqueInput
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    userId?: StringFilter<"Wishlist"> | string
    serviceId?: StringFilter<"Wishlist"> | string
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id" | "userId_serviceId">

  export type WishlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    _count?: WishlistCountOrderByAggregateInput
    _max?: WishlistMaxOrderByAggregateInput
    _min?: WishlistMinOrderByAggregateInput
  }

  export type WishlistScalarWhereWithAggregatesInput = {
    AND?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    OR?: WishlistScalarWhereWithAggregatesInput[]
    NOT?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wishlist"> | string
    userId?: StringWithAggregatesFilter<"Wishlist"> | string
    serviceId?: StringWithAggregatesFilter<"Wishlist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    title?: StringFilter<"PromoCode"> | string
    description?: StringFilter<"PromoCode"> | string
    discountType?: StringFilter<"PromoCode"> | string
    amount?: IntFilter<"PromoCode"> | number
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeFilter<"PromoCode"> | Date | string
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    isActive?: BoolFilter<"PromoCode"> | boolean
    bookings?: BookingListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    amount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    title?: StringFilter<"PromoCode"> | string
    description?: StringFilter<"PromoCode"> | string
    discountType?: StringFilter<"PromoCode"> | string
    amount?: IntFilter<"PromoCode"> | number
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeFilter<"PromoCode"> | Date | string
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    isActive?: BoolFilter<"PromoCode"> | boolean
    bookings?: BookingListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    amount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    title?: StringWithAggregatesFilter<"PromoCode"> | string
    description?: StringWithAggregatesFilter<"PromoCode"> | string
    discountType?: StringWithAggregatesFilter<"PromoCode"> | string
    amount?: IntWithAggregatesFilter<"PromoCode"> | number
    validFrom?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    usageLimit?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    usedCount?: IntWithAggregatesFilter<"PromoCode"> | number
    isActive?: BoolWithAggregatesFilter<"PromoCode"> | boolean
  }

  export type HostBadgeWhereInput = {
    AND?: HostBadgeWhereInput | HostBadgeWhereInput[]
    OR?: HostBadgeWhereInput[]
    NOT?: HostBadgeWhereInput | HostBadgeWhereInput[]
    id?: StringFilter<"HostBadge"> | string
    hostId?: StringFilter<"HostBadge"> | string
    type?: StringFilter<"HostBadge"> | string
    createdAt?: DateTimeFilter<"HostBadge"> | Date | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }

  export type HostBadgeOrderByWithRelationInput = {
    id?: SortOrder
    hostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    host?: HostOrderByWithRelationInput
  }

  export type HostBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HostBadgeWhereInput | HostBadgeWhereInput[]
    OR?: HostBadgeWhereInput[]
    NOT?: HostBadgeWhereInput | HostBadgeWhereInput[]
    hostId?: StringFilter<"HostBadge"> | string
    type?: StringFilter<"HostBadge"> | string
    createdAt?: DateTimeFilter<"HostBadge"> | Date | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }, "id">

  export type HostBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    hostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: HostBadgeCountOrderByAggregateInput
    _max?: HostBadgeMaxOrderByAggregateInput
    _min?: HostBadgeMinOrderByAggregateInput
  }

  export type HostBadgeScalarWhereWithAggregatesInput = {
    AND?: HostBadgeScalarWhereWithAggregatesInput | HostBadgeScalarWhereWithAggregatesInput[]
    OR?: HostBadgeScalarWhereWithAggregatesInput[]
    NOT?: HostBadgeScalarWhereWithAggregatesInput | HostBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HostBadge"> | string
    hostId?: StringWithAggregatesFilter<"HostBadge"> | string
    type?: StringWithAggregatesFilter<"HostBadge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HostBadge"> | Date | string
  }

  export type BlockedDateWhereInput = {
    AND?: BlockedDateWhereInput | BlockedDateWhereInput[]
    OR?: BlockedDateWhereInput[]
    NOT?: BlockedDateWhereInput | BlockedDateWhereInput[]
    id?: StringFilter<"BlockedDate"> | string
    hostId?: StringFilter<"BlockedDate"> | string
    date?: DateTimeFilter<"BlockedDate"> | Date | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }

  export type BlockedDateOrderByWithRelationInput = {
    id?: SortOrder
    hostId?: SortOrder
    date?: SortOrder
    host?: HostOrderByWithRelationInput
  }

  export type BlockedDateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlockedDateWhereInput | BlockedDateWhereInput[]
    OR?: BlockedDateWhereInput[]
    NOT?: BlockedDateWhereInput | BlockedDateWhereInput[]
    hostId?: StringFilter<"BlockedDate"> | string
    date?: DateTimeFilter<"BlockedDate"> | Date | string
    host?: XOR<HostRelationFilter, HostWhereInput>
  }, "id">

  export type BlockedDateOrderByWithAggregationInput = {
    id?: SortOrder
    hostId?: SortOrder
    date?: SortOrder
    _count?: BlockedDateCountOrderByAggregateInput
    _max?: BlockedDateMaxOrderByAggregateInput
    _min?: BlockedDateMinOrderByAggregateInput
  }

  export type BlockedDateScalarWhereWithAggregatesInput = {
    AND?: BlockedDateScalarWhereWithAggregatesInput | BlockedDateScalarWhereWithAggregatesInput[]
    OR?: BlockedDateScalarWhereWithAggregatesInput[]
    NOT?: BlockedDateScalarWhereWithAggregatesInput | BlockedDateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockedDate"> | string
    hostId?: StringWithAggregatesFilter<"BlockedDate"> | string
    date?: DateTimeWithAggregatesFilter<"BlockedDate"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringFilter<"Referral"> | string
    usedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    referrer?: UserOrderByWithRelationInput
    referee?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refereeId?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: StringFilter<"Referral"> | string
    usedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "refereeId">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    refereeId?: StringWithAggregatesFilter<"Referral"> | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
  }

  export type StoryWhereInput = {
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    id?: StringFilter<"Story"> | string
    userId?: StringFilter<"Story"> | string
    type?: EnumStoryTypeFilter<"Story"> | $Enums.StoryType
    title?: StringFilter<"Story"> | string
    content?: StringFilter<"Story"> | string
    imageUrl?: StringFilter<"Story"> | string
    location?: StringFilter<"Story"> | string
    postedAt?: DateTimeFilter<"Story"> | Date | string
    createdAt?: DateTimeFilter<"Story"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    likes?: StoryLikeListRelationFilter
    comments?: StoryCommentListRelationFilter
  }

  export type StoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    location?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    likes?: StoryLikeOrderByRelationAggregateInput
    comments?: StoryCommentOrderByRelationAggregateInput
  }

  export type StoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    userId?: StringFilter<"Story"> | string
    type?: EnumStoryTypeFilter<"Story"> | $Enums.StoryType
    title?: StringFilter<"Story"> | string
    content?: StringFilter<"Story"> | string
    imageUrl?: StringFilter<"Story"> | string
    location?: StringFilter<"Story"> | string
    postedAt?: DateTimeFilter<"Story"> | Date | string
    createdAt?: DateTimeFilter<"Story"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    likes?: StoryLikeListRelationFilter
    comments?: StoryCommentListRelationFilter
  }, "id">

  export type StoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    location?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
    _count?: StoryCountOrderByAggregateInput
    _max?: StoryMaxOrderByAggregateInput
    _min?: StoryMinOrderByAggregateInput
  }

  export type StoryScalarWhereWithAggregatesInput = {
    AND?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    OR?: StoryScalarWhereWithAggregatesInput[]
    NOT?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Story"> | string
    userId?: StringWithAggregatesFilter<"Story"> | string
    type?: EnumStoryTypeWithAggregatesFilter<"Story"> | $Enums.StoryType
    title?: StringWithAggregatesFilter<"Story"> | string
    content?: StringWithAggregatesFilter<"Story"> | string
    imageUrl?: StringWithAggregatesFilter<"Story"> | string
    location?: StringWithAggregatesFilter<"Story"> | string
    postedAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
  }

  export type StoryLikeWhereInput = {
    AND?: StoryLikeWhereInput | StoryLikeWhereInput[]
    OR?: StoryLikeWhereInput[]
    NOT?: StoryLikeWhereInput | StoryLikeWhereInput[]
    id?: StringFilter<"StoryLike"> | string
    storyId?: StringFilter<"StoryLike"> | string
    userId?: StringFilter<"StoryLike"> | string
    createdAt?: DateTimeFilter<"StoryLike"> | Date | string
    story?: XOR<StoryRelationFilter, StoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StoryLikeOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    story?: StoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StoryLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storyId_userId?: StoryLikeStoryIdUserIdCompoundUniqueInput
    AND?: StoryLikeWhereInput | StoryLikeWhereInput[]
    OR?: StoryLikeWhereInput[]
    NOT?: StoryLikeWhereInput | StoryLikeWhereInput[]
    storyId?: StringFilter<"StoryLike"> | string
    userId?: StringFilter<"StoryLike"> | string
    createdAt?: DateTimeFilter<"StoryLike"> | Date | string
    story?: XOR<StoryRelationFilter, StoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "storyId_userId">

  export type StoryLikeOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: StoryLikeCountOrderByAggregateInput
    _max?: StoryLikeMaxOrderByAggregateInput
    _min?: StoryLikeMinOrderByAggregateInput
  }

  export type StoryLikeScalarWhereWithAggregatesInput = {
    AND?: StoryLikeScalarWhereWithAggregatesInput | StoryLikeScalarWhereWithAggregatesInput[]
    OR?: StoryLikeScalarWhereWithAggregatesInput[]
    NOT?: StoryLikeScalarWhereWithAggregatesInput | StoryLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryLike"> | string
    storyId?: StringWithAggregatesFilter<"StoryLike"> | string
    userId?: StringWithAggregatesFilter<"StoryLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StoryLike"> | Date | string
  }

  export type StoryCommentWhereInput = {
    AND?: StoryCommentWhereInput | StoryCommentWhereInput[]
    OR?: StoryCommentWhereInput[]
    NOT?: StoryCommentWhereInput | StoryCommentWhereInput[]
    id?: StringFilter<"StoryComment"> | string
    storyId?: StringFilter<"StoryComment"> | string
    userId?: StringFilter<"StoryComment"> | string
    content?: StringFilter<"StoryComment"> | string
    createdAt?: DateTimeFilter<"StoryComment"> | Date | string
    story?: XOR<StoryRelationFilter, StoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StoryCommentOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    story?: StoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StoryCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryCommentWhereInput | StoryCommentWhereInput[]
    OR?: StoryCommentWhereInput[]
    NOT?: StoryCommentWhereInput | StoryCommentWhereInput[]
    storyId?: StringFilter<"StoryComment"> | string
    userId?: StringFilter<"StoryComment"> | string
    content?: StringFilter<"StoryComment"> | string
    createdAt?: DateTimeFilter<"StoryComment"> | Date | string
    story?: XOR<StoryRelationFilter, StoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type StoryCommentOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: StoryCommentCountOrderByAggregateInput
    _max?: StoryCommentMaxOrderByAggregateInput
    _min?: StoryCommentMinOrderByAggregateInput
  }

  export type StoryCommentScalarWhereWithAggregatesInput = {
    AND?: StoryCommentScalarWhereWithAggregatesInput | StoryCommentScalarWhereWithAggregatesInput[]
    OR?: StoryCommentScalarWhereWithAggregatesInput[]
    NOT?: StoryCommentScalarWhereWithAggregatesInput | StoryCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryComment"> | string
    storyId?: StringWithAggregatesFilter<"StoryComment"> | string
    userId?: StringWithAggregatesFilter<"StoryComment"> | string
    content?: StringWithAggregatesFilter<"StoryComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StoryComment"> | Date | string
  }

  export type TopDestinationCreateInput = {
    id?: string
    order: number
    imageUrl?: string | null
    createdAt?: Date | string
    city: CityCreateNestedOneWithoutTopDestinationInput
  }

  export type TopDestinationUncheckedCreateInput = {
    id?: string
    cityId: string
    order: number
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type TopDestinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutTopDestinationNestedInput
  }

  export type TopDestinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopDestinationCreateManyInput = {
    id?: string
    cityId: string
    order: number
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type TopDestinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopDestinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    code: string
    cities?: CityCreateNestedManyWithoutCountryInput
    users?: UserCreateNestedManyWithoutCountryInput
    hosts?: HostCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    users?: UserUncheckedCreateNestedManyWithoutCountryInput
    hosts?: HostUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    users?: UserUpdateManyWithoutCountryNestedInput
    hosts?: HostUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    users?: UserUncheckedUpdateManyWithoutCountryNestedInput
    hosts?: HostUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    code: string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    lat: number
    lng: number
    country: CountryCreateNestedOneWithoutCitiesInput
    users?: UserCreateNestedManyWithoutCityInput
    hosts?: HostCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationCreateNestedOneWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    countryId: string
    lat: number
    lng: number
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    hosts?: HostUncheckedCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationUncheckedCreateNestedOneWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    hosts?: HostUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUpdateOneWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    hosts?: HostUncheckedUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUncheckedUpdateOneWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    countryId: string
    lat: number
    lng: number
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
  }

  export type LanguageCreateInput = {
    id?: string
    name: string
    hosts?: HostLanguageCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    name: string
    hosts?: HostLanguageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hosts?: HostLanguageUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hosts?: HostLanguageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: string
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HostCreateInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type HostCreateManyInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type HostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostLanguageCreateInput = {
    id?: string
    host: HostCreateNestedOneWithoutLanguagesInput
    language: LanguageCreateNestedOneWithoutHostsInput
  }

  export type HostLanguageUncheckedCreateInput = {
    id?: string
    hostId: string
    languageId: string
  }

  export type HostLanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    host?: HostUpdateOneRequiredWithoutLanguagesNestedInput
    language?: LanguageUpdateOneRequiredWithoutHostsNestedInput
  }

  export type HostLanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
  }

  export type HostLanguageCreateManyInput = {
    id?: string
    hostId: string
    languageId: string
  }

  export type HostLanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type HostLanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerSkillCreateInput = {
    id?: string
    skill: string
    host: HostCreateNestedOneWithoutPhotographerSkillsInput
  }

  export type PhotographerSkillUncheckedCreateInput = {
    id?: string
    hostId: string
    skill: string
  }

  export type PhotographerSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    host?: HostUpdateOneRequiredWithoutPhotographerSkillsNestedInput
  }

  export type PhotographerSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerSkillCreateManyInput = {
    id?: string
    hostId: string
    skill: string
  }

  export type PhotographerSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerGearCreateInput = {
    id?: string
    gearType: string
    name: string
    host: HostCreateNestedOneWithoutPhotographerGearsInput
  }

  export type PhotographerGearUncheckedCreateInput = {
    id?: string
    hostId: string
    gearType: string
    name: string
  }

  export type PhotographerGearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gearType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    host?: HostUpdateOneRequiredWithoutPhotographerGearsNestedInput
  }

  export type PhotographerGearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    gearType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerGearCreateManyInput = {
    id?: string
    hostId: string
    gearType: string
    name: string
  }

  export type PhotographerGearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gearType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerGearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    gearType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    host: HostCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
    wishlist?: WishlistCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    hostId: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: HostUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    wishlist?: WishlistUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    hostId: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryCreateInput = {
    id?: string
    step: number
    title: string
    description: string
    duration: number
    service: ServiceCreateNestedOneWithoutItinerariesInput
  }

  export type ItineraryUncheckedCreateInput = {
    id?: string
    serviceId: string
    step: number
    title: string
    description: string
    duration: number
  }

  export type ItineraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutItinerariesNestedInput
  }

  export type ItineraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryCreateManyInput = {
    id?: string
    serviceId: string
    step: number
    title: string
    description: string
    duration: number
  }

  export type ItineraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type BookingCreateInput = {
    id?: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyConversionLogCreateInput = {
    id?: string
    sourceCurrency: $Enums.CurrencyCode
    targetCurrency: $Enums.CurrencyCode
    rate: number
    convertedAmount: number
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutCurrencyConversionLogInput
  }

  export type CurrencyConversionLogUncheckedCreateInput = {
    id?: string
    bookingId: string
    sourceCurrency: $Enums.CurrencyCode
    targetCurrency: $Enums.CurrencyCode
    rate: number
    convertedAmount: number
    createdAt?: Date | string
  }

  export type CurrencyConversionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    rate?: FloatFieldUpdateOperationsInput | number
    convertedAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCurrencyConversionLogNestedInput
  }

  export type CurrencyConversionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    sourceCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    rate?: FloatFieldUpdateOperationsInput | number
    convertedAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyConversionLogCreateManyInput = {
    id?: string
    bookingId: string
    sourceCurrency: $Enums.CurrencyCode
    targetCurrency: $Enums.CurrencyCode
    rate: number
    convertedAmount: number
    createdAt?: Date | string
  }

  export type CurrencyConversionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    rate?: FloatFieldUpdateOperationsInput | number
    convertedAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyConversionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    sourceCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    rate?: FloatFieldUpdateOperationsInput | number
    convertedAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutReviewInput
    host: HostCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    bookingId: string
    hostId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutReviewNestedInput
    host?: HostUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    bookingId: string
    hostId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistInput
    service: ServiceCreateNestedOneWithoutWishlistInput
  }

  export type WishlistUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type WishlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
    service?: ServiceUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type WishlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    title: string
    description: string
    discountType: string
    amount: number
    validFrom: Date | string
    validUntil: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    bookings?: BookingCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    description: string
    discountType: string
    amount: number
    validFrom: Date | string
    validUntil: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    bookings?: BookingUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    title: string
    description: string
    discountType: string
    amount: number
    validFrom: Date | string
    validUntil: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HostBadgeCreateInput = {
    id?: string
    type: string
    createdAt?: Date | string
    host: HostCreateNestedOneWithoutBadgesInput
  }

  export type HostBadgeUncheckedCreateInput = {
    id?: string
    hostId: string
    type: string
    createdAt?: Date | string
  }

  export type HostBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: HostUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type HostBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostBadgeCreateManyInput = {
    id?: string
    hostId: string
    type: string
    createdAt?: Date | string
  }

  export type HostBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedDateCreateInput = {
    id?: string
    date: Date | string
    host: HostCreateNestedOneWithoutBlockedDatesInput
  }

  export type BlockedDateUncheckedCreateInput = {
    id?: string
    hostId: string
    date: Date | string
  }

  export type BlockedDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: HostUpdateOneRequiredWithoutBlockedDatesNestedInput
  }

  export type BlockedDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedDateCreateManyInput = {
    id?: string
    hostId: string
    date: Date | string
  }

  export type BlockedDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    usedAt?: Date | string | null
    referrer: UserCreateNestedOneWithoutReferralsInput
    referee: UserCreateNestedOneWithoutReferredByInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerId: string
    refereeId: string
    usedAt?: Date | string | null
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
    referee?: UserUpdateOneRequiredWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerId: string
    refereeId: string
    usedAt?: Date | string | null
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryCreateInput = {
    id?: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStoriesInput
    likes?: StoryLikeCreateNestedManyWithoutStoryInput
    comments?: StoryCommentCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    likes?: StoryLikeUncheckedCreateNestedManyWithoutStoryInput
    comments?: StoryCommentUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoriesNestedInput
    likes?: StoryLikeUpdateManyWithoutStoryNestedInput
    comments?: StoryCommentUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: StoryLikeUncheckedUpdateManyWithoutStoryNestedInput
    comments?: StoryCommentUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
  }

  export type StoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    story: StoryCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutStoryLikesInput
  }

  export type StoryLikeUncheckedCreateInput = {
    id?: string
    storyId: string
    userId: string
    createdAt?: Date | string
  }

  export type StoryLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutStoryLikesNestedInput
  }

  export type StoryLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryLikeCreateManyInput = {
    id?: string
    storyId: string
    userId: string
    createdAt?: Date | string
  }

  export type StoryLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    story: StoryCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutStoryCommentsInput
  }

  export type StoryCommentUncheckedCreateInput = {
    id?: string
    storyId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type StoryCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutStoryCommentsNestedInput
  }

  export type StoryCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCommentCreateManyInput = {
    id?: string
    storyId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type StoryCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TopDestinationCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TopDestinationAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TopDestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TopDestinationMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    order?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TopDestinationSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type HostListRelationFilter = {
    every?: HostWhereInput
    some?: HostWhereInput
    none?: HostWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type TopDestinationNullableRelationFilter = {
    is?: TopDestinationWhereInput | null
    isNot?: TopDestinationWhereInput | null
  }

  export type CityNameCountryIdCompoundUniqueInput = {
    name: string
    countryId: string
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type HostLanguageListRelationFilter = {
    every?: HostLanguageWhereInput
    some?: HostLanguageWhereInput
    none?: HostLanguageWhereInput
  }

  export type HostLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type CountryNullableRelationFilter = {
    is?: CountryWhereInput | null
    isNot?: CountryWhereInput | null
  }

  export type CityNullableRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type HostNullableRelationFilter = {
    is?: HostWhereInput | null
    isNot?: HostWhereInput | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type WishlistListRelationFilter = {
    every?: WishlistWhereInput
    some?: WishlistWhereInput
    none?: WishlistWhereInput
  }

  export type StoryListRelationFilter = {
    every?: StoryWhereInput
    some?: StoryWhereInput
    none?: StoryWhereInput
  }

  export type StoryLikeListRelationFilter = {
    every?: StoryLikeWhereInput
    some?: StoryLikeWhereInput
    none?: StoryLikeWhereInput
  }

  export type StoryCommentListRelationFilter = {
    every?: StoryCommentWhereInput
    some?: StoryCommentWhereInput
    none?: StoryCommentWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReferralNullableRelationFilter = {
    is?: ReferralWhereInput | null
    isNot?: ReferralWhereInput | null
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredById?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type BlockedDateListRelationFilter = {
    every?: BlockedDateWhereInput
    some?: BlockedDateWhereInput
    none?: BlockedDateWhereInput
  }

  export type HostBadgeListRelationFilter = {
    every?: HostBadgeWhereInput
    some?: HostBadgeWhereInput
    none?: HostBadgeWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type PhotographerSkillListRelationFilter = {
    every?: PhotographerSkillWhereInput
    some?: PhotographerSkillWhereInput
    none?: PhotographerSkillWhereInput
  }

  export type PhotographerGearListRelationFilter = {
    every?: PhotographerGearWhereInput
    some?: PhotographerGearWhereInput
    none?: PhotographerGearWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockedDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HostBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhotographerSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhotographerGearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isGuide?: SortOrder
    isPhotographer?: SortOrder
    profileVideo?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type HostAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type HostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isGuide?: SortOrder
    isPhotographer?: SortOrder
    profileVideo?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type HostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isGuide?: SortOrder
    isPhotographer?: SortOrder
    profileVideo?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type HostSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type HostRelationFilter = {
    is?: HostWhereInput
    isNot?: HostWhereInput
  }

  export type LanguageRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type HostLanguageHostIdLanguageIdCompoundUniqueInput = {
    hostId: string
    languageId: string
  }

  export type HostLanguageCountOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    languageId?: SortOrder
  }

  export type HostLanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    languageId?: SortOrder
  }

  export type HostLanguageMinOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    languageId?: SortOrder
  }

  export type PhotographerSkillCountOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    skill?: SortOrder
  }

  export type PhotographerSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    skill?: SortOrder
  }

  export type PhotographerSkillMinOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    skill?: SortOrder
  }

  export type PhotographerGearCountOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    gearType?: SortOrder
    name?: SortOrder
  }

  export type PhotographerGearMaxOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    gearType?: SortOrder
    name?: SortOrder
  }

  export type PhotographerGearMinOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    gearType?: SortOrder
    name?: SortOrder
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type EnumCurrencyCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeFilter<$PrismaModel> | $Enums.CurrencyCode
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ItineraryListRelationFilter = {
    every?: ItineraryWhereInput
    some?: ItineraryWhereInput
    none?: ItineraryWhereInput
  }

  export type ItineraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type EnumCurrencyCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyCodeFilter<$PrismaModel>
    _max?: NestedEnumCurrencyCodeFilter<$PrismaModel>
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ItineraryCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
  }

  export type ItineraryAvgOrderByAggregateInput = {
    step?: SortOrder
    duration?: SortOrder
  }

  export type ItineraryMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
  }

  export type ItineraryMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    step?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
  }

  export type ItinerarySumOrderByAggregateInput = {
    step?: SortOrder
    duration?: SortOrder
  }

  export type EnumContactMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodFilter<$PrismaModel> | $Enums.ContactMethod
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type PromoCodeNullableRelationFilter = {
    is?: PromoCodeWhereInput | null
    isNot?: PromoCodeWhereInput | null
  }

  export type ReviewNullableRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type CurrencyConversionLogNullableRelationFilter = {
    is?: CurrencyConversionLogWhereInput | null
    isNot?: CurrencyConversionLogWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    date?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    contactMethod?: SortOrder
    contactDetail?: SortOrder
    meetingPoint?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    promoCodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    date?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    contactMethod?: SortOrder
    contactDetail?: SortOrder
    meetingPoint?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    promoCodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    date?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    contactMethod?: SortOrder
    contactDetail?: SortOrder
    meetingPoint?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    promoCodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumContactMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodWithAggregatesFilter<$PrismaModel> | $Enums.ContactMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactMethodFilter<$PrismaModel>
    _max?: NestedEnumContactMethodFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type CurrencyConversionLogCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    sourceCurrency?: SortOrder
    targetCurrency?: SortOrder
    rate?: SortOrder
    convertedAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type CurrencyConversionLogAvgOrderByAggregateInput = {
    rate?: SortOrder
    convertedAmount?: SortOrder
  }

  export type CurrencyConversionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    sourceCurrency?: SortOrder
    targetCurrency?: SortOrder
    rate?: SortOrder
    convertedAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type CurrencyConversionLogMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    sourceCurrency?: SortOrder
    targetCurrency?: SortOrder
    rate?: SortOrder
    convertedAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type CurrencyConversionLogSumOrderByAggregateInput = {
    rate?: SortOrder
    convertedAmount?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hostId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hostId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hostId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type WishlistUserIdServiceIdCompoundUniqueInput = {
    userId: string
    serviceId: string
  }

  export type WishlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type WishlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type WishlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    amount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    amount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    amount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    amount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    amount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type HostBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type HostBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type HostBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedDateCountOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    date?: SortOrder
  }

  export type BlockedDateMaxOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    date?: SortOrder
  }

  export type BlockedDateMinOrderByAggregateInput = {
    id?: SortOrder
    hostId?: SortOrder
    date?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    usedAt?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    usedAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    usedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumStoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryType | EnumStoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryTypeFilter<$PrismaModel> | $Enums.StoryType
  }

  export type StoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    location?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    location?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    location?: SortOrder
    postedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumStoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryType | EnumStoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryTypeFilter<$PrismaModel>
    _max?: NestedEnumStoryTypeFilter<$PrismaModel>
  }

  export type StoryRelationFilter = {
    is?: StoryWhereInput
    isNot?: StoryWhereInput
  }

  export type StoryLikeStoryIdUserIdCompoundUniqueInput = {
    storyId: string
    userId: string
  }

  export type StoryLikeCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryLikeMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryCommentCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryCommentMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CityCreateNestedOneWithoutTopDestinationInput = {
    create?: XOR<CityCreateWithoutTopDestinationInput, CityUncheckedCreateWithoutTopDestinationInput>
    connectOrCreate?: CityCreateOrConnectWithoutTopDestinationInput
    connect?: CityWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CityUpdateOneRequiredWithoutTopDestinationNestedInput = {
    create?: XOR<CityCreateWithoutTopDestinationInput, CityUncheckedCreateWithoutTopDestinationInput>
    connectOrCreate?: CityCreateOrConnectWithoutTopDestinationInput
    upsert?: CityUpsertWithoutTopDestinationInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutTopDestinationInput, CityUpdateWithoutTopDestinationInput>, CityUncheckedUpdateWithoutTopDestinationInput>
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCountryInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HostCreateNestedManyWithoutCountryInput = {
    create?: XOR<HostCreateWithoutCountryInput, HostUncheckedCreateWithoutCountryInput> | HostCreateWithoutCountryInput[] | HostUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCountryInput | HostCreateOrConnectWithoutCountryInput[]
    createMany?: HostCreateManyCountryInputEnvelope
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HostUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<HostCreateWithoutCountryInput, HostUncheckedCreateWithoutCountryInput> | HostCreateWithoutCountryInput[] | HostUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCountryInput | HostCreateOrConnectWithoutCountryInput[]
    createMany?: HostCreateManyCountryInputEnvelope
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCountryNestedInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCountryInput | UserUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCountryInput | UserUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCountryInput | UserUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HostUpdateManyWithoutCountryNestedInput = {
    create?: XOR<HostCreateWithoutCountryInput, HostUncheckedCreateWithoutCountryInput> | HostCreateWithoutCountryInput[] | HostUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCountryInput | HostCreateOrConnectWithoutCountryInput[]
    upsert?: HostUpsertWithWhereUniqueWithoutCountryInput | HostUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: HostCreateManyCountryInputEnvelope
    set?: HostWhereUniqueInput | HostWhereUniqueInput[]
    disconnect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    delete?: HostWhereUniqueInput | HostWhereUniqueInput[]
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    update?: HostUpdateWithWhereUniqueWithoutCountryInput | HostUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: HostUpdateManyWithWhereWithoutCountryInput | HostUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: HostScalarWhereInput | HostScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput> | UserCreateWithoutCountryInput[] | UserUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCountryInput | UserCreateOrConnectWithoutCountryInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCountryInput | UserUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: UserCreateManyCountryInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCountryInput | UserUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCountryInput | UserUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HostUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<HostCreateWithoutCountryInput, HostUncheckedCreateWithoutCountryInput> | HostCreateWithoutCountryInput[] | HostUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCountryInput | HostCreateOrConnectWithoutCountryInput[]
    upsert?: HostUpsertWithWhereUniqueWithoutCountryInput | HostUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: HostCreateManyCountryInputEnvelope
    set?: HostWhereUniqueInput | HostWhereUniqueInput[]
    disconnect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    delete?: HostWhereUniqueInput | HostWhereUniqueInput[]
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    update?: HostUpdateWithWhereUniqueWithoutCountryInput | HostUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: HostUpdateManyWithWhereWithoutCountryInput | HostUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: HostScalarWhereInput | HostScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HostCreateNestedManyWithoutCityInput = {
    create?: XOR<HostCreateWithoutCityInput, HostUncheckedCreateWithoutCityInput> | HostCreateWithoutCityInput[] | HostUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCityInput | HostCreateOrConnectWithoutCityInput[]
    createMany?: HostCreateManyCityInputEnvelope
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
  }

  export type TopDestinationCreateNestedOneWithoutCityInput = {
    create?: XOR<TopDestinationCreateWithoutCityInput, TopDestinationUncheckedCreateWithoutCityInput>
    connectOrCreate?: TopDestinationCreateOrConnectWithoutCityInput
    connect?: TopDestinationWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HostUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<HostCreateWithoutCityInput, HostUncheckedCreateWithoutCityInput> | HostCreateWithoutCityInput[] | HostUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCityInput | HostCreateOrConnectWithoutCityInput[]
    createMany?: HostCreateManyCityInputEnvelope
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
  }

  export type TopDestinationUncheckedCreateNestedOneWithoutCityInput = {
    create?: XOR<TopDestinationCreateWithoutCityInput, TopDestinationUncheckedCreateWithoutCityInput>
    connectOrCreate?: TopDestinationCreateOrConnectWithoutCityInput
    connect?: TopDestinationWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HostUpdateManyWithoutCityNestedInput = {
    create?: XOR<HostCreateWithoutCityInput, HostUncheckedCreateWithoutCityInput> | HostCreateWithoutCityInput[] | HostUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCityInput | HostCreateOrConnectWithoutCityInput[]
    upsert?: HostUpsertWithWhereUniqueWithoutCityInput | HostUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: HostCreateManyCityInputEnvelope
    set?: HostWhereUniqueInput | HostWhereUniqueInput[]
    disconnect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    delete?: HostWhereUniqueInput | HostWhereUniqueInput[]
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    update?: HostUpdateWithWhereUniqueWithoutCityInput | HostUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: HostUpdateManyWithWhereWithoutCityInput | HostUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: HostScalarWhereInput | HostScalarWhereInput[]
  }

  export type TopDestinationUpdateOneWithoutCityNestedInput = {
    create?: XOR<TopDestinationCreateWithoutCityInput, TopDestinationUncheckedCreateWithoutCityInput>
    connectOrCreate?: TopDestinationCreateOrConnectWithoutCityInput
    upsert?: TopDestinationUpsertWithoutCityInput
    disconnect?: TopDestinationWhereInput | boolean
    delete?: TopDestinationWhereInput | boolean
    connect?: TopDestinationWhereUniqueInput
    update?: XOR<XOR<TopDestinationUpdateToOneWithWhereWithoutCityInput, TopDestinationUpdateWithoutCityInput>, TopDestinationUncheckedUpdateWithoutCityInput>
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HostUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<HostCreateWithoutCityInput, HostUncheckedCreateWithoutCityInput> | HostCreateWithoutCityInput[] | HostUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HostCreateOrConnectWithoutCityInput | HostCreateOrConnectWithoutCityInput[]
    upsert?: HostUpsertWithWhereUniqueWithoutCityInput | HostUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: HostCreateManyCityInputEnvelope
    set?: HostWhereUniqueInput | HostWhereUniqueInput[]
    disconnect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    delete?: HostWhereUniqueInput | HostWhereUniqueInput[]
    connect?: HostWhereUniqueInput | HostWhereUniqueInput[]
    update?: HostUpdateWithWhereUniqueWithoutCityInput | HostUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: HostUpdateManyWithWhereWithoutCityInput | HostUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: HostScalarWhereInput | HostScalarWhereInput[]
  }

  export type TopDestinationUncheckedUpdateOneWithoutCityNestedInput = {
    create?: XOR<TopDestinationCreateWithoutCityInput, TopDestinationUncheckedCreateWithoutCityInput>
    connectOrCreate?: TopDestinationCreateOrConnectWithoutCityInput
    upsert?: TopDestinationUpsertWithoutCityInput
    disconnect?: TopDestinationWhereInput | boolean
    delete?: TopDestinationWhereInput | boolean
    connect?: TopDestinationWhereUniqueInput
    update?: XOR<XOR<TopDestinationUpdateToOneWithWhereWithoutCityInput, TopDestinationUpdateWithoutCityInput>, TopDestinationUncheckedUpdateWithoutCityInput>
  }

  export type HostLanguageCreateNestedManyWithoutLanguageInput = {
    create?: XOR<HostLanguageCreateWithoutLanguageInput, HostLanguageUncheckedCreateWithoutLanguageInput> | HostLanguageCreateWithoutLanguageInput[] | HostLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutLanguageInput | HostLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: HostLanguageCreateManyLanguageInputEnvelope
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
  }

  export type HostLanguageUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<HostLanguageCreateWithoutLanguageInput, HostLanguageUncheckedCreateWithoutLanguageInput> | HostLanguageCreateWithoutLanguageInput[] | HostLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutLanguageInput | HostLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: HostLanguageCreateManyLanguageInputEnvelope
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
  }

  export type HostLanguageUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<HostLanguageCreateWithoutLanguageInput, HostLanguageUncheckedCreateWithoutLanguageInput> | HostLanguageCreateWithoutLanguageInput[] | HostLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutLanguageInput | HostLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: HostLanguageUpsertWithWhereUniqueWithoutLanguageInput | HostLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: HostLanguageCreateManyLanguageInputEnvelope
    set?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    disconnect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    delete?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    update?: HostLanguageUpdateWithWhereUniqueWithoutLanguageInput | HostLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: HostLanguageUpdateManyWithWhereWithoutLanguageInput | HostLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: HostLanguageScalarWhereInput | HostLanguageScalarWhereInput[]
  }

  export type HostLanguageUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<HostLanguageCreateWithoutLanguageInput, HostLanguageUncheckedCreateWithoutLanguageInput> | HostLanguageCreateWithoutLanguageInput[] | HostLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutLanguageInput | HostLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: HostLanguageUpsertWithWhereUniqueWithoutLanguageInput | HostLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: HostLanguageCreateManyLanguageInputEnvelope
    set?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    disconnect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    delete?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    update?: HostLanguageUpdateWithWhereUniqueWithoutLanguageInput | HostLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: HostLanguageUpdateManyWithWhereWithoutLanguageInput | HostLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: HostLanguageScalarWhereInput | HostLanguageScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutUsersInput = {
    create?: XOR<CountryCreateWithoutUsersInput, CountryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CountryCreateOrConnectWithoutUsersInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutUsersInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    connect?: CityWhereUniqueInput
  }

  export type HostCreateNestedOneWithoutUserInput = {
    create?: XOR<HostCreateWithoutUserInput, HostUncheckedCreateWithoutUserInput>
    connectOrCreate?: HostCreateOrConnectWithoutUserInput
    connect?: HostWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type WishlistCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type StoryCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryCreateWithoutUserInput, StoryUncheckedCreateWithoutUserInput> | StoryCreateWithoutUserInput[] | StoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUserInput | StoryCreateOrConnectWithoutUserInput[]
    createMany?: StoryCreateManyUserInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type StoryLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryLikeCreateWithoutUserInput, StoryLikeUncheckedCreateWithoutUserInput> | StoryLikeCreateWithoutUserInput[] | StoryLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutUserInput | StoryLikeCreateOrConnectWithoutUserInput[]
    createMany?: StoryLikeCreateManyUserInputEnvelope
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
  }

  export type StoryCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryCommentCreateWithoutUserInput, StoryCommentUncheckedCreateWithoutUserInput> | StoryCommentCreateWithoutUserInput[] | StoryCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutUserInput | StoryCommentCreateOrConnectWithoutUserInput[]
    createMany?: StoryCommentCreateManyUserInputEnvelope
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    connect?: ReferralWhereUniqueInput
  }

  export type HostUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HostCreateWithoutUserInput, HostUncheckedCreateWithoutUserInput>
    connectOrCreate?: HostCreateOrConnectWithoutUserInput
    connect?: HostWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type WishlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryCreateWithoutUserInput, StoryUncheckedCreateWithoutUserInput> | StoryCreateWithoutUserInput[] | StoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUserInput | StoryCreateOrConnectWithoutUserInput[]
    createMany?: StoryCreateManyUserInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type StoryLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryLikeCreateWithoutUserInput, StoryLikeUncheckedCreateWithoutUserInput> | StoryLikeCreateWithoutUserInput[] | StoryLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutUserInput | StoryLikeCreateOrConnectWithoutUserInput[]
    createMany?: StoryLikeCreateManyUserInputEnvelope
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
  }

  export type StoryCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoryCommentCreateWithoutUserInput, StoryCommentUncheckedCreateWithoutUserInput> | StoryCommentCreateWithoutUserInput[] | StoryCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutUserInput | StoryCommentCreateOrConnectWithoutUserInput[]
    createMany?: StoryCommentCreateManyUserInputEnvelope
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    connect?: ReferralWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type CountryUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CountryCreateWithoutUsersInput, CountryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CountryCreateOrConnectWithoutUsersInput
    upsert?: CountryUpsertWithoutUsersInput
    disconnect?: CountryWhereInput | boolean
    delete?: CountryWhereInput | boolean
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutUsersInput, CountryUpdateWithoutUsersInput>, CountryUncheckedUpdateWithoutUsersInput>
  }

  export type CityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    upsert?: CityUpsertWithoutUsersInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutUsersInput, CityUpdateWithoutUsersInput>, CityUncheckedUpdateWithoutUsersInput>
  }

  export type HostUpdateOneWithoutUserNestedInput = {
    create?: XOR<HostCreateWithoutUserInput, HostUncheckedCreateWithoutUserInput>
    connectOrCreate?: HostCreateOrConnectWithoutUserInput
    upsert?: HostUpsertWithoutUserInput
    disconnect?: HostWhereInput | boolean
    delete?: HostWhereInput | boolean
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutUserInput, HostUpdateWithoutUserInput>, HostUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type WishlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type StoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryCreateWithoutUserInput, StoryUncheckedCreateWithoutUserInput> | StoryCreateWithoutUserInput[] | StoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUserInput | StoryCreateOrConnectWithoutUserInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutUserInput | StoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryCreateManyUserInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutUserInput | StoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutUserInput | StoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type StoryLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryLikeCreateWithoutUserInput, StoryLikeUncheckedCreateWithoutUserInput> | StoryLikeCreateWithoutUserInput[] | StoryLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutUserInput | StoryLikeCreateOrConnectWithoutUserInput[]
    upsert?: StoryLikeUpsertWithWhereUniqueWithoutUserInput | StoryLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryLikeCreateManyUserInputEnvelope
    set?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    disconnect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    delete?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    update?: StoryLikeUpdateWithWhereUniqueWithoutUserInput | StoryLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryLikeUpdateManyWithWhereWithoutUserInput | StoryLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryLikeScalarWhereInput | StoryLikeScalarWhereInput[]
  }

  export type StoryCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryCommentCreateWithoutUserInput, StoryCommentUncheckedCreateWithoutUserInput> | StoryCommentCreateWithoutUserInput[] | StoryCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutUserInput | StoryCommentCreateOrConnectWithoutUserInput[]
    upsert?: StoryCommentUpsertWithWhereUniqueWithoutUserInput | StoryCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryCommentCreateManyUserInputEnvelope
    set?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    disconnect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    delete?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    update?: StoryCommentUpdateWithWhereUniqueWithoutUserInput | StoryCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryCommentUpdateManyWithWhereWithoutUserInput | StoryCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryCommentScalarWhereInput | StoryCommentScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    upsert?: ReferralUpsertWithoutRefereeInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutRefereeInput, ReferralUpdateWithoutRefereeInput>, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type HostUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HostCreateWithoutUserInput, HostUncheckedCreateWithoutUserInput>
    connectOrCreate?: HostCreateOrConnectWithoutUserInput
    upsert?: HostUpsertWithoutUserInput
    disconnect?: HostWhereInput | boolean
    delete?: HostWhereInput | boolean
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutUserInput, HostUpdateWithoutUserInput>, HostUncheckedUpdateWithoutUserInput>
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type WishlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryCreateWithoutUserInput, StoryUncheckedCreateWithoutUserInput> | StoryCreateWithoutUserInput[] | StoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUserInput | StoryCreateOrConnectWithoutUserInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutUserInput | StoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryCreateManyUserInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutUserInput | StoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutUserInput | StoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type StoryLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryLikeCreateWithoutUserInput, StoryLikeUncheckedCreateWithoutUserInput> | StoryLikeCreateWithoutUserInput[] | StoryLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutUserInput | StoryLikeCreateOrConnectWithoutUserInput[]
    upsert?: StoryLikeUpsertWithWhereUniqueWithoutUserInput | StoryLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryLikeCreateManyUserInputEnvelope
    set?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    disconnect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    delete?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    update?: StoryLikeUpdateWithWhereUniqueWithoutUserInput | StoryLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryLikeUpdateManyWithWhereWithoutUserInput | StoryLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryLikeScalarWhereInput | StoryLikeScalarWhereInput[]
  }

  export type StoryCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoryCommentCreateWithoutUserInput, StoryCommentUncheckedCreateWithoutUserInput> | StoryCommentCreateWithoutUserInput[] | StoryCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutUserInput | StoryCommentCreateOrConnectWithoutUserInput[]
    upsert?: StoryCommentUpsertWithWhereUniqueWithoutUserInput | StoryCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoryCommentCreateManyUserInputEnvelope
    set?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    disconnect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    delete?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    update?: StoryCommentUpdateWithWhereUniqueWithoutUserInput | StoryCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoryCommentUpdateManyWithWhereWithoutUserInput | StoryCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoryCommentScalarWhereInput | StoryCommentScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    upsert?: ReferralUpsertWithoutRefereeInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutRefereeInput, ReferralUpdateWithoutRefereeInput>, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type UserCreateNestedOneWithoutHostInput = {
    create?: XOR<UserCreateWithoutHostInput, UserUncheckedCreateWithoutHostInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostInput
    connect?: UserWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutHostsInput = {
    create?: XOR<CountryCreateWithoutHostsInput, CountryUncheckedCreateWithoutHostsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutHostsInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutHostsInput = {
    create?: XOR<CityCreateWithoutHostsInput, CityUncheckedCreateWithoutHostsInput>
    connectOrCreate?: CityCreateOrConnectWithoutHostsInput
    connect?: CityWhereUniqueInput
  }

  export type HostLanguageCreateNestedManyWithoutHostInput = {
    create?: XOR<HostLanguageCreateWithoutHostInput, HostLanguageUncheckedCreateWithoutHostInput> | HostLanguageCreateWithoutHostInput[] | HostLanguageUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutHostInput | HostLanguageCreateOrConnectWithoutHostInput[]
    createMany?: HostLanguageCreateManyHostInputEnvelope
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutHostInput = {
    create?: XOR<ServiceCreateWithoutHostInput, ServiceUncheckedCreateWithoutHostInput> | ServiceCreateWithoutHostInput[] | ServiceUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutHostInput | ServiceCreateOrConnectWithoutHostInput[]
    createMany?: ServiceCreateManyHostInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type BlockedDateCreateNestedManyWithoutHostInput = {
    create?: XOR<BlockedDateCreateWithoutHostInput, BlockedDateUncheckedCreateWithoutHostInput> | BlockedDateCreateWithoutHostInput[] | BlockedDateUncheckedCreateWithoutHostInput[]
    connectOrCreate?: BlockedDateCreateOrConnectWithoutHostInput | BlockedDateCreateOrConnectWithoutHostInput[]
    createMany?: BlockedDateCreateManyHostInputEnvelope
    connect?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
  }

  export type HostBadgeCreateNestedManyWithoutHostInput = {
    create?: XOR<HostBadgeCreateWithoutHostInput, HostBadgeUncheckedCreateWithoutHostInput> | HostBadgeCreateWithoutHostInput[] | HostBadgeUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostBadgeCreateOrConnectWithoutHostInput | HostBadgeCreateOrConnectWithoutHostInput[]
    createMany?: HostBadgeCreateManyHostInputEnvelope
    connect?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutHostInput = {
    create?: XOR<ReviewCreateWithoutHostInput, ReviewUncheckedCreateWithoutHostInput> | ReviewCreateWithoutHostInput[] | ReviewUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHostInput | ReviewCreateOrConnectWithoutHostInput[]
    createMany?: ReviewCreateManyHostInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PhotographerSkillCreateNestedManyWithoutHostInput = {
    create?: XOR<PhotographerSkillCreateWithoutHostInput, PhotographerSkillUncheckedCreateWithoutHostInput> | PhotographerSkillCreateWithoutHostInput[] | PhotographerSkillUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerSkillCreateOrConnectWithoutHostInput | PhotographerSkillCreateOrConnectWithoutHostInput[]
    createMany?: PhotographerSkillCreateManyHostInputEnvelope
    connect?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
  }

  export type PhotographerGearCreateNestedManyWithoutHostInput = {
    create?: XOR<PhotographerGearCreateWithoutHostInput, PhotographerGearUncheckedCreateWithoutHostInput> | PhotographerGearCreateWithoutHostInput[] | PhotographerGearUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerGearCreateOrConnectWithoutHostInput | PhotographerGearCreateOrConnectWithoutHostInput[]
    createMany?: PhotographerGearCreateManyHostInputEnvelope
    connect?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
  }

  export type HostLanguageUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<HostLanguageCreateWithoutHostInput, HostLanguageUncheckedCreateWithoutHostInput> | HostLanguageCreateWithoutHostInput[] | HostLanguageUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutHostInput | HostLanguageCreateOrConnectWithoutHostInput[]
    createMany?: HostLanguageCreateManyHostInputEnvelope
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<ServiceCreateWithoutHostInput, ServiceUncheckedCreateWithoutHostInput> | ServiceCreateWithoutHostInput[] | ServiceUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutHostInput | ServiceCreateOrConnectWithoutHostInput[]
    createMany?: ServiceCreateManyHostInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type BlockedDateUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<BlockedDateCreateWithoutHostInput, BlockedDateUncheckedCreateWithoutHostInput> | BlockedDateCreateWithoutHostInput[] | BlockedDateUncheckedCreateWithoutHostInput[]
    connectOrCreate?: BlockedDateCreateOrConnectWithoutHostInput | BlockedDateCreateOrConnectWithoutHostInput[]
    createMany?: BlockedDateCreateManyHostInputEnvelope
    connect?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
  }

  export type HostBadgeUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<HostBadgeCreateWithoutHostInput, HostBadgeUncheckedCreateWithoutHostInput> | HostBadgeCreateWithoutHostInput[] | HostBadgeUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostBadgeCreateOrConnectWithoutHostInput | HostBadgeCreateOrConnectWithoutHostInput[]
    createMany?: HostBadgeCreateManyHostInputEnvelope
    connect?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<ReviewCreateWithoutHostInput, ReviewUncheckedCreateWithoutHostInput> | ReviewCreateWithoutHostInput[] | ReviewUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHostInput | ReviewCreateOrConnectWithoutHostInput[]
    createMany?: ReviewCreateManyHostInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PhotographerSkillUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<PhotographerSkillCreateWithoutHostInput, PhotographerSkillUncheckedCreateWithoutHostInput> | PhotographerSkillCreateWithoutHostInput[] | PhotographerSkillUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerSkillCreateOrConnectWithoutHostInput | PhotographerSkillCreateOrConnectWithoutHostInput[]
    createMany?: PhotographerSkillCreateManyHostInputEnvelope
    connect?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
  }

  export type PhotographerGearUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<PhotographerGearCreateWithoutHostInput, PhotographerGearUncheckedCreateWithoutHostInput> | PhotographerGearCreateWithoutHostInput[] | PhotographerGearUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerGearCreateOrConnectWithoutHostInput | PhotographerGearCreateOrConnectWithoutHostInput[]
    createMany?: PhotographerGearCreateManyHostInputEnvelope
    connect?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutHostNestedInput = {
    create?: XOR<UserCreateWithoutHostInput, UserUncheckedCreateWithoutHostInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostInput
    upsert?: UserUpsertWithoutHostInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHostInput, UserUpdateWithoutHostInput>, UserUncheckedUpdateWithoutHostInput>
  }

  export type CountryUpdateOneRequiredWithoutHostsNestedInput = {
    create?: XOR<CountryCreateWithoutHostsInput, CountryUncheckedCreateWithoutHostsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutHostsInput
    upsert?: CountryUpsertWithoutHostsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutHostsInput, CountryUpdateWithoutHostsInput>, CountryUncheckedUpdateWithoutHostsInput>
  }

  export type CityUpdateOneRequiredWithoutHostsNestedInput = {
    create?: XOR<CityCreateWithoutHostsInput, CityUncheckedCreateWithoutHostsInput>
    connectOrCreate?: CityCreateOrConnectWithoutHostsInput
    upsert?: CityUpsertWithoutHostsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutHostsInput, CityUpdateWithoutHostsInput>, CityUncheckedUpdateWithoutHostsInput>
  }

  export type HostLanguageUpdateManyWithoutHostNestedInput = {
    create?: XOR<HostLanguageCreateWithoutHostInput, HostLanguageUncheckedCreateWithoutHostInput> | HostLanguageCreateWithoutHostInput[] | HostLanguageUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutHostInput | HostLanguageCreateOrConnectWithoutHostInput[]
    upsert?: HostLanguageUpsertWithWhereUniqueWithoutHostInput | HostLanguageUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: HostLanguageCreateManyHostInputEnvelope
    set?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    disconnect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    delete?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    update?: HostLanguageUpdateWithWhereUniqueWithoutHostInput | HostLanguageUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: HostLanguageUpdateManyWithWhereWithoutHostInput | HostLanguageUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: HostLanguageScalarWhereInput | HostLanguageScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutHostNestedInput = {
    create?: XOR<ServiceCreateWithoutHostInput, ServiceUncheckedCreateWithoutHostInput> | ServiceCreateWithoutHostInput[] | ServiceUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutHostInput | ServiceCreateOrConnectWithoutHostInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutHostInput | ServiceUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: ServiceCreateManyHostInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutHostInput | ServiceUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutHostInput | ServiceUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type BlockedDateUpdateManyWithoutHostNestedInput = {
    create?: XOR<BlockedDateCreateWithoutHostInput, BlockedDateUncheckedCreateWithoutHostInput> | BlockedDateCreateWithoutHostInput[] | BlockedDateUncheckedCreateWithoutHostInput[]
    connectOrCreate?: BlockedDateCreateOrConnectWithoutHostInput | BlockedDateCreateOrConnectWithoutHostInput[]
    upsert?: BlockedDateUpsertWithWhereUniqueWithoutHostInput | BlockedDateUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: BlockedDateCreateManyHostInputEnvelope
    set?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    disconnect?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    delete?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    connect?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    update?: BlockedDateUpdateWithWhereUniqueWithoutHostInput | BlockedDateUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: BlockedDateUpdateManyWithWhereWithoutHostInput | BlockedDateUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: BlockedDateScalarWhereInput | BlockedDateScalarWhereInput[]
  }

  export type HostBadgeUpdateManyWithoutHostNestedInput = {
    create?: XOR<HostBadgeCreateWithoutHostInput, HostBadgeUncheckedCreateWithoutHostInput> | HostBadgeCreateWithoutHostInput[] | HostBadgeUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostBadgeCreateOrConnectWithoutHostInput | HostBadgeCreateOrConnectWithoutHostInput[]
    upsert?: HostBadgeUpsertWithWhereUniqueWithoutHostInput | HostBadgeUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: HostBadgeCreateManyHostInputEnvelope
    set?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    disconnect?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    delete?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    connect?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    update?: HostBadgeUpdateWithWhereUniqueWithoutHostInput | HostBadgeUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: HostBadgeUpdateManyWithWhereWithoutHostInput | HostBadgeUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: HostBadgeScalarWhereInput | HostBadgeScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutHostNestedInput = {
    create?: XOR<ReviewCreateWithoutHostInput, ReviewUncheckedCreateWithoutHostInput> | ReviewCreateWithoutHostInput[] | ReviewUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHostInput | ReviewCreateOrConnectWithoutHostInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutHostInput | ReviewUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: ReviewCreateManyHostInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutHostInput | ReviewUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutHostInput | ReviewUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PhotographerSkillUpdateManyWithoutHostNestedInput = {
    create?: XOR<PhotographerSkillCreateWithoutHostInput, PhotographerSkillUncheckedCreateWithoutHostInput> | PhotographerSkillCreateWithoutHostInput[] | PhotographerSkillUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerSkillCreateOrConnectWithoutHostInput | PhotographerSkillCreateOrConnectWithoutHostInput[]
    upsert?: PhotographerSkillUpsertWithWhereUniqueWithoutHostInput | PhotographerSkillUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: PhotographerSkillCreateManyHostInputEnvelope
    set?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    disconnect?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    delete?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    connect?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    update?: PhotographerSkillUpdateWithWhereUniqueWithoutHostInput | PhotographerSkillUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: PhotographerSkillUpdateManyWithWhereWithoutHostInput | PhotographerSkillUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: PhotographerSkillScalarWhereInput | PhotographerSkillScalarWhereInput[]
  }

  export type PhotographerGearUpdateManyWithoutHostNestedInput = {
    create?: XOR<PhotographerGearCreateWithoutHostInput, PhotographerGearUncheckedCreateWithoutHostInput> | PhotographerGearCreateWithoutHostInput[] | PhotographerGearUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerGearCreateOrConnectWithoutHostInput | PhotographerGearCreateOrConnectWithoutHostInput[]
    upsert?: PhotographerGearUpsertWithWhereUniqueWithoutHostInput | PhotographerGearUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: PhotographerGearCreateManyHostInputEnvelope
    set?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    disconnect?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    delete?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    connect?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    update?: PhotographerGearUpdateWithWhereUniqueWithoutHostInput | PhotographerGearUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: PhotographerGearUpdateManyWithWhereWithoutHostInput | PhotographerGearUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: PhotographerGearScalarWhereInput | PhotographerGearScalarWhereInput[]
  }

  export type HostLanguageUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<HostLanguageCreateWithoutHostInput, HostLanguageUncheckedCreateWithoutHostInput> | HostLanguageCreateWithoutHostInput[] | HostLanguageUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostLanguageCreateOrConnectWithoutHostInput | HostLanguageCreateOrConnectWithoutHostInput[]
    upsert?: HostLanguageUpsertWithWhereUniqueWithoutHostInput | HostLanguageUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: HostLanguageCreateManyHostInputEnvelope
    set?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    disconnect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    delete?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    connect?: HostLanguageWhereUniqueInput | HostLanguageWhereUniqueInput[]
    update?: HostLanguageUpdateWithWhereUniqueWithoutHostInput | HostLanguageUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: HostLanguageUpdateManyWithWhereWithoutHostInput | HostLanguageUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: HostLanguageScalarWhereInput | HostLanguageScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<ServiceCreateWithoutHostInput, ServiceUncheckedCreateWithoutHostInput> | ServiceCreateWithoutHostInput[] | ServiceUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutHostInput | ServiceCreateOrConnectWithoutHostInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutHostInput | ServiceUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: ServiceCreateManyHostInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutHostInput | ServiceUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutHostInput | ServiceUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type BlockedDateUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<BlockedDateCreateWithoutHostInput, BlockedDateUncheckedCreateWithoutHostInput> | BlockedDateCreateWithoutHostInput[] | BlockedDateUncheckedCreateWithoutHostInput[]
    connectOrCreate?: BlockedDateCreateOrConnectWithoutHostInput | BlockedDateCreateOrConnectWithoutHostInput[]
    upsert?: BlockedDateUpsertWithWhereUniqueWithoutHostInput | BlockedDateUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: BlockedDateCreateManyHostInputEnvelope
    set?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    disconnect?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    delete?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    connect?: BlockedDateWhereUniqueInput | BlockedDateWhereUniqueInput[]
    update?: BlockedDateUpdateWithWhereUniqueWithoutHostInput | BlockedDateUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: BlockedDateUpdateManyWithWhereWithoutHostInput | BlockedDateUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: BlockedDateScalarWhereInput | BlockedDateScalarWhereInput[]
  }

  export type HostBadgeUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<HostBadgeCreateWithoutHostInput, HostBadgeUncheckedCreateWithoutHostInput> | HostBadgeCreateWithoutHostInput[] | HostBadgeUncheckedCreateWithoutHostInput[]
    connectOrCreate?: HostBadgeCreateOrConnectWithoutHostInput | HostBadgeCreateOrConnectWithoutHostInput[]
    upsert?: HostBadgeUpsertWithWhereUniqueWithoutHostInput | HostBadgeUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: HostBadgeCreateManyHostInputEnvelope
    set?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    disconnect?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    delete?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    connect?: HostBadgeWhereUniqueInput | HostBadgeWhereUniqueInput[]
    update?: HostBadgeUpdateWithWhereUniqueWithoutHostInput | HostBadgeUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: HostBadgeUpdateManyWithWhereWithoutHostInput | HostBadgeUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: HostBadgeScalarWhereInput | HostBadgeScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<ReviewCreateWithoutHostInput, ReviewUncheckedCreateWithoutHostInput> | ReviewCreateWithoutHostInput[] | ReviewUncheckedCreateWithoutHostInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHostInput | ReviewCreateOrConnectWithoutHostInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutHostInput | ReviewUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: ReviewCreateManyHostInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutHostInput | ReviewUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutHostInput | ReviewUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<PhotographerSkillCreateWithoutHostInput, PhotographerSkillUncheckedCreateWithoutHostInput> | PhotographerSkillCreateWithoutHostInput[] | PhotographerSkillUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerSkillCreateOrConnectWithoutHostInput | PhotographerSkillCreateOrConnectWithoutHostInput[]
    upsert?: PhotographerSkillUpsertWithWhereUniqueWithoutHostInput | PhotographerSkillUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: PhotographerSkillCreateManyHostInputEnvelope
    set?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    disconnect?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    delete?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    connect?: PhotographerSkillWhereUniqueInput | PhotographerSkillWhereUniqueInput[]
    update?: PhotographerSkillUpdateWithWhereUniqueWithoutHostInput | PhotographerSkillUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: PhotographerSkillUpdateManyWithWhereWithoutHostInput | PhotographerSkillUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: PhotographerSkillScalarWhereInput | PhotographerSkillScalarWhereInput[]
  }

  export type PhotographerGearUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<PhotographerGearCreateWithoutHostInput, PhotographerGearUncheckedCreateWithoutHostInput> | PhotographerGearCreateWithoutHostInput[] | PhotographerGearUncheckedCreateWithoutHostInput[]
    connectOrCreate?: PhotographerGearCreateOrConnectWithoutHostInput | PhotographerGearCreateOrConnectWithoutHostInput[]
    upsert?: PhotographerGearUpsertWithWhereUniqueWithoutHostInput | PhotographerGearUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: PhotographerGearCreateManyHostInputEnvelope
    set?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    disconnect?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    delete?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    connect?: PhotographerGearWhereUniqueInput | PhotographerGearWhereUniqueInput[]
    update?: PhotographerGearUpdateWithWhereUniqueWithoutHostInput | PhotographerGearUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: PhotographerGearUpdateManyWithWhereWithoutHostInput | PhotographerGearUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: PhotographerGearScalarWhereInput | PhotographerGearScalarWhereInput[]
  }

  export type HostCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<HostCreateWithoutLanguagesInput, HostUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: HostCreateOrConnectWithoutLanguagesInput
    connect?: HostWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutHostsInput = {
    create?: XOR<LanguageCreateWithoutHostsInput, LanguageUncheckedCreateWithoutHostsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutHostsInput
    connect?: LanguageWhereUniqueInput
  }

  export type HostUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<HostCreateWithoutLanguagesInput, HostUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: HostCreateOrConnectWithoutLanguagesInput
    upsert?: HostUpsertWithoutLanguagesInput
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutLanguagesInput, HostUpdateWithoutLanguagesInput>, HostUncheckedUpdateWithoutLanguagesInput>
  }

  export type LanguageUpdateOneRequiredWithoutHostsNestedInput = {
    create?: XOR<LanguageCreateWithoutHostsInput, LanguageUncheckedCreateWithoutHostsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutHostsInput
    upsert?: LanguageUpsertWithoutHostsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutHostsInput, LanguageUpdateWithoutHostsInput>, LanguageUncheckedUpdateWithoutHostsInput>
  }

  export type HostCreateNestedOneWithoutPhotographerSkillsInput = {
    create?: XOR<HostCreateWithoutPhotographerSkillsInput, HostUncheckedCreateWithoutPhotographerSkillsInput>
    connectOrCreate?: HostCreateOrConnectWithoutPhotographerSkillsInput
    connect?: HostWhereUniqueInput
  }

  export type HostUpdateOneRequiredWithoutPhotographerSkillsNestedInput = {
    create?: XOR<HostCreateWithoutPhotographerSkillsInput, HostUncheckedCreateWithoutPhotographerSkillsInput>
    connectOrCreate?: HostCreateOrConnectWithoutPhotographerSkillsInput
    upsert?: HostUpsertWithoutPhotographerSkillsInput
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutPhotographerSkillsInput, HostUpdateWithoutPhotographerSkillsInput>, HostUncheckedUpdateWithoutPhotographerSkillsInput>
  }

  export type HostCreateNestedOneWithoutPhotographerGearsInput = {
    create?: XOR<HostCreateWithoutPhotographerGearsInput, HostUncheckedCreateWithoutPhotographerGearsInput>
    connectOrCreate?: HostCreateOrConnectWithoutPhotographerGearsInput
    connect?: HostWhereUniqueInput
  }

  export type HostUpdateOneRequiredWithoutPhotographerGearsNestedInput = {
    create?: XOR<HostCreateWithoutPhotographerGearsInput, HostUncheckedCreateWithoutPhotographerGearsInput>
    connectOrCreate?: HostCreateOrConnectWithoutPhotographerGearsInput
    upsert?: HostUpsertWithoutPhotographerGearsInput
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutPhotographerGearsInput, HostUpdateWithoutPhotographerGearsInput>, HostUncheckedUpdateWithoutPhotographerGearsInput>
  }

  export type ServiceCreatetagsInput = {
    set: string[]
  }

  export type ServiceCreateimagesInput = {
    set: string[]
  }

  export type HostCreateNestedOneWithoutServicesInput = {
    create?: XOR<HostCreateWithoutServicesInput, HostUncheckedCreateWithoutServicesInput>
    connectOrCreate?: HostCreateOrConnectWithoutServicesInput
    connect?: HostWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type WishlistCreateNestedManyWithoutServiceInput = {
    create?: XOR<WishlistCreateWithoutServiceInput, WishlistUncheckedCreateWithoutServiceInput> | WishlistCreateWithoutServiceInput[] | WishlistUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutServiceInput | WishlistCreateOrConnectWithoutServiceInput[]
    createMany?: WishlistCreateManyServiceInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type ItineraryCreateNestedManyWithoutServiceInput = {
    create?: XOR<ItineraryCreateWithoutServiceInput, ItineraryUncheckedCreateWithoutServiceInput> | ItineraryCreateWithoutServiceInput[] | ItineraryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutServiceInput | ItineraryCreateOrConnectWithoutServiceInput[]
    createMany?: ItineraryCreateManyServiceInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type WishlistUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<WishlistCreateWithoutServiceInput, WishlistUncheckedCreateWithoutServiceInput> | WishlistCreateWithoutServiceInput[] | WishlistUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutServiceInput | WishlistCreateOrConnectWithoutServiceInput[]
    createMany?: WishlistCreateManyServiceInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ItineraryCreateWithoutServiceInput, ItineraryUncheckedCreateWithoutServiceInput> | ItineraryCreateWithoutServiceInput[] | ItineraryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutServiceInput | ItineraryCreateOrConnectWithoutServiceInput[]
    createMany?: ItineraryCreateManyServiceInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type EnumCurrencyCodeFieldUpdateOperationsInput = {
    set?: $Enums.CurrencyCode
  }

  export type ServiceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ServiceUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HostUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<HostCreateWithoutServicesInput, HostUncheckedCreateWithoutServicesInput>
    connectOrCreate?: HostCreateOrConnectWithoutServicesInput
    upsert?: HostUpsertWithoutServicesInput
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutServicesInput, HostUpdateWithoutServicesInput>, HostUncheckedUpdateWithoutServicesInput>
  }

  export type BookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type WishlistUpdateManyWithoutServiceNestedInput = {
    create?: XOR<WishlistCreateWithoutServiceInput, WishlistUncheckedCreateWithoutServiceInput> | WishlistCreateWithoutServiceInput[] | WishlistUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutServiceInput | WishlistCreateOrConnectWithoutServiceInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutServiceInput | WishlistUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: WishlistCreateManyServiceInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutServiceInput | WishlistUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutServiceInput | WishlistUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type ItineraryUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ItineraryCreateWithoutServiceInput, ItineraryUncheckedCreateWithoutServiceInput> | ItineraryCreateWithoutServiceInput[] | ItineraryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutServiceInput | ItineraryCreateOrConnectWithoutServiceInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutServiceInput | ItineraryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ItineraryCreateManyServiceInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutServiceInput | ItineraryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutServiceInput | ItineraryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type WishlistUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<WishlistCreateWithoutServiceInput, WishlistUncheckedCreateWithoutServiceInput> | WishlistCreateWithoutServiceInput[] | WishlistUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutServiceInput | WishlistCreateOrConnectWithoutServiceInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutServiceInput | WishlistUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: WishlistCreateManyServiceInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutServiceInput | WishlistUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutServiceInput | WishlistUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ItineraryCreateWithoutServiceInput, ItineraryUncheckedCreateWithoutServiceInput> | ItineraryCreateWithoutServiceInput[] | ItineraryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutServiceInput | ItineraryCreateOrConnectWithoutServiceInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutServiceInput | ItineraryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ItineraryCreateManyServiceInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutServiceInput | ItineraryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutServiceInput | ItineraryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutItinerariesInput = {
    create?: XOR<ServiceCreateWithoutItinerariesInput, ServiceUncheckedCreateWithoutItinerariesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutItinerariesInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutItinerariesNestedInput = {
    create?: XOR<ServiceCreateWithoutItinerariesInput, ServiceUncheckedCreateWithoutItinerariesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutItinerariesInput
    upsert?: ServiceUpsertWithoutItinerariesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutItinerariesInput, ServiceUpdateWithoutItinerariesInput>, ServiceUncheckedUpdateWithoutItinerariesInput>
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type PromoCodeCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutBookingsInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    connect?: ReviewWhereUniqueInput
  }

  export type CurrencyConversionLogCreateNestedOneWithoutBookingInput = {
    create?: XOR<CurrencyConversionLogCreateWithoutBookingInput, CurrencyConversionLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CurrencyConversionLogCreateOrConnectWithoutBookingInput
    connect?: CurrencyConversionLogWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    connect?: ReviewWhereUniqueInput
  }

  export type CurrencyConversionLogUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<CurrencyConversionLogCreateWithoutBookingInput, CurrencyConversionLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CurrencyConversionLogCreateOrConnectWithoutBookingInput
    connect?: CurrencyConversionLogWhereUniqueInput
  }

  export type EnumContactMethodFieldUpdateOperationsInput = {
    set?: $Enums.ContactMethod
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type PromoCodeUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutBookingsInput
    upsert?: PromoCodeUpsertWithoutBookingsInput
    disconnect?: PromoCodeWhereInput | boolean
    delete?: PromoCodeWhereInput | boolean
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutBookingsInput, PromoCodeUpdateWithoutBookingsInput>, PromoCodeUncheckedUpdateWithoutBookingsInput>
  }

  export type ReviewUpdateOneWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    upsert?: ReviewUpsertWithoutBookingInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutBookingInput, ReviewUpdateWithoutBookingInput>, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type CurrencyConversionLogUpdateOneWithoutBookingNestedInput = {
    create?: XOR<CurrencyConversionLogCreateWithoutBookingInput, CurrencyConversionLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CurrencyConversionLogCreateOrConnectWithoutBookingInput
    upsert?: CurrencyConversionLogUpsertWithoutBookingInput
    disconnect?: CurrencyConversionLogWhereInput | boolean
    delete?: CurrencyConversionLogWhereInput | boolean
    connect?: CurrencyConversionLogWhereUniqueInput
    update?: XOR<XOR<CurrencyConversionLogUpdateToOneWithWhereWithoutBookingInput, CurrencyConversionLogUpdateWithoutBookingInput>, CurrencyConversionLogUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    upsert?: ReviewUpsertWithoutBookingInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutBookingInput, ReviewUpdateWithoutBookingInput>, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type CurrencyConversionLogUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<CurrencyConversionLogCreateWithoutBookingInput, CurrencyConversionLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CurrencyConversionLogCreateOrConnectWithoutBookingInput
    upsert?: CurrencyConversionLogUpsertWithoutBookingInput
    disconnect?: CurrencyConversionLogWhereInput | boolean
    delete?: CurrencyConversionLogWhereInput | boolean
    connect?: CurrencyConversionLogWhereUniqueInput
    update?: XOR<XOR<CurrencyConversionLogUpdateToOneWithWhereWithoutBookingInput, CurrencyConversionLogUpdateWithoutBookingInput>, CurrencyConversionLogUncheckedUpdateWithoutBookingInput>
  }

  export type BookingCreateNestedOneWithoutCurrencyConversionLogInput = {
    create?: XOR<BookingCreateWithoutCurrencyConversionLogInput, BookingUncheckedCreateWithoutCurrencyConversionLogInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCurrencyConversionLogInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutCurrencyConversionLogNestedInput = {
    create?: XOR<BookingCreateWithoutCurrencyConversionLogInput, BookingUncheckedCreateWithoutCurrencyConversionLogInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCurrencyConversionLogInput
    upsert?: BookingUpsertWithoutCurrencyConversionLogInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCurrencyConversionLogInput, BookingUpdateWithoutCurrencyConversionLogInput>, BookingUncheckedUpdateWithoutCurrencyConversionLogInput>
  }

  export type BookingCreateNestedOneWithoutReviewInput = {
    create?: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewInput
    connect?: BookingWhereUniqueInput
  }

  export type HostCreateNestedOneWithoutReviewsInput = {
    create?: XOR<HostCreateWithoutReviewsInput, HostUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: HostCreateOrConnectWithoutReviewsInput
    connect?: HostWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewInput
    upsert?: BookingUpsertWithoutReviewInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutReviewInput, BookingUpdateWithoutReviewInput>, BookingUncheckedUpdateWithoutReviewInput>
  }

  export type HostUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<HostCreateWithoutReviewsInput, HostUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: HostCreateOrConnectWithoutReviewsInput
    upsert?: HostUpsertWithoutReviewsInput
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutReviewsInput, HostUpdateWithoutReviewsInput>, HostUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutWishlistInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutWishlistInput = {
    create?: XOR<ServiceCreateWithoutWishlistInput, ServiceUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutWishlistInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    upsert?: UserUpsertWithoutWishlistInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishlistInput, UserUpdateWithoutWishlistInput>, UserUncheckedUpdateWithoutWishlistInput>
  }

  export type ServiceUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<ServiceCreateWithoutWishlistInput, ServiceUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutWishlistInput
    upsert?: ServiceUpsertWithoutWishlistInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutWishlistInput, ServiceUpdateWithoutWishlistInput>, ServiceUncheckedUpdateWithoutWishlistInput>
  }

  export type BookingCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPromoCodeInput | BookingUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPromoCodeInput | BookingUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPromoCodeInput | BookingUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput> | BookingCreateWithoutPromoCodeInput[] | BookingUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromoCodeInput | BookingCreateOrConnectWithoutPromoCodeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPromoCodeInput | BookingUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: BookingCreateManyPromoCodeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPromoCodeInput | BookingUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPromoCodeInput | BookingUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type HostCreateNestedOneWithoutBadgesInput = {
    create?: XOR<HostCreateWithoutBadgesInput, HostUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: HostCreateOrConnectWithoutBadgesInput
    connect?: HostWhereUniqueInput
  }

  export type HostUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<HostCreateWithoutBadgesInput, HostUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: HostCreateOrConnectWithoutBadgesInput
    upsert?: HostUpsertWithoutBadgesInput
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutBadgesInput, HostUpdateWithoutBadgesInput>, HostUncheckedUpdateWithoutBadgesInput>
  }

  export type HostCreateNestedOneWithoutBlockedDatesInput = {
    create?: XOR<HostCreateWithoutBlockedDatesInput, HostUncheckedCreateWithoutBlockedDatesInput>
    connectOrCreate?: HostCreateOrConnectWithoutBlockedDatesInput
    connect?: HostWhereUniqueInput
  }

  export type HostUpdateOneRequiredWithoutBlockedDatesNestedInput = {
    create?: XOR<HostCreateWithoutBlockedDatesInput, HostUncheckedCreateWithoutBlockedDatesInput>
    connectOrCreate?: HostCreateOrConnectWithoutBlockedDatesInput
    upsert?: HostUpsertWithoutBlockedDatesInput
    connect?: HostWhereUniqueInput
    update?: XOR<XOR<HostUpdateToOneWithWhereWithoutBlockedDatesInput, HostUpdateWithoutBlockedDatesInput>, HostUncheckedUpdateWithoutBlockedDatesInput>
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateOneRequiredWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput
    upsert?: UserUpsertWithoutReferredByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredByInput, UserUpdateWithoutReferredByInput>, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserCreateNestedOneWithoutStoriesInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type StoryLikeCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryLikeCreateWithoutStoryInput, StoryLikeUncheckedCreateWithoutStoryInput> | StoryLikeCreateWithoutStoryInput[] | StoryLikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutStoryInput | StoryLikeCreateOrConnectWithoutStoryInput[]
    createMany?: StoryLikeCreateManyStoryInputEnvelope
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
  }

  export type StoryCommentCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryCommentCreateWithoutStoryInput, StoryCommentUncheckedCreateWithoutStoryInput> | StoryCommentCreateWithoutStoryInput[] | StoryCommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutStoryInput | StoryCommentCreateOrConnectWithoutStoryInput[]
    createMany?: StoryCommentCreateManyStoryInputEnvelope
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
  }

  export type StoryLikeUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryLikeCreateWithoutStoryInput, StoryLikeUncheckedCreateWithoutStoryInput> | StoryLikeCreateWithoutStoryInput[] | StoryLikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutStoryInput | StoryLikeCreateOrConnectWithoutStoryInput[]
    createMany?: StoryLikeCreateManyStoryInputEnvelope
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
  }

  export type StoryCommentUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryCommentCreateWithoutStoryInput, StoryCommentUncheckedCreateWithoutStoryInput> | StoryCommentCreateWithoutStoryInput[] | StoryCommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutStoryInput | StoryCommentCreateOrConnectWithoutStoryInput[]
    createMany?: StoryCommentCreateManyStoryInputEnvelope
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
  }

  export type EnumStoryTypeFieldUpdateOperationsInput = {
    set?: $Enums.StoryType
  }

  export type UserUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    upsert?: UserUpsertWithoutStoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoriesInput, UserUpdateWithoutStoriesInput>, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type StoryLikeUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryLikeCreateWithoutStoryInput, StoryLikeUncheckedCreateWithoutStoryInput> | StoryLikeCreateWithoutStoryInput[] | StoryLikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutStoryInput | StoryLikeCreateOrConnectWithoutStoryInput[]
    upsert?: StoryLikeUpsertWithWhereUniqueWithoutStoryInput | StoryLikeUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryLikeCreateManyStoryInputEnvelope
    set?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    disconnect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    delete?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    update?: StoryLikeUpdateWithWhereUniqueWithoutStoryInput | StoryLikeUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryLikeUpdateManyWithWhereWithoutStoryInput | StoryLikeUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryLikeScalarWhereInput | StoryLikeScalarWhereInput[]
  }

  export type StoryCommentUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryCommentCreateWithoutStoryInput, StoryCommentUncheckedCreateWithoutStoryInput> | StoryCommentCreateWithoutStoryInput[] | StoryCommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutStoryInput | StoryCommentCreateOrConnectWithoutStoryInput[]
    upsert?: StoryCommentUpsertWithWhereUniqueWithoutStoryInput | StoryCommentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryCommentCreateManyStoryInputEnvelope
    set?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    disconnect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    delete?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    update?: StoryCommentUpdateWithWhereUniqueWithoutStoryInput | StoryCommentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryCommentUpdateManyWithWhereWithoutStoryInput | StoryCommentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryCommentScalarWhereInput | StoryCommentScalarWhereInput[]
  }

  export type StoryLikeUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryLikeCreateWithoutStoryInput, StoryLikeUncheckedCreateWithoutStoryInput> | StoryLikeCreateWithoutStoryInput[] | StoryLikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryLikeCreateOrConnectWithoutStoryInput | StoryLikeCreateOrConnectWithoutStoryInput[]
    upsert?: StoryLikeUpsertWithWhereUniqueWithoutStoryInput | StoryLikeUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryLikeCreateManyStoryInputEnvelope
    set?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    disconnect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    delete?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    connect?: StoryLikeWhereUniqueInput | StoryLikeWhereUniqueInput[]
    update?: StoryLikeUpdateWithWhereUniqueWithoutStoryInput | StoryLikeUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryLikeUpdateManyWithWhereWithoutStoryInput | StoryLikeUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryLikeScalarWhereInput | StoryLikeScalarWhereInput[]
  }

  export type StoryCommentUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryCommentCreateWithoutStoryInput, StoryCommentUncheckedCreateWithoutStoryInput> | StoryCommentCreateWithoutStoryInput[] | StoryCommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryCommentCreateOrConnectWithoutStoryInput | StoryCommentCreateOrConnectWithoutStoryInput[]
    upsert?: StoryCommentUpsertWithWhereUniqueWithoutStoryInput | StoryCommentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryCommentCreateManyStoryInputEnvelope
    set?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    disconnect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    delete?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    connect?: StoryCommentWhereUniqueInput | StoryCommentWhereUniqueInput[]
    update?: StoryCommentUpdateWithWhereUniqueWithoutStoryInput | StoryCommentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryCommentUpdateManyWithWhereWithoutStoryInput | StoryCommentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryCommentScalarWhereInput | StoryCommentScalarWhereInput[]
  }

  export type StoryCreateNestedOneWithoutLikesInput = {
    create?: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
    connectOrCreate?: StoryCreateOrConnectWithoutLikesInput
    connect?: StoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStoryLikesInput = {
    create?: XOR<UserCreateWithoutStoryLikesInput, UserUncheckedCreateWithoutStoryLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryLikesInput
    connect?: UserWhereUniqueInput
  }

  export type StoryUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
    connectOrCreate?: StoryCreateOrConnectWithoutLikesInput
    upsert?: StoryUpsertWithoutLikesInput
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutLikesInput, StoryUpdateWithoutLikesInput>, StoryUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutStoryLikesNestedInput = {
    create?: XOR<UserCreateWithoutStoryLikesInput, UserUncheckedCreateWithoutStoryLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryLikesInput
    upsert?: UserUpsertWithoutStoryLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoryLikesInput, UserUpdateWithoutStoryLikesInput>, UserUncheckedUpdateWithoutStoryLikesInput>
  }

  export type StoryCreateNestedOneWithoutCommentsInput = {
    create?: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutCommentsInput
    connect?: StoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStoryCommentsInput = {
    create?: XOR<UserCreateWithoutStoryCommentsInput, UserUncheckedCreateWithoutStoryCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type StoryUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutCommentsInput
    upsert?: StoryUpsertWithoutCommentsInput
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutCommentsInput, StoryUpdateWithoutCommentsInput>, StoryUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutStoryCommentsNestedInput = {
    create?: XOR<UserCreateWithoutStoryCommentsInput, UserUncheckedCreateWithoutStoryCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoryCommentsInput
    upsert?: UserUpsertWithoutStoryCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoryCommentsInput, UserUpdateWithoutStoryCommentsInput>, UserUncheckedUpdateWithoutStoryCommentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedEnumCurrencyCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeFilter<$PrismaModel> | $Enums.CurrencyCode
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyCodeFilter<$PrismaModel>
    _max?: NestedEnumCurrencyCodeFilter<$PrismaModel>
  }

  export type NestedEnumContactMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodFilter<$PrismaModel> | $Enums.ContactMethod
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumContactMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodWithAggregatesFilter<$PrismaModel> | $Enums.ContactMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactMethodFilter<$PrismaModel>
    _max?: NestedEnumContactMethodFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryType | EnumStoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryTypeFilter<$PrismaModel> | $Enums.StoryType
  }

  export type NestedEnumStoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryType | EnumStoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryType[] | ListEnumStoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryTypeFilter<$PrismaModel>
    _max?: NestedEnumStoryTypeFilter<$PrismaModel>
  }

  export type CityCreateWithoutTopDestinationInput = {
    id?: string
    name: string
    lat: number
    lng: number
    country: CountryCreateNestedOneWithoutCitiesInput
    users?: UserCreateNestedManyWithoutCityInput
    hosts?: HostCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutTopDestinationInput = {
    id?: string
    name: string
    countryId: string
    lat: number
    lng: number
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    hosts?: HostUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutTopDestinationInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutTopDestinationInput, CityUncheckedCreateWithoutTopDestinationInput>
  }

  export type CityUpsertWithoutTopDestinationInput = {
    update: XOR<CityUpdateWithoutTopDestinationInput, CityUncheckedUpdateWithoutTopDestinationInput>
    create: XOR<CityCreateWithoutTopDestinationInput, CityUncheckedCreateWithoutTopDestinationInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutTopDestinationInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutTopDestinationInput, CityUncheckedUpdateWithoutTopDestinationInput>
  }

  export type CityUpdateWithoutTopDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    hosts?: HostUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutTopDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    hosts?: HostUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateWithoutCountryInput = {
    id?: string
    name: string
    lat: number
    lng: number
    users?: UserCreateNestedManyWithoutCityInput
    hosts?: HostCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationCreateNestedOneWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    lat: number
    lng: number
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    hosts?: HostUncheckedCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationUncheckedCreateNestedOneWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCountryInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutCountryInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutCountryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput>
  }

  export type UserCreateManyCountryInputEnvelope = {
    data: UserCreateManyCountryInput | UserCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type HostCreateWithoutCountryInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutCountryInput = {
    id?: string
    userId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutCountryInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutCountryInput, HostUncheckedCreateWithoutCountryInput>
  }

  export type HostCreateManyCountryInputEnvelope = {
    data: HostCreateManyCountryInput | HostCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    countryId?: StringFilter<"City"> | string
    lat?: FloatFilter<"City"> | number
    lng?: FloatFilter<"City"> | number
  }

  export type UserUpsertWithWhereUniqueWithoutCountryInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCountryInput, UserUncheckedUpdateWithoutCountryInput>
    create: XOR<UserCreateWithoutCountryInput, UserUncheckedCreateWithoutCountryInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCountryInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCountryInput, UserUncheckedUpdateWithoutCountryInput>
  }

  export type UserUpdateManyWithWhereWithoutCountryInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCountryInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    countryId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: StringNullableFilter<"User"> | string | null
  }

  export type HostUpsertWithWhereUniqueWithoutCountryInput = {
    where: HostWhereUniqueInput
    update: XOR<HostUpdateWithoutCountryInput, HostUncheckedUpdateWithoutCountryInput>
    create: XOR<HostCreateWithoutCountryInput, HostUncheckedCreateWithoutCountryInput>
  }

  export type HostUpdateWithWhereUniqueWithoutCountryInput = {
    where: HostWhereUniqueInput
    data: XOR<HostUpdateWithoutCountryInput, HostUncheckedUpdateWithoutCountryInput>
  }

  export type HostUpdateManyWithWhereWithoutCountryInput = {
    where: HostScalarWhereInput
    data: XOR<HostUpdateManyMutationInput, HostUncheckedUpdateManyWithoutCountryInput>
  }

  export type HostScalarWhereInput = {
    AND?: HostScalarWhereInput | HostScalarWhereInput[]
    OR?: HostScalarWhereInput[]
    NOT?: HostScalarWhereInput | HostScalarWhereInput[]
    id?: StringFilter<"Host"> | string
    userId?: StringFilter<"Host"> | string
    countryId?: StringFilter<"Host"> | string
    cityId?: StringFilter<"Host"> | string
    lat?: FloatFilter<"Host"> | number
    lng?: FloatFilter<"Host"> | number
    isGuide?: BoolFilter<"Host"> | boolean
    isPhotographer?: BoolFilter<"Host"> | boolean
    profileVideo?: StringNullableFilter<"Host"> | string | null
    isVerified?: BoolFilter<"Host"> | boolean
    createdAt?: DateTimeFilter<"Host"> | Date | string
  }

  export type CountryCreateWithoutCitiesInput = {
    id?: string
    name: string
    code: string
    users?: UserCreateNestedManyWithoutCountryInput
    hosts?: HostCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    code: string
    users?: UserUncheckedCreateNestedManyWithoutCountryInput
    hosts?: HostUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type HostCreateWithoutCityInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutCityInput = {
    id?: string
    userId: string
    countryId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutCityInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutCityInput, HostUncheckedCreateWithoutCityInput>
  }

  export type HostCreateManyCityInputEnvelope = {
    data: HostCreateManyCityInput | HostCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type TopDestinationCreateWithoutCityInput = {
    id?: string
    order: number
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type TopDestinationUncheckedCreateWithoutCityInput = {
    id?: string
    order: number
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type TopDestinationCreateOrConnectWithoutCityInput = {
    where: TopDestinationWhereUniqueInput
    create: XOR<TopDestinationCreateWithoutCityInput, TopDestinationUncheckedCreateWithoutCityInput>
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutCountryNestedInput
    hosts?: HostUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutCountryNestedInput
    hosts?: HostUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCityInput>
  }

  export type HostUpsertWithWhereUniqueWithoutCityInput = {
    where: HostWhereUniqueInput
    update: XOR<HostUpdateWithoutCityInput, HostUncheckedUpdateWithoutCityInput>
    create: XOR<HostCreateWithoutCityInput, HostUncheckedCreateWithoutCityInput>
  }

  export type HostUpdateWithWhereUniqueWithoutCityInput = {
    where: HostWhereUniqueInput
    data: XOR<HostUpdateWithoutCityInput, HostUncheckedUpdateWithoutCityInput>
  }

  export type HostUpdateManyWithWhereWithoutCityInput = {
    where: HostScalarWhereInput
    data: XOR<HostUpdateManyMutationInput, HostUncheckedUpdateManyWithoutCityInput>
  }

  export type TopDestinationUpsertWithoutCityInput = {
    update: XOR<TopDestinationUpdateWithoutCityInput, TopDestinationUncheckedUpdateWithoutCityInput>
    create: XOR<TopDestinationCreateWithoutCityInput, TopDestinationUncheckedCreateWithoutCityInput>
    where?: TopDestinationWhereInput
  }

  export type TopDestinationUpdateToOneWithWhereWithoutCityInput = {
    where?: TopDestinationWhereInput
    data: XOR<TopDestinationUpdateWithoutCityInput, TopDestinationUncheckedUpdateWithoutCityInput>
  }

  export type TopDestinationUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopDestinationUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostLanguageCreateWithoutLanguageInput = {
    id?: string
    host: HostCreateNestedOneWithoutLanguagesInput
  }

  export type HostLanguageUncheckedCreateWithoutLanguageInput = {
    id?: string
    hostId: string
  }

  export type HostLanguageCreateOrConnectWithoutLanguageInput = {
    where: HostLanguageWhereUniqueInput
    create: XOR<HostLanguageCreateWithoutLanguageInput, HostLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type HostLanguageCreateManyLanguageInputEnvelope = {
    data: HostLanguageCreateManyLanguageInput | HostLanguageCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type HostLanguageUpsertWithWhereUniqueWithoutLanguageInput = {
    where: HostLanguageWhereUniqueInput
    update: XOR<HostLanguageUpdateWithoutLanguageInput, HostLanguageUncheckedUpdateWithoutLanguageInput>
    create: XOR<HostLanguageCreateWithoutLanguageInput, HostLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type HostLanguageUpdateWithWhereUniqueWithoutLanguageInput = {
    where: HostLanguageWhereUniqueInput
    data: XOR<HostLanguageUpdateWithoutLanguageInput, HostLanguageUncheckedUpdateWithoutLanguageInput>
  }

  export type HostLanguageUpdateManyWithWhereWithoutLanguageInput = {
    where: HostLanguageScalarWhereInput
    data: XOR<HostLanguageUpdateManyMutationInput, HostLanguageUncheckedUpdateManyWithoutLanguageInput>
  }

  export type HostLanguageScalarWhereInput = {
    AND?: HostLanguageScalarWhereInput | HostLanguageScalarWhereInput[]
    OR?: HostLanguageScalarWhereInput[]
    NOT?: HostLanguageScalarWhereInput | HostLanguageScalarWhereInput[]
    id?: StringFilter<"HostLanguage"> | string
    hostId?: StringFilter<"HostLanguage"> | string
    languageId?: StringFilter<"HostLanguage"> | string
  }

  export type CountryCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    cities?: CityCreateNestedManyWithoutCountryInput
    hosts?: HostCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    hosts?: HostUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutUsersInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutUsersInput, CountryUncheckedCreateWithoutUsersInput>
  }

  export type CityCreateWithoutUsersInput = {
    id?: string
    name: string
    lat: number
    lng: number
    country: CountryCreateNestedOneWithoutCitiesInput
    hosts?: HostCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationCreateNestedOneWithoutCityInput
  }

  export type CityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    countryId: string
    lat: number
    lng: number
    hosts?: HostUncheckedCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationUncheckedCreateNestedOneWithoutCityInput
  }

  export type CityCreateOrConnectWithoutUsersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type HostCreateWithoutUserInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutUserInput = {
    id?: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutUserInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutUserInput, HostUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutWishlistInput
  }

  export type WishlistUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type WishlistCreateOrConnectWithoutUserInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistCreateManyUserInputEnvelope = {
    data: WishlistCreateManyUserInput | WishlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoryCreateWithoutUserInput = {
    id?: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    likes?: StoryLikeCreateNestedManyWithoutStoryInput
    comments?: StoryCommentCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    likes?: StoryLikeUncheckedCreateNestedManyWithoutStoryInput
    comments?: StoryCommentUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutUserInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutUserInput, StoryUncheckedCreateWithoutUserInput>
  }

  export type StoryCreateManyUserInputEnvelope = {
    data: StoryCreateManyUserInput | StoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoryLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    story: StoryCreateNestedOneWithoutLikesInput
  }

  export type StoryLikeUncheckedCreateWithoutUserInput = {
    id?: string
    storyId: string
    createdAt?: Date | string
  }

  export type StoryLikeCreateOrConnectWithoutUserInput = {
    where: StoryLikeWhereUniqueInput
    create: XOR<StoryLikeCreateWithoutUserInput, StoryLikeUncheckedCreateWithoutUserInput>
  }

  export type StoryLikeCreateManyUserInputEnvelope = {
    data: StoryLikeCreateManyUserInput | StoryLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoryCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    story: StoryCreateNestedOneWithoutCommentsInput
  }

  export type StoryCommentUncheckedCreateWithoutUserInput = {
    id?: string
    storyId: string
    content: string
    createdAt?: Date | string
  }

  export type StoryCommentCreateOrConnectWithoutUserInput = {
    where: StoryCommentWhereUniqueInput
    create: XOR<StoryCommentCreateWithoutUserInput, StoryCommentUncheckedCreateWithoutUserInput>
  }

  export type StoryCommentCreateManyUserInputEnvelope = {
    data: StoryCommentCreateManyUserInput | StoryCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    usedAt?: Date | string | null
    referee: UserCreateNestedOneWithoutReferredByInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    refereeId: string
    usedAt?: Date | string | null
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutRefereeInput = {
    id?: string
    usedAt?: Date | string | null
    referrer: UserCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutRefereeInput = {
    id?: string
    referrerId: string
    usedAt?: Date | string | null
  }

  export type ReferralCreateOrConnectWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
  }

  export type CountryUpsertWithoutUsersInput = {
    update: XOR<CountryUpdateWithoutUsersInput, CountryUncheckedUpdateWithoutUsersInput>
    create: XOR<CountryCreateWithoutUsersInput, CountryUncheckedCreateWithoutUsersInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutUsersInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutUsersInput, CountryUncheckedUpdateWithoutUsersInput>
  }

  export type CountryUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    hosts?: HostUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    hosts?: HostUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithoutUsersInput = {
    update: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutUsersInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
  }

  export type CityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    hosts?: HostUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUpdateOneWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    hosts?: HostUncheckedUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUncheckedUpdateOneWithoutCityNestedInput
  }

  export type HostUpsertWithoutUserInput = {
    update: XOR<HostUpdateWithoutUserInput, HostUncheckedUpdateWithoutUserInput>
    create: XOR<HostCreateWithoutUserInput, HostUncheckedCreateWithoutUserInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutUserInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutUserInput, HostUncheckedUpdateWithoutUserInput>
  }

  export type HostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    serviceId?: StringFilter<"Booking"> | string
    date?: DateTimeFilter<"Booking"> | Date | string
    adults?: IntFilter<"Booking"> | number
    children?: IntFilter<"Booking"> | number
    contactMethod?: EnumContactMethodFilter<"Booking"> | $Enums.ContactMethod
    contactDetail?: StringFilter<"Booking"> | string
    meetingPoint?: StringNullableFilter<"Booking"> | string | null
    totalPrice?: IntFilter<"Booking"> | number
    currency?: EnumCurrencyCodeFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    promoCodeId?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type WishlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    update: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    data: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
  }

  export type WishlistUpdateManyWithWhereWithoutUserInput = {
    where: WishlistScalarWhereInput
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyWithoutUserInput>
  }

  export type WishlistScalarWhereInput = {
    AND?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    OR?: WishlistScalarWhereInput[]
    NOT?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    id?: StringFilter<"Wishlist"> | string
    userId?: StringFilter<"Wishlist"> | string
    serviceId?: StringFilter<"Wishlist"> | string
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
  }

  export type StoryUpsertWithWhereUniqueWithoutUserInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutUserInput, StoryUncheckedUpdateWithoutUserInput>
    create: XOR<StoryCreateWithoutUserInput, StoryUncheckedCreateWithoutUserInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutUserInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutUserInput, StoryUncheckedUpdateWithoutUserInput>
  }

  export type StoryUpdateManyWithWhereWithoutUserInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutUserInput>
  }

  export type StoryScalarWhereInput = {
    AND?: StoryScalarWhereInput | StoryScalarWhereInput[]
    OR?: StoryScalarWhereInput[]
    NOT?: StoryScalarWhereInput | StoryScalarWhereInput[]
    id?: StringFilter<"Story"> | string
    userId?: StringFilter<"Story"> | string
    type?: EnumStoryTypeFilter<"Story"> | $Enums.StoryType
    title?: StringFilter<"Story"> | string
    content?: StringFilter<"Story"> | string
    imageUrl?: StringFilter<"Story"> | string
    location?: StringFilter<"Story"> | string
    postedAt?: DateTimeFilter<"Story"> | Date | string
    createdAt?: DateTimeFilter<"Story"> | Date | string
  }

  export type StoryLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: StoryLikeWhereUniqueInput
    update: XOR<StoryLikeUpdateWithoutUserInput, StoryLikeUncheckedUpdateWithoutUserInput>
    create: XOR<StoryLikeCreateWithoutUserInput, StoryLikeUncheckedCreateWithoutUserInput>
  }

  export type StoryLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: StoryLikeWhereUniqueInput
    data: XOR<StoryLikeUpdateWithoutUserInput, StoryLikeUncheckedUpdateWithoutUserInput>
  }

  export type StoryLikeUpdateManyWithWhereWithoutUserInput = {
    where: StoryLikeScalarWhereInput
    data: XOR<StoryLikeUpdateManyMutationInput, StoryLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type StoryLikeScalarWhereInput = {
    AND?: StoryLikeScalarWhereInput | StoryLikeScalarWhereInput[]
    OR?: StoryLikeScalarWhereInput[]
    NOT?: StoryLikeScalarWhereInput | StoryLikeScalarWhereInput[]
    id?: StringFilter<"StoryLike"> | string
    storyId?: StringFilter<"StoryLike"> | string
    userId?: StringFilter<"StoryLike"> | string
    createdAt?: DateTimeFilter<"StoryLike"> | Date | string
  }

  export type StoryCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: StoryCommentWhereUniqueInput
    update: XOR<StoryCommentUpdateWithoutUserInput, StoryCommentUncheckedUpdateWithoutUserInput>
    create: XOR<StoryCommentCreateWithoutUserInput, StoryCommentUncheckedCreateWithoutUserInput>
  }

  export type StoryCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: StoryCommentWhereUniqueInput
    data: XOR<StoryCommentUpdateWithoutUserInput, StoryCommentUncheckedUpdateWithoutUserInput>
  }

  export type StoryCommentUpdateManyWithWhereWithoutUserInput = {
    where: StoryCommentScalarWhereInput
    data: XOR<StoryCommentUpdateManyMutationInput, StoryCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type StoryCommentScalarWhereInput = {
    AND?: StoryCommentScalarWhereInput | StoryCommentScalarWhereInput[]
    OR?: StoryCommentScalarWhereInput[]
    NOT?: StoryCommentScalarWhereInput | StoryCommentScalarWhereInput[]
    id?: StringFilter<"StoryComment"> | string
    storyId?: StringFilter<"StoryComment"> | string
    userId?: StringFilter<"StoryComment"> | string
    content?: StringFilter<"StoryComment"> | string
    createdAt?: DateTimeFilter<"StoryComment"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringFilter<"Referral"> | string
    usedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
  }

  export type ReferralUpsertWithoutRefereeInput = {
    update: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutRefereeInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutHostInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutHostInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutHostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHostInput, UserUncheckedCreateWithoutHostInput>
  }

  export type CountryCreateWithoutHostsInput = {
    id?: string
    name: string
    code: string
    cities?: CityCreateNestedManyWithoutCountryInput
    users?: UserCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutHostsInput = {
    id?: string
    name: string
    code: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    users?: UserUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutHostsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutHostsInput, CountryUncheckedCreateWithoutHostsInput>
  }

  export type CityCreateWithoutHostsInput = {
    id?: string
    name: string
    lat: number
    lng: number
    country: CountryCreateNestedOneWithoutCitiesInput
    users?: UserCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationCreateNestedOneWithoutCityInput
  }

  export type CityUncheckedCreateWithoutHostsInput = {
    id?: string
    name: string
    countryId: string
    lat: number
    lng: number
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    topDestination?: TopDestinationUncheckedCreateNestedOneWithoutCityInput
  }

  export type CityCreateOrConnectWithoutHostsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutHostsInput, CityUncheckedCreateWithoutHostsInput>
  }

  export type HostLanguageCreateWithoutHostInput = {
    id?: string
    language: LanguageCreateNestedOneWithoutHostsInput
  }

  export type HostLanguageUncheckedCreateWithoutHostInput = {
    id?: string
    languageId: string
  }

  export type HostLanguageCreateOrConnectWithoutHostInput = {
    where: HostLanguageWhereUniqueInput
    create: XOR<HostLanguageCreateWithoutHostInput, HostLanguageUncheckedCreateWithoutHostInput>
  }

  export type HostLanguageCreateManyHostInputEnvelope = {
    data: HostLanguageCreateManyHostInput | HostLanguageCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutHostInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutServiceInput
    wishlist?: WishlistCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutHostInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutHostInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutHostInput, ServiceUncheckedCreateWithoutHostInput>
  }

  export type ServiceCreateManyHostInputEnvelope = {
    data: ServiceCreateManyHostInput | ServiceCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type BlockedDateCreateWithoutHostInput = {
    id?: string
    date: Date | string
  }

  export type BlockedDateUncheckedCreateWithoutHostInput = {
    id?: string
    date: Date | string
  }

  export type BlockedDateCreateOrConnectWithoutHostInput = {
    where: BlockedDateWhereUniqueInput
    create: XOR<BlockedDateCreateWithoutHostInput, BlockedDateUncheckedCreateWithoutHostInput>
  }

  export type BlockedDateCreateManyHostInputEnvelope = {
    data: BlockedDateCreateManyHostInput | BlockedDateCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type HostBadgeCreateWithoutHostInput = {
    id?: string
    type: string
    createdAt?: Date | string
  }

  export type HostBadgeUncheckedCreateWithoutHostInput = {
    id?: string
    type: string
    createdAt?: Date | string
  }

  export type HostBadgeCreateOrConnectWithoutHostInput = {
    where: HostBadgeWhereUniqueInput
    create: XOR<HostBadgeCreateWithoutHostInput, HostBadgeUncheckedCreateWithoutHostInput>
  }

  export type HostBadgeCreateManyHostInputEnvelope = {
    data: HostBadgeCreateManyHostInput | HostBadgeCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutHostInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutHostInput = {
    id?: string
    bookingId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutHostInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutHostInput, ReviewUncheckedCreateWithoutHostInput>
  }

  export type ReviewCreateManyHostInputEnvelope = {
    data: ReviewCreateManyHostInput | ReviewCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type PhotographerSkillCreateWithoutHostInput = {
    id?: string
    skill: string
  }

  export type PhotographerSkillUncheckedCreateWithoutHostInput = {
    id?: string
    skill: string
  }

  export type PhotographerSkillCreateOrConnectWithoutHostInput = {
    where: PhotographerSkillWhereUniqueInput
    create: XOR<PhotographerSkillCreateWithoutHostInput, PhotographerSkillUncheckedCreateWithoutHostInput>
  }

  export type PhotographerSkillCreateManyHostInputEnvelope = {
    data: PhotographerSkillCreateManyHostInput | PhotographerSkillCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type PhotographerGearCreateWithoutHostInput = {
    id?: string
    gearType: string
    name: string
  }

  export type PhotographerGearUncheckedCreateWithoutHostInput = {
    id?: string
    gearType: string
    name: string
  }

  export type PhotographerGearCreateOrConnectWithoutHostInput = {
    where: PhotographerGearWhereUniqueInput
    create: XOR<PhotographerGearCreateWithoutHostInput, PhotographerGearUncheckedCreateWithoutHostInput>
  }

  export type PhotographerGearCreateManyHostInputEnvelope = {
    data: PhotographerGearCreateManyHostInput | PhotographerGearCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHostInput = {
    update: XOR<UserUpdateWithoutHostInput, UserUncheckedUpdateWithoutHostInput>
    create: XOR<UserCreateWithoutHostInput, UserUncheckedCreateWithoutHostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHostInput, UserUncheckedUpdateWithoutHostInput>
  }

  export type UserUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type CountryUpsertWithoutHostsInput = {
    update: XOR<CountryUpdateWithoutHostsInput, CountryUncheckedUpdateWithoutHostsInput>
    create: XOR<CountryCreateWithoutHostsInput, CountryUncheckedCreateWithoutHostsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutHostsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutHostsInput, CountryUncheckedUpdateWithoutHostsInput>
  }

  export type CountryUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    users?: UserUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    users?: UserUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithoutHostsInput = {
    update: XOR<CityUpdateWithoutHostsInput, CityUncheckedUpdateWithoutHostsInput>
    create: XOR<CityCreateWithoutHostsInput, CityUncheckedCreateWithoutHostsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutHostsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutHostsInput, CityUncheckedUpdateWithoutHostsInput>
  }

  export type CityUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUpdateOneWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUncheckedUpdateOneWithoutCityNestedInput
  }

  export type HostLanguageUpsertWithWhereUniqueWithoutHostInput = {
    where: HostLanguageWhereUniqueInput
    update: XOR<HostLanguageUpdateWithoutHostInput, HostLanguageUncheckedUpdateWithoutHostInput>
    create: XOR<HostLanguageCreateWithoutHostInput, HostLanguageUncheckedCreateWithoutHostInput>
  }

  export type HostLanguageUpdateWithWhereUniqueWithoutHostInput = {
    where: HostLanguageWhereUniqueInput
    data: XOR<HostLanguageUpdateWithoutHostInput, HostLanguageUncheckedUpdateWithoutHostInput>
  }

  export type HostLanguageUpdateManyWithWhereWithoutHostInput = {
    where: HostLanguageScalarWhereInput
    data: XOR<HostLanguageUpdateManyMutationInput, HostLanguageUncheckedUpdateManyWithoutHostInput>
  }

  export type ServiceUpsertWithWhereUniqueWithoutHostInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutHostInput, ServiceUncheckedUpdateWithoutHostInput>
    create: XOR<ServiceCreateWithoutHostInput, ServiceUncheckedCreateWithoutHostInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutHostInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutHostInput, ServiceUncheckedUpdateWithoutHostInput>
  }

  export type ServiceUpdateManyWithWhereWithoutHostInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutHostInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    hostId?: StringFilter<"Service"> | string
    title?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    price?: IntFilter<"Service"> | number
    currency?: EnumCurrencyCodeFilter<"Service"> | $Enums.CurrencyCode
    duration?: IntFilter<"Service"> | number
    tags?: StringNullableListFilter<"Service">
    images?: StringNullableListFilter<"Service">
    createdAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type BlockedDateUpsertWithWhereUniqueWithoutHostInput = {
    where: BlockedDateWhereUniqueInput
    update: XOR<BlockedDateUpdateWithoutHostInput, BlockedDateUncheckedUpdateWithoutHostInput>
    create: XOR<BlockedDateCreateWithoutHostInput, BlockedDateUncheckedCreateWithoutHostInput>
  }

  export type BlockedDateUpdateWithWhereUniqueWithoutHostInput = {
    where: BlockedDateWhereUniqueInput
    data: XOR<BlockedDateUpdateWithoutHostInput, BlockedDateUncheckedUpdateWithoutHostInput>
  }

  export type BlockedDateUpdateManyWithWhereWithoutHostInput = {
    where: BlockedDateScalarWhereInput
    data: XOR<BlockedDateUpdateManyMutationInput, BlockedDateUncheckedUpdateManyWithoutHostInput>
  }

  export type BlockedDateScalarWhereInput = {
    AND?: BlockedDateScalarWhereInput | BlockedDateScalarWhereInput[]
    OR?: BlockedDateScalarWhereInput[]
    NOT?: BlockedDateScalarWhereInput | BlockedDateScalarWhereInput[]
    id?: StringFilter<"BlockedDate"> | string
    hostId?: StringFilter<"BlockedDate"> | string
    date?: DateTimeFilter<"BlockedDate"> | Date | string
  }

  export type HostBadgeUpsertWithWhereUniqueWithoutHostInput = {
    where: HostBadgeWhereUniqueInput
    update: XOR<HostBadgeUpdateWithoutHostInput, HostBadgeUncheckedUpdateWithoutHostInput>
    create: XOR<HostBadgeCreateWithoutHostInput, HostBadgeUncheckedCreateWithoutHostInput>
  }

  export type HostBadgeUpdateWithWhereUniqueWithoutHostInput = {
    where: HostBadgeWhereUniqueInput
    data: XOR<HostBadgeUpdateWithoutHostInput, HostBadgeUncheckedUpdateWithoutHostInput>
  }

  export type HostBadgeUpdateManyWithWhereWithoutHostInput = {
    where: HostBadgeScalarWhereInput
    data: XOR<HostBadgeUpdateManyMutationInput, HostBadgeUncheckedUpdateManyWithoutHostInput>
  }

  export type HostBadgeScalarWhereInput = {
    AND?: HostBadgeScalarWhereInput | HostBadgeScalarWhereInput[]
    OR?: HostBadgeScalarWhereInput[]
    NOT?: HostBadgeScalarWhereInput | HostBadgeScalarWhereInput[]
    id?: StringFilter<"HostBadge"> | string
    hostId?: StringFilter<"HostBadge"> | string
    type?: StringFilter<"HostBadge"> | string
    createdAt?: DateTimeFilter<"HostBadge"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutHostInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutHostInput, ReviewUncheckedUpdateWithoutHostInput>
    create: XOR<ReviewCreateWithoutHostInput, ReviewUncheckedCreateWithoutHostInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutHostInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutHostInput, ReviewUncheckedUpdateWithoutHostInput>
  }

  export type ReviewUpdateManyWithWhereWithoutHostInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutHostInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    bookingId?: StringFilter<"Review"> | string
    hostId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type PhotographerSkillUpsertWithWhereUniqueWithoutHostInput = {
    where: PhotographerSkillWhereUniqueInput
    update: XOR<PhotographerSkillUpdateWithoutHostInput, PhotographerSkillUncheckedUpdateWithoutHostInput>
    create: XOR<PhotographerSkillCreateWithoutHostInput, PhotographerSkillUncheckedCreateWithoutHostInput>
  }

  export type PhotographerSkillUpdateWithWhereUniqueWithoutHostInput = {
    where: PhotographerSkillWhereUniqueInput
    data: XOR<PhotographerSkillUpdateWithoutHostInput, PhotographerSkillUncheckedUpdateWithoutHostInput>
  }

  export type PhotographerSkillUpdateManyWithWhereWithoutHostInput = {
    where: PhotographerSkillScalarWhereInput
    data: XOR<PhotographerSkillUpdateManyMutationInput, PhotographerSkillUncheckedUpdateManyWithoutHostInput>
  }

  export type PhotographerSkillScalarWhereInput = {
    AND?: PhotographerSkillScalarWhereInput | PhotographerSkillScalarWhereInput[]
    OR?: PhotographerSkillScalarWhereInput[]
    NOT?: PhotographerSkillScalarWhereInput | PhotographerSkillScalarWhereInput[]
    id?: StringFilter<"PhotographerSkill"> | string
    hostId?: StringFilter<"PhotographerSkill"> | string
    skill?: StringFilter<"PhotographerSkill"> | string
  }

  export type PhotographerGearUpsertWithWhereUniqueWithoutHostInput = {
    where: PhotographerGearWhereUniqueInput
    update: XOR<PhotographerGearUpdateWithoutHostInput, PhotographerGearUncheckedUpdateWithoutHostInput>
    create: XOR<PhotographerGearCreateWithoutHostInput, PhotographerGearUncheckedCreateWithoutHostInput>
  }

  export type PhotographerGearUpdateWithWhereUniqueWithoutHostInput = {
    where: PhotographerGearWhereUniqueInput
    data: XOR<PhotographerGearUpdateWithoutHostInput, PhotographerGearUncheckedUpdateWithoutHostInput>
  }

  export type PhotographerGearUpdateManyWithWhereWithoutHostInput = {
    where: PhotographerGearScalarWhereInput
    data: XOR<PhotographerGearUpdateManyMutationInput, PhotographerGearUncheckedUpdateManyWithoutHostInput>
  }

  export type PhotographerGearScalarWhereInput = {
    AND?: PhotographerGearScalarWhereInput | PhotographerGearScalarWhereInput[]
    OR?: PhotographerGearScalarWhereInput[]
    NOT?: PhotographerGearScalarWhereInput | PhotographerGearScalarWhereInput[]
    id?: StringFilter<"PhotographerGear"> | string
    hostId?: StringFilter<"PhotographerGear"> | string
    gearType?: StringFilter<"PhotographerGear"> | string
    name?: StringFilter<"PhotographerGear"> | string
  }

  export type HostCreateWithoutLanguagesInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutLanguagesInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutLanguagesInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutLanguagesInput, HostUncheckedCreateWithoutLanguagesInput>
  }

  export type LanguageCreateWithoutHostsInput = {
    id?: string
    name: string
  }

  export type LanguageUncheckedCreateWithoutHostsInput = {
    id?: string
    name: string
  }

  export type LanguageCreateOrConnectWithoutHostsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutHostsInput, LanguageUncheckedCreateWithoutHostsInput>
  }

  export type HostUpsertWithoutLanguagesInput = {
    update: XOR<HostUpdateWithoutLanguagesInput, HostUncheckedUpdateWithoutLanguagesInput>
    create: XOR<HostCreateWithoutLanguagesInput, HostUncheckedCreateWithoutLanguagesInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutLanguagesInput, HostUncheckedUpdateWithoutLanguagesInput>
  }

  export type HostUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type LanguageUpsertWithoutHostsInput = {
    update: XOR<LanguageUpdateWithoutHostsInput, LanguageUncheckedUpdateWithoutHostsInput>
    create: XOR<LanguageCreateWithoutHostsInput, LanguageUncheckedCreateWithoutHostsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutHostsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutHostsInput, LanguageUncheckedUpdateWithoutHostsInput>
  }

  export type LanguageUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HostCreateWithoutPhotographerSkillsInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutPhotographerSkillsInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutPhotographerSkillsInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutPhotographerSkillsInput, HostUncheckedCreateWithoutPhotographerSkillsInput>
  }

  export type HostUpsertWithoutPhotographerSkillsInput = {
    update: XOR<HostUpdateWithoutPhotographerSkillsInput, HostUncheckedUpdateWithoutPhotographerSkillsInput>
    create: XOR<HostCreateWithoutPhotographerSkillsInput, HostUncheckedCreateWithoutPhotographerSkillsInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutPhotographerSkillsInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutPhotographerSkillsInput, HostUncheckedUpdateWithoutPhotographerSkillsInput>
  }

  export type HostUpdateWithoutPhotographerSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutPhotographerSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type HostCreateWithoutPhotographerGearsInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutPhotographerGearsInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutPhotographerGearsInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutPhotographerGearsInput, HostUncheckedCreateWithoutPhotographerGearsInput>
  }

  export type HostUpsertWithoutPhotographerGearsInput = {
    update: XOR<HostUpdateWithoutPhotographerGearsInput, HostUncheckedUpdateWithoutPhotographerGearsInput>
    create: XOR<HostCreateWithoutPhotographerGearsInput, HostUncheckedCreateWithoutPhotographerGearsInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutPhotographerGearsInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutPhotographerGearsInput, HostUncheckedUpdateWithoutPhotographerGearsInput>
  }

  export type HostUpdateWithoutPhotographerGearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutPhotographerGearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
  }

  export type HostCreateWithoutServicesInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutServicesInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutServicesInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutServicesInput, HostUncheckedCreateWithoutServicesInput>
  }

  export type BookingCreateWithoutServiceInput = {
    id?: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingCreateManyServiceInputEnvelope = {
    data: BookingCreateManyServiceInput | BookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type WishlistCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistInput
  }

  export type WishlistUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type WishlistCreateOrConnectWithoutServiceInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutServiceInput, WishlistUncheckedCreateWithoutServiceInput>
  }

  export type WishlistCreateManyServiceInputEnvelope = {
    data: WishlistCreateManyServiceInput | WishlistCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutServiceInput = {
    id?: string
    step: number
    title: string
    description: string
    duration: number
  }

  export type ItineraryUncheckedCreateWithoutServiceInput = {
    id?: string
    step: number
    title: string
    description: string
    duration: number
  }

  export type ItineraryCreateOrConnectWithoutServiceInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutServiceInput, ItineraryUncheckedCreateWithoutServiceInput>
  }

  export type ItineraryCreateManyServiceInputEnvelope = {
    data: ItineraryCreateManyServiceInput | ItineraryCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type HostUpsertWithoutServicesInput = {
    update: XOR<HostUpdateWithoutServicesInput, HostUncheckedUpdateWithoutServicesInput>
    create: XOR<HostCreateWithoutServicesInput, HostUncheckedCreateWithoutServicesInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutServicesInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutServicesInput, HostUncheckedUpdateWithoutServicesInput>
  }

  export type HostUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type WishlistUpsertWithWhereUniqueWithoutServiceInput = {
    where: WishlistWhereUniqueInput
    update: XOR<WishlistUpdateWithoutServiceInput, WishlistUncheckedUpdateWithoutServiceInput>
    create: XOR<WishlistCreateWithoutServiceInput, WishlistUncheckedCreateWithoutServiceInput>
  }

  export type WishlistUpdateWithWhereUniqueWithoutServiceInput = {
    where: WishlistWhereUniqueInput
    data: XOR<WishlistUpdateWithoutServiceInput, WishlistUncheckedUpdateWithoutServiceInput>
  }

  export type WishlistUpdateManyWithWhereWithoutServiceInput = {
    where: WishlistScalarWhereInput
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyWithoutServiceInput>
  }

  export type ItineraryUpsertWithWhereUniqueWithoutServiceInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutServiceInput, ItineraryUncheckedUpdateWithoutServiceInput>
    create: XOR<ItineraryCreateWithoutServiceInput, ItineraryUncheckedCreateWithoutServiceInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutServiceInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutServiceInput, ItineraryUncheckedUpdateWithoutServiceInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutServiceInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutServiceInput>
  }

  export type ItineraryScalarWhereInput = {
    AND?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    OR?: ItineraryScalarWhereInput[]
    NOT?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    id?: StringFilter<"Itinerary"> | string
    serviceId?: StringFilter<"Itinerary"> | string
    step?: IntFilter<"Itinerary"> | number
    title?: StringFilter<"Itinerary"> | string
    description?: StringFilter<"Itinerary"> | string
    duration?: IntFilter<"Itinerary"> | number
  }

  export type ServiceCreateWithoutItinerariesInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    host: HostCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
    wishlist?: WishlistCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutItinerariesInput = {
    id?: string
    hostId: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutItinerariesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutItinerariesInput, ServiceUncheckedCreateWithoutItinerariesInput>
  }

  export type ServiceUpsertWithoutItinerariesInput = {
    update: XOR<ServiceUpdateWithoutItinerariesInput, ServiceUncheckedUpdateWithoutItinerariesInput>
    create: XOR<ServiceCreateWithoutItinerariesInput, ServiceUncheckedCreateWithoutItinerariesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutItinerariesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutItinerariesInput, ServiceUncheckedUpdateWithoutItinerariesInput>
  }

  export type ServiceUpdateWithoutItinerariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: HostUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    wishlist?: WishlistUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutItinerariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    host: HostCreateNestedOneWithoutServicesInput
    wishlist?: WishlistCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    hostId: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    wishlist?: WishlistUncheckedCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type PromoCodeCreateWithoutBookingsInput = {
    id?: string
    code: string
    title: string
    description: string
    discountType: string
    amount: number
    validFrom: Date | string
    validUntil: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
  }

  export type PromoCodeUncheckedCreateWithoutBookingsInput = {
    id?: string
    code: string
    title: string
    description: string
    discountType: string
    amount: number
    validFrom: Date | string
    validUntil: Date | string
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
  }

  export type PromoCodeCreateOrConnectWithoutBookingsInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
  }

  export type ReviewCreateWithoutBookingInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    host: HostCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutBookingInput = {
    id?: string
    hostId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type CurrencyConversionLogCreateWithoutBookingInput = {
    id?: string
    sourceCurrency: $Enums.CurrencyCode
    targetCurrency: $Enums.CurrencyCode
    rate: number
    convertedAmount: number
    createdAt?: Date | string
  }

  export type CurrencyConversionLogUncheckedCreateWithoutBookingInput = {
    id?: string
    sourceCurrency: $Enums.CurrencyCode
    targetCurrency: $Enums.CurrencyCode
    rate: number
    convertedAmount: number
    createdAt?: Date | string
  }

  export type CurrencyConversionLogCreateOrConnectWithoutBookingInput = {
    where: CurrencyConversionLogWhereUniqueInput
    create: XOR<CurrencyConversionLogCreateWithoutBookingInput, CurrencyConversionLogUncheckedCreateWithoutBookingInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: HostUpdateOneRequiredWithoutServicesNestedInput
    wishlist?: WishlistUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wishlist?: WishlistUncheckedUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type PromoCodeUpsertWithoutBookingsInput = {
    update: XOR<PromoCodeUpdateWithoutBookingsInput, PromoCodeUncheckedUpdateWithoutBookingsInput>
    create: XOR<PromoCodeCreateWithoutBookingsInput, PromoCodeUncheckedCreateWithoutBookingsInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutBookingsInput, PromoCodeUncheckedUpdateWithoutBookingsInput>
  }

  export type PromoCodeUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromoCodeUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUpsertWithoutBookingInput = {
    update: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutBookingInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: HostUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyConversionLogUpsertWithoutBookingInput = {
    update: XOR<CurrencyConversionLogUpdateWithoutBookingInput, CurrencyConversionLogUncheckedUpdateWithoutBookingInput>
    create: XOR<CurrencyConversionLogCreateWithoutBookingInput, CurrencyConversionLogUncheckedCreateWithoutBookingInput>
    where?: CurrencyConversionLogWhereInput
  }

  export type CurrencyConversionLogUpdateToOneWithWhereWithoutBookingInput = {
    where?: CurrencyConversionLogWhereInput
    data: XOR<CurrencyConversionLogUpdateWithoutBookingInput, CurrencyConversionLogUncheckedUpdateWithoutBookingInput>
  }

  export type CurrencyConversionLogUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    rate?: FloatFieldUpdateOperationsInput | number
    convertedAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyConversionLogUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    targetCurrency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    rate?: FloatFieldUpdateOperationsInput | number
    convertedAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateWithoutCurrencyConversionLogInput = {
    id?: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    review?: ReviewCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCurrencyConversionLogInput = {
    id?: string
    userId: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCurrencyConversionLogInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCurrencyConversionLogInput, BookingUncheckedCreateWithoutCurrencyConversionLogInput>
  }

  export type BookingUpsertWithoutCurrencyConversionLogInput = {
    update: XOR<BookingUpdateWithoutCurrencyConversionLogInput, BookingUncheckedUpdateWithoutCurrencyConversionLogInput>
    create: XOR<BookingCreateWithoutCurrencyConversionLogInput, BookingUncheckedCreateWithoutCurrencyConversionLogInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCurrencyConversionLogInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCurrencyConversionLogInput, BookingUncheckedUpdateWithoutCurrencyConversionLogInput>
  }

  export type BookingUpdateWithoutCurrencyConversionLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCurrencyConversionLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingCreateWithoutReviewInput = {
    id?: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    promoCode?: PromoCodeCreateNestedOneWithoutBookingsInput
    currencyConversionLog?: CurrencyConversionLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
    currencyConversionLog?: CurrencyConversionLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutReviewInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
  }

  export type HostCreateWithoutReviewsInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutReviewsInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutReviewsInput, HostUncheckedCreateWithoutReviewsInput>
  }

  export type BookingUpsertWithoutReviewInput = {
    update: XOR<BookingUpdateWithoutReviewInput, BookingUncheckedUpdateWithoutReviewInput>
    create: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutReviewInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutReviewInput, BookingUncheckedUpdateWithoutReviewInput>
  }

  export type BookingUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    currencyConversionLog?: CurrencyConversionLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyConversionLog?: CurrencyConversionLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type HostUpsertWithoutReviewsInput = {
    update: XOR<HostUpdateWithoutReviewsInput, HostUncheckedUpdateWithoutReviewsInput>
    create: XOR<HostCreateWithoutReviewsInput, HostUncheckedCreateWithoutReviewsInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutReviewsInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutReviewsInput, HostUncheckedUpdateWithoutReviewsInput>
  }

  export type HostUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type UserCreateWithoutWishlistInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutWishlistInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutWishlistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
  }

  export type ServiceCreateWithoutWishlistInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    host: HostCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutWishlistInput = {
    id?: string
    hostId: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutWishlistInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutWishlistInput, ServiceUncheckedCreateWithoutWishlistInput>
  }

  export type UserUpsertWithoutWishlistInput = {
    update: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishlistInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
  }

  export type UserUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type ServiceUpsertWithoutWishlistInput = {
    update: XOR<ServiceUpdateWithoutWishlistInput, ServiceUncheckedUpdateWithoutWishlistInput>
    create: XOR<ServiceCreateWithoutWishlistInput, ServiceUncheckedCreateWithoutWishlistInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutWishlistInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutWishlistInput, ServiceUncheckedUpdateWithoutWishlistInput>
  }

  export type ServiceUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: HostUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BookingCreateWithoutPromoCodeInput = {
    id?: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    userId: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    currencyConversionLog?: CurrencyConversionLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPromoCodeInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput>
  }

  export type BookingCreateManyPromoCodeInputEnvelope = {
    data: BookingCreateManyPromoCodeInput | BookingCreateManyPromoCodeInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPromoCodeInput, BookingUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<BookingCreateWithoutPromoCodeInput, BookingUncheckedCreateWithoutPromoCodeInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPromoCodeInput, BookingUncheckedUpdateWithoutPromoCodeInput>
  }

  export type BookingUpdateManyWithWhereWithoutPromoCodeInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type HostCreateWithoutBadgesInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutBadgesInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    blockedDates?: BlockedDateUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutBadgesInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutBadgesInput, HostUncheckedCreateWithoutBadgesInput>
  }

  export type HostUpsertWithoutBadgesInput = {
    update: XOR<HostUpdateWithoutBadgesInput, HostUncheckedUpdateWithoutBadgesInput>
    create: XOR<HostCreateWithoutBadgesInput, HostUncheckedCreateWithoutBadgesInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutBadgesInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutBadgesInput, HostUncheckedUpdateWithoutBadgesInput>
  }

  export type HostUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type HostCreateWithoutBlockedDatesInput = {
    id?: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHostInput
    country: CountryCreateNestedOneWithoutHostsInput
    city: CityCreateNestedOneWithoutHostsInput
    languages?: HostLanguageCreateNestedManyWithoutHostInput
    services?: ServiceCreateNestedManyWithoutHostInput
    badges?: HostBadgeCreateNestedManyWithoutHostInput
    reviews?: ReviewCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutBlockedDatesInput = {
    id?: string
    userId: string
    countryId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    languages?: HostLanguageUncheckedCreateNestedManyWithoutHostInput
    services?: ServiceUncheckedCreateNestedManyWithoutHostInput
    badges?: HostBadgeUncheckedCreateNestedManyWithoutHostInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHostInput
    photographerSkills?: PhotographerSkillUncheckedCreateNestedManyWithoutHostInput
    photographerGears?: PhotographerGearUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutBlockedDatesInput = {
    where: HostWhereUniqueInput
    create: XOR<HostCreateWithoutBlockedDatesInput, HostUncheckedCreateWithoutBlockedDatesInput>
  }

  export type HostUpsertWithoutBlockedDatesInput = {
    update: XOR<HostUpdateWithoutBlockedDatesInput, HostUncheckedUpdateWithoutBlockedDatesInput>
    create: XOR<HostCreateWithoutBlockedDatesInput, HostUncheckedCreateWithoutBlockedDatesInput>
    where?: HostWhereInput
  }

  export type HostUpdateToOneWithWhereWithoutBlockedDatesInput = {
    where?: HostWhereInput
    data: XOR<HostUpdateWithoutBlockedDatesInput, HostUncheckedUpdateWithoutBlockedDatesInput>
  }

  export type HostUpdateWithoutBlockedDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutBlockedDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type UserUpsertWithoutReferredByInput = {
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type UserCreateWithoutStoriesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutStoriesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
  }

  export type StoryLikeCreateWithoutStoryInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStoryLikesInput
  }

  export type StoryLikeUncheckedCreateWithoutStoryInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type StoryLikeCreateOrConnectWithoutStoryInput = {
    where: StoryLikeWhereUniqueInput
    create: XOR<StoryLikeCreateWithoutStoryInput, StoryLikeUncheckedCreateWithoutStoryInput>
  }

  export type StoryLikeCreateManyStoryInputEnvelope = {
    data: StoryLikeCreateManyStoryInput | StoryLikeCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryCommentCreateWithoutStoryInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStoryCommentsInput
  }

  export type StoryCommentUncheckedCreateWithoutStoryInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type StoryCommentCreateOrConnectWithoutStoryInput = {
    where: StoryCommentWhereUniqueInput
    create: XOR<StoryCommentCreateWithoutStoryInput, StoryCommentUncheckedCreateWithoutStoryInput>
  }

  export type StoryCommentCreateManyStoryInputEnvelope = {
    data: StoryCommentCreateManyStoryInput | StoryCommentCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStoriesInput = {
    update: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type UserUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type StoryLikeUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryLikeWhereUniqueInput
    update: XOR<StoryLikeUpdateWithoutStoryInput, StoryLikeUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryLikeCreateWithoutStoryInput, StoryLikeUncheckedCreateWithoutStoryInput>
  }

  export type StoryLikeUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryLikeWhereUniqueInput
    data: XOR<StoryLikeUpdateWithoutStoryInput, StoryLikeUncheckedUpdateWithoutStoryInput>
  }

  export type StoryLikeUpdateManyWithWhereWithoutStoryInput = {
    where: StoryLikeScalarWhereInput
    data: XOR<StoryLikeUpdateManyMutationInput, StoryLikeUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryCommentUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryCommentWhereUniqueInput
    update: XOR<StoryCommentUpdateWithoutStoryInput, StoryCommentUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryCommentCreateWithoutStoryInput, StoryCommentUncheckedCreateWithoutStoryInput>
  }

  export type StoryCommentUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryCommentWhereUniqueInput
    data: XOR<StoryCommentUpdateWithoutStoryInput, StoryCommentUncheckedUpdateWithoutStoryInput>
  }

  export type StoryCommentUpdateManyWithWhereWithoutStoryInput = {
    where: StoryCommentScalarWhereInput
    data: XOR<StoryCommentUpdateManyMutationInput, StoryCommentUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryCreateWithoutLikesInput = {
    id?: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStoriesInput
    comments?: StoryCommentCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutLikesInput = {
    id?: string
    userId: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    comments?: StoryCommentUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutLikesInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutStoryLikesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutStoryLikesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyComments?: StoryCommentUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutStoryLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoryLikesInput, UserUncheckedCreateWithoutStoryLikesInput>
  }

  export type StoryUpsertWithoutLikesInput = {
    update: XOR<StoryUpdateWithoutLikesInput, StoryUncheckedUpdateWithoutLikesInput>
    create: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutLikesInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutLikesInput, StoryUncheckedUpdateWithoutLikesInput>
  }

  export type StoryUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoriesNestedInput
    comments?: StoryCommentUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: StoryCommentUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UserUpsertWithoutStoryLikesInput = {
    update: XOR<UserUpdateWithoutStoryLikesInput, UserUncheckedUpdateWithoutStoryLikesInput>
    create: XOR<UserCreateWithoutStoryLikesInput, UserUncheckedCreateWithoutStoryLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoryLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoryLikesInput, UserUncheckedUpdateWithoutStoryLikesInput>
  }

  export type UserUpdateWithoutStoryLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutStoryLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type StoryCreateWithoutCommentsInput = {
    id?: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStoriesInput
    likes?: StoryLikeCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
    likes?: StoryLikeUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutCommentsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutStoryCommentsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    country?: CountryCreateNestedOneWithoutUsersInput
    city?: CityCreateNestedOneWithoutUsersInput
    host?: HostCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    stories?: StoryCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutStoryCommentsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
    host?: HostUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    stories?: StoryUncheckedCreateNestedManyWithoutUserInput
    storyLikes?: StoryLikeUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutStoryCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoryCommentsInput, UserUncheckedCreateWithoutStoryCommentsInput>
  }

  export type StoryUpsertWithoutCommentsInput = {
    update: XOR<StoryUpdateWithoutCommentsInput, StoryUncheckedUpdateWithoutCommentsInput>
    create: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutCommentsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutCommentsInput, StoryUncheckedUpdateWithoutCommentsInput>
  }

  export type StoryUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoriesNestedInput
    likes?: StoryLikeUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: StoryLikeUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UserUpsertWithoutStoryCommentsInput = {
    update: XOR<UserUpdateWithoutStoryCommentsInput, UserUncheckedUpdateWithoutStoryCommentsInput>
    create: XOR<UserCreateWithoutStoryCommentsInput, UserUncheckedCreateWithoutStoryCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoryCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoryCommentsInput, UserUncheckedUpdateWithoutStoryCommentsInput>
  }

  export type UserUpdateWithoutStoryCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutStoryCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type CityCreateManyCountryInput = {
    id?: string
    name: string
    lat: number
    lng: number
  }

  export type UserCreateManyCountryInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
  }

  export type HostCreateManyCountryInput = {
    id?: string
    userId: string
    cityId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type CityUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutCityNestedInput
    hosts?: HostUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUpdateOneWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    hosts?: HostUncheckedUpdateManyWithoutCityNestedInput
    topDestination?: TopDestinationUncheckedUpdateOneWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    city?: CityUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HostUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    city?: CityUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCityInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    phone?: string | null
    bio?: string | null
    role?: $Enums.Role
    countryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredById?: string | null
  }

  export type HostCreateManyCityInput = {
    id?: string
    userId: string
    countryId: string
    lat: number
    lng: number
    isGuide?: boolean
    isPhotographer?: boolean
    profileVideo?: string | null
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutUsersNestedInput
    host?: HostUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    stories?: StoryUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    host?: HostUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUserNestedInput
    storyLikes?: StoryLikeUncheckedUpdateManyWithoutUserNestedInput
    storyComments?: StoryCommentUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    countryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HostUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHostNestedInput
    country?: CountryUpdateOneRequiredWithoutHostsNestedInput
    languages?: HostLanguageUpdateManyWithoutHostNestedInput
    services?: ServiceUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUpdateManyWithoutHostNestedInput
    reviews?: ReviewUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languages?: HostLanguageUncheckedUpdateManyWithoutHostNestedInput
    services?: ServiceUncheckedUpdateManyWithoutHostNestedInput
    blockedDates?: BlockedDateUncheckedUpdateManyWithoutHostNestedInput
    badges?: HostBadgeUncheckedUpdateManyWithoutHostNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHostNestedInput
    photographerSkills?: PhotographerSkillUncheckedUpdateManyWithoutHostNestedInput
    photographerGears?: PhotographerGearUncheckedUpdateManyWithoutHostNestedInput
  }

  export type HostUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    isGuide?: BoolFieldUpdateOperationsInput | boolean
    isPhotographer?: BoolFieldUpdateOperationsInput | boolean
    profileVideo?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostLanguageCreateManyLanguageInput = {
    id?: string
    hostId: string
  }

  export type HostLanguageUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    host?: HostUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type HostLanguageUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
  }

  export type HostLanguageUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
  }

  export type WishlistCreateManyUserInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type StoryCreateManyUserInput = {
    id?: string
    type: $Enums.StoryType
    title: string
    content: string
    imageUrl: string
    location: string
    postedAt: Date | string
    createdAt?: Date | string
  }

  export type StoryLikeCreateManyUserInput = {
    id?: string
    storyId: string
    createdAt?: Date | string
  }

  export type StoryCommentCreateManyUserInput = {
    id?: string
    storyId: string
    content: string
    createdAt?: Date | string
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    refereeId: string
    usedAt?: Date | string | null
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: StoryLikeUpdateManyWithoutStoryNestedInput
    comments?: StoryCommentUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: StoryLikeUncheckedUpdateManyWithoutStoryNestedInput
    comments?: StoryCommentUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoryTypeFieldUpdateOperationsInput | $Enums.StoryType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutLikesNestedInput
  }

  export type StoryLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type StoryCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referee?: UserUpdateOneRequiredWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HostLanguageCreateManyHostInput = {
    id?: string
    languageId: string
  }

  export type ServiceCreateManyHostInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ServiceType
    price: number
    currency?: $Enums.CurrencyCode
    duration: number
    tags?: ServiceCreatetagsInput | string[]
    images?: ServiceCreateimagesInput | string[]
    createdAt?: Date | string
  }

  export type BlockedDateCreateManyHostInput = {
    id?: string
    date: Date | string
  }

  export type HostBadgeCreateManyHostInput = {
    id?: string
    type: string
    createdAt?: Date | string
  }

  export type ReviewCreateManyHostInput = {
    id?: string
    bookingId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type PhotographerSkillCreateManyHostInput = {
    id?: string
    skill: string
  }

  export type PhotographerGearCreateManyHostInput = {
    id?: string
    gearType: string
    name: string
  }

  export type HostLanguageUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: LanguageUpdateOneRequiredWithoutHostsNestedInput
  }

  export type HostLanguageUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
  }

  export type HostLanguageUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    wishlist?: WishlistUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutServiceNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    price?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    duration?: IntFieldUpdateOperationsInput | number
    tags?: ServiceUpdatetagsInput | string[]
    images?: ServiceUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedDateUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedDateUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedDateUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostBadgeUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostBadgeUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HostBadgeUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotographerSkillUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerSkillUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerSkillUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerGearUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    gearType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerGearUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    gearType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PhotographerGearUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    gearType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BookingCreateManyServiceInput = {
    id?: string
    userId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    promoCodeId?: string | null
    createdAt?: Date | string
  }

  export type WishlistCreateManyServiceInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ItineraryCreateManyServiceInput = {
    id?: string
    step: number
    title: string
    description: string
    duration: number
  }

  export type BookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutBookingsNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type BookingCreateManyPromoCodeInput = {
    id?: string
    userId: string
    serviceId: string
    date: Date | string
    adults?: number
    children?: number
    contactMethod: $Enums.ContactMethod
    contactDetail: string
    meetingPoint?: string | null
    totalPrice: number
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    currencyConversionLog?: CurrencyConversionLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    contactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    contactDetail?: StringFieldUpdateOperationsInput | string
    meetingPoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryLikeCreateManyStoryInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type StoryCommentCreateManyStoryInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type StoryLikeUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoryLikesNestedInput
  }

  export type StoryLikeUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryLikeUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCommentUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoryCommentsNestedInput
  }

  export type StoryCommentUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCommentUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CountryCountOutputTypeDefaultArgs instead
     */
    export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HostCountOutputTypeDefaultArgs instead
     */
    export type HostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromoCodeCountOutputTypeDefaultArgs instead
     */
    export type PromoCodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoryCountOutputTypeDefaultArgs instead
     */
    export type StoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopDestinationDefaultArgs instead
     */
    export type TopDestinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopDestinationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageDefaultArgs instead
     */
    export type LanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HostDefaultArgs instead
     */
    export type HostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HostLanguageDefaultArgs instead
     */
    export type HostLanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HostLanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotographerSkillDefaultArgs instead
     */
    export type PhotographerSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotographerSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotographerGearDefaultArgs instead
     */
    export type PhotographerGearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotographerGearDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryDefaultArgs instead
     */
    export type ItineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CurrencyConversionLogDefaultArgs instead
     */
    export type CurrencyConversionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CurrencyConversionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WishlistDefaultArgs instead
     */
    export type WishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WishlistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromoCodeDefaultArgs instead
     */
    export type PromoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromoCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HostBadgeDefaultArgs instead
     */
    export type HostBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HostBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockedDateDefaultArgs instead
     */
    export type BlockedDateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockedDateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralDefaultArgs instead
     */
    export type ReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoryDefaultArgs instead
     */
    export type StoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoryLikeDefaultArgs instead
     */
    export type StoryLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoryLikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoryCommentDefaultArgs instead
     */
    export type StoryCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoryCommentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}